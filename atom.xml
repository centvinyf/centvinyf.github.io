<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-23T10:00:04.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-100-Same Tree</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-100-Same-Tree/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-100-Same-Tree/</id>
    <published>2016-05-23T09:45:16.000Z</published>
    <updated>2016-05-23T10:00:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary trees, write a function to check if they are equal or not.&lt;/p&gt;
&lt;p&gt;Two binary trees are considered equal if they are structurally identical and the nodes have the same value.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个二叉树，写一个函数来检查它们是否相同。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用函数，检查左右子树以及根节点的值是否相同。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        bool isSameTree(TreeNode* p, TreeNode* q) {
            if(!p&amp;amp;&amp;amp;!q) return true;
            if((p&amp;amp;&amp;amp;!q)||(!p&amp;amp;&amp;amp;q)) return false;
            return (p-&amp;gt;val==q-&amp;gt;val)&amp;amp;&amp;amp;isSameTree(p-&amp;gt;left,q-&amp;gt;left)&amp;amp;&amp;amp;isSameTree(p-&amp;gt;right,q-&amp;gt;right);

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary trees, write a function to check if they are equal or not.&lt;/p&gt;
&lt;p&gt;Two binary trees are considered equal if they are structurally identical and the nodes have the same value.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-237-Delete Node in a Linked List</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-237-Delete-Node-in-a-Linked-List/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-237-Delete-Node-in-a-Linked-List/</id>
    <published>2016-05-23T09:42:16.000Z</published>
    <updated>2016-05-23T09:44:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;删除一个链表中的结点，你只能获取该结点的指针。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;有点像脑筋急转弯。很简单，将这个结点的next结点拷贝到这个结点就可以了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        void deleteNode(ListNode* node) {
            node-&amp;gt;val=node-&amp;gt;next-&amp;gt;val;
            node-&amp;gt;next=node-&amp;gt;next-&amp;gt;next;
        }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-260-Single Number III</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-260-Single-Number-III/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-260-Single-Number-III/</id>
    <published>2016-05-23T09:33:28.000Z</published>
    <updated>2016-05-23T09:41:27.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The order of the result is not important. So in the above example, [5, 3] is also correct.&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，其中有两个元素只出现了一次，其他的元素出现了2次，找出这两个只出现过一次的元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;第一步与&lt;a href=&quot;/2016/05/23/Leetcode-136-Single-Number/&quot;&gt;simgle number I&lt;/a&gt; 一样，先求出所有的数字的^结果，此时假设这两个数是a和b,那么我们已经得到了a^b的结果。那么我们如何将这两个数分开呢。^运算的结果是同位相等为0，不等为1.那么我们就可以找出a和b不相等的最低位，然后把原数组分成两个子数组，接着使用我们&lt;a href=&quot;/2016/05/23/Leetcode-136-Single-Number/&quot;&gt;simgle number I&lt;/a&gt; 中使用的方法即可求解两个数。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int tem = 0;
            for(int i=0;i&amp;lt;nums.size();i++)
                tem^=nums[i];
            int last = tem-(tem&amp;amp;(tem-1));//求出tem中最低“1”位
            int first = 0; int second = 0;
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                    if(nums[i]&amp;amp;last)
                        first^=nums[i];
                    else
                        second^=nums[i];
                }
            vector&amp;lt;int&amp;gt; ans;
            ans.push_back(first);
            ans.push_back(second);
            return ans;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The order of the result is not important. So in the above example, [5, 3] is also correct.&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-283-Move Zeroes</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-283-Move-Zeroes/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-283-Move-Zeroes/</id>
    <published>2016-05-23T09:27:42.000Z</published>
    <updated>2016-05-23T09:32:43.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must do this in-place without making a copy of the array.&lt;br&gt;Minimize the total number of operations.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，写一个函数把所有的0都移动到数组的末端且非0元素的相对位置不变。&lt;br&gt;你没有额外的存储空间来复制一遍数组。且使移动操作次数最少。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用一个指针指向第一个0的坐标，如果不是0，则交换0坐标上的数字与当前数字&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int mark = 0;
            for(int i =0;i&amp;lt;nums.size();i++)
                {
                    if(nums[i]!=0)
                           swap(nums[i],nums[mark++]);     
                }

            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must do this in-place without making a copy of the array.&lt;br&gt;Minimize the total number of operations.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-349-Intersection of Two Arrays</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/</id>
    <published>2016-05-23T09:19:50.000Z</published>
    <updated>2016-05-23T09:24:17.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result must be unique.&lt;br&gt;The result can be in any order.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;找到两个集合的交集，并且注意交集中每个元素只能出现一次。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的hash map的题，遍历a中每一个元素，只要在b中出现的，如果没有添加过，则添加到结果集合中。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; intersection(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) {
        vector&amp;lt;int&amp;gt; res;
        if(!nums1.empty()||!nums2.empty())
            for(int i=0;i&amp;lt;nums1.size();i++)
                {
                    if(find(nums2.begin(),nums2.end(),nums1[i])!=nums2.end())//if nums1[i] is in nums2
                        if(find(res.begin(),res.end(),nums1[i])==res.end())// if nums[i] not in res
                            res.push_back(nums1[i]);
                }
            return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result must be unique.&lt;br&gt;The result can be in any order.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-226-Invert Binay Tree</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-226-Invert-Binay-Tree/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-226-Invert-Binay-Tree/</id>
    <published>2016-05-23T09:04:15.000Z</published>
    <updated>2016-05-23T09:15:21.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Invert a binary tree.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     4
   /   \
  2     7
 / \   / \
1   3 6   9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      4
    /   \
  7     2
 / \   / \
9   6 3   1
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个二叉树&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用函数本身即可，注意边界条件。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
           TreeNode* invertTree(TreeNode* root) {
            if(!root) return root;
            if(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right) return root;
            else{
                TreeNode* teml = invertTree(root-&amp;gt;right);
                TreeNode* temr = invertTree(root-&amp;gt;left);
                root-&amp;gt;left= teml;
                root-&amp;gt;right=temr;
                return root;
                    }

            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Invert a binary tree.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     4
   /   \
  2     7
 / \   / \
1   3 6   9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      4
    /   \
  7     2
 / \   / \
9   6 3   1
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-104-Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/</id>
    <published>2016-05-23T09:00:29.000Z</published>
    <updated>2016-05-23T09:17:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its maximum depth.&lt;/p&gt;
&lt;p&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个二叉树，返回它的最大深度&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用本函数，返回左右子树的最大深度中较大值+1即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int maxDepth(TreeNode* root) {
            if(!root) return 0;
            else
                return max(maxDepth(root-&amp;gt;left),maxDepth(root-&amp;gt;right))+1;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its maximum depth.&lt;/p&gt;
&lt;p&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-258-Add Digits</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-258-Add-Digits/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-258-Add-Digits/</id>
    <published>2016-05-23T08:51:32.000Z</published>
    <updated>2016-05-23T09:15:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个非负整数，重复累加它的每一位，直到生成的新数字只有一位。&lt;br&gt;例如：38-》3+8=11-》1+1=2.此时返回2.&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这里提供两种方法，第一种是正常的循环解题思路，另一种是数学的方法。数学方法请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_root&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇wiki文章&lt;/a&gt;.循环解法只需要按照题目要求累加每一位数字即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int addDigits(int num) {
            switch(num)
                {
                    case 0: return 0;
                    default: return (num-1)%9+1;
                }
            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-136-Single Number</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-136-Single-Number/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-136-Single-Number/</id>
    <published>2016-05-23T08:47:34.000Z</published>
    <updated>2016-05-23T09:15:18.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears twice except for one. Find that single one.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，其中除了某一个数字以外其他数字都出现过两次，找出这个数字。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题方法有许多，这里本文介绍最简单的一种，使用位运算，一个数字a^b^b以后仍然为它本身。这样，把整个数组^一次即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int res=0;
            for(int i=0;i&amp;lt;nums.size();i++)
                res^=nums[i];

            return res;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears twice except for one. Find that single one.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-292-Nim Game</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-292-Nim-Game/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-292-Nim-Game/</id>
    <published>2016-05-23T08:40:44.000Z</published>
    <updated>2016-05-23T09:16:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;
&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;
&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;你和朋友玩一个取石子的游戏，每一个人可以取1-3个石子，假如你们俩都能每一步做出最优选择，那么当你先取的时候，输入一个石子数，返回你是否能取得胜利。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题仔细分析其实并不难。当石子数为4的整数倍的时候，总是后手胜利，因为不管先手拿走了n(1-3)枚石子，你总是拿走4-n枚，即可获胜，其他情况下，先手可以把自己变为后手，即取走余数。所以想通了这一点之后这道题变得非常简单。即判断先手是否胜利的条件在于石子数能否被4整除。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool canWinNim(int n) {
            return n%4;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;
&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;
&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-191-Number of 1 Bits</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-191-Number-of-1-Bits/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-191-Number-of-1-Bits/</id>
    <published>2016-05-23T08:06:57.000Z</published>
    <updated>2016-05-23T09:17:11.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).&lt;/p&gt;
&lt;p&gt;For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;写一个函数，返回某一数字二进制表示中1出现的次数&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用位运算中&amp;amp;操作符号，和指定数的每一位都单独&amp;amp;一次，如果是1，则会返回1，再使用一个计数器实现统计。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int hammingWeight(uint32_t n) {
            int count=0;
            for(int i=0;i&amp;lt;32;i++)
                if(n&amp;amp;1&amp;lt;&amp;lt;i) count++;

            return count;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).&lt;/p&gt;
&lt;p&gt;For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-338-Counting Bits</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-338-Counting-Bits/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-338-Counting-Bits/</id>
    <published>2016-05-23T02:26:55.000Z</published>
    <updated>2016-05-23T09:16:37.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;For num = 5 you should return [0,1,1,2,1,2].&lt;/p&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?&lt;br&gt;Space complexity should be O(n).&lt;br&gt;Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;输入一个数字，输出从0开始到该数字为止的所有数字二进制表示中1的个数.&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;对于最基本的解题思路，如果使用O(n*sizeof(integer))的时间的话,可以写一个统计某个数之中出现“1”的次数的函数，正如&lt;a href=&quot;/2016/05/23/Leetcode-191-Number-of-1-Bits/&quot;&gt;这一题&lt;/a&gt;，然后从0开始循环调用N次。&lt;br&gt;但是我们通过观察二进制的规律不难发现，除了2的整数次幂只有一个1以外，每多一位，立马会从0开始到这个数字为止全部重复一次。动态规划转移方程为a[n]=1(如果n为2的整数次幂)，a[n]=1+a[mark] （mark为我们的标记）我们用两个标记变量，一个表示2的整数次幂，另一个表示已经循环到的数字，每次经过2的整数次幂后，该标记归0。这样便能把时间复杂度降低为O(n)，而且只用使用O(n)的额外空间。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; countBits(int num) {
            vector&amp;lt;int&amp;gt; res(num+1);
            if(num==0) return res;
            else {

                res[0]=0;
                int power=1;
                int mark=1;
                for(int i =1;i&amp;lt;=num;i++)
                    {
                        if(i==power)
                            {
                                    res[i]=1;
                                    power&amp;lt;&amp;lt;=1;
                                    mark=1;
                            }else
                        {
                              res[i]=1+res[mark];
                              mark++;
                        }
                    }
                }
            return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;For num = 5 you should return [0,1,1,2,1,2].&lt;/p&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?&lt;br&gt;Space complexity should be O(n).&lt;br&gt;Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-344-Reverse String</title>
    <link href="http://yoursite.com/2016/05/22/Leetcode-344-Reverse-String/"/>
    <id>http://yoursite.com/2016/05/22/Leetcode-344-Reverse-String/</id>
    <published>2016-05-22T11:32:54.000Z</published>
    <updated>2016-05-23T09:16:26.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes a string as input and returns the string reversed.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given s = “hello”, return “olleh”.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个给定字符串&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的倒序添加每一个字符即可&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string reverseString(string s) {
        string res=&amp;quot;&amp;quot;;
        for(int i = 0; i&amp;lt;s.length();i++)
        res=s[i]+res;

        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes a string as input and returns the string reversed.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given s = “hello”, return “olleh”.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2015/10/20/Hello-World/"/>
    <id>http://yoursite.com/2015/10/20/Hello-World/</id>
    <published>2015-10-20T13:04:33.000Z</published>
    <updated>2015-10-21T14:54:12.000Z</updated>
    
    <content type="html">&lt;p&gt;由于上一次惨痛的经历。。。重装系统忘记备份博客源码。我决定使用Time Machine。。。没啥好说的，心情十分复杂，就这样。。。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;由于上一次惨痛的经历。。。重装系统忘记备份博客源码。我决定使用Time Machine。。。没啥好说的，心情十分复杂，就这样。。。&lt;/p&gt;

    
    </summary>
    
      <category term="Milestone" scheme="http://yoursite.com/categories/Milestone/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随手小记</title>
    <link href="http://yoursite.com/2015/10/15/%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/10/15/随手小记/</id>
    <published>2015-10-14T17:40:05.000Z</published>
    <updated>2015-10-21T05:41:04.000Z</updated>
    
    <content type="html">&lt;p&gt;今天终于刷完了Leetcode最后一道我能做的Easy难度。明天就要迈向Medium了。想到Z君说的easy 5分钟一道，我还是太年轻了么果然。。。加油吧。。。坚持就是胜利！逐渐成为一个合格的码农！不过通过这两周来的训练，我觉得我自己的代码能力确实有了一个很大的提升。No pains, no gains.加油吧。从0到1比从1到2难多了，非常庆幸自己能迈出第一步。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天终于刷完了Leetcode最后一道我能做的Easy难度。明天就要迈向Medium了。想到Z君说的easy 5分钟一道，我还是太年轻了么果然。。。加油吧。。。坚持就是胜利！逐渐成为一个合格的码农！不过通过这两周来的训练，我觉得我自己的代码能力确实有了一个很大的提升。No 
    
    </summary>
    
      <category term="Milestone" scheme="http://yoursite.com/categories/Milestone/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Latex使用经验1——用bibtex添加引用</title>
    <link href="http://yoursite.com/2015/10/02/Latex%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C1%E2%80%94%E2%80%94%E7%94%A8bibtex%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2015/10/02/Latex使用经验1——用bibtex添加引用/</id>
    <published>2015-10-02T13:34:08.000Z</published>
    <updated>2015-10-21T01:39:34.000Z</updated>
    
    <content type="html">&lt;p&gt;用bibtex添加引用&lt;/p&gt;
&lt;h2 id=&quot;第一步：建立一个tex文件&quot;&gt;&lt;a href=&quot;#第一步：建立一个tex文件&quot; class=&quot;headerlink&quot; title=&quot;第一步：建立一个tex文件&quot;&gt;&lt;/a&gt;第一步：建立一个tex文件&lt;/h2&gt;&lt;p&gt;任何一种你想要方法建立一个tex文件，假如说叫a.tex&lt;/p&gt;
&lt;p&gt;在文章末尾\end{document}之前加入以下三行：&lt;br&gt;\renewcommand\refname{Reference}&lt;br&gt;\bibliographystyle{plain}&lt;br&gt;\bibliography{b}&lt;br&gt;其中第一行是参考文献的标题，标题是Reference；第二行是格式，还有其他格式见此处，这里用plain；第三行是一个bib格式文件的名字，最好和tex文件名称一致，编译起来方便一些。&lt;br&gt;(有一点小小要注意的地方：最常见的引用格式是plain，它是按作者字母排序的，如果要按引用顺序来排序，推荐用格式unsrt)&lt;/p&gt;
&lt;h2 id=&quot;第二步：建立一个bib文件&quot;&gt;&lt;a href=&quot;#第二步：建立一个bib文件&quot; class=&quot;headerlink&quot; title=&quot;第二步：建立一个bib文件&quot;&gt;&lt;/a&gt;第二步：建立一个bib文件&lt;/h2&gt;&lt;p&gt;bib文件就是一个plain text文件，明明为b.bib，bib格式可以在各种数据库里面的citation找到，例如&lt;br&gt;@book{Book1,&lt;br&gt;title = “Title1”,&lt;br&gt;author = “author1”,&lt;br&gt;publisher = “publisher1”,&lt;br&gt;year = “2015”&lt;br&gt;}&lt;/p&gt;
&lt;h2 id=&quot;第三步：在tex文件中引用&quot;&gt;&lt;a href=&quot;#第三步：在tex文件中引用&quot; class=&quot;headerlink&quot; title=&quot;第三步：在tex文件中引用&quot;&gt;&lt;/a&gt;第三步：在tex文件中引用&lt;/h2&gt;&lt;p&gt;在需要引用的地方使用\cite{Book1},期中Book1是你在bib文件中给每个引用的名字&lt;/p&gt;
&lt;h2 id=&quot;第四步：运行-tex文件&quot;&gt;&lt;a href=&quot;#第四步：运行-tex文件&quot; class=&quot;headerlink&quot; title=&quot;第四步：运行.tex文件&quot;&gt;&lt;/a&gt;第四步：运行.tex文件&lt;/h2&gt;&lt;p&gt;可以直接运行texshop里面的排版或者用命令行 pdflatex a(a是咱们.tex文件的名字)&lt;/p&gt;
&lt;h2 id=&quot;第五步：运行-bib文件&quot;&gt;&lt;a href=&quot;#第五步：运行-bib文件&quot; class=&quot;headerlink&quot; title=&quot;第五步：运行.bib文件&quot;&gt;&lt;/a&gt;第五步：运行.bib文件&lt;/h2&gt;&lt;p&gt;用bibtex b(b是咱们.bib文件的名字)，注意：一定要先运行pdflatex命令，因为运行后会生成aux文件，而编译bib是需要aux文件的、&lt;/p&gt;
&lt;h2 id=&quot;第六步：运行-tex文件2次&quot;&gt;&lt;a href=&quot;#第六步：运行-tex文件2次&quot; class=&quot;headerlink&quot; title=&quot;第六步：运行.tex文件2次&quot;&gt;&lt;/a&gt;第六步：运行.tex文件2次&lt;/h2&gt;&lt;p&gt;对，你没看错，运行2次，才能正确生成引用和引用目录，原理我也不知道，就这么用就行了！pdflatex a 这个命令运行2次就行了&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;用bibtex添加引用&lt;/p&gt;
&lt;h2 id=&quot;第一步：建立一个tex文件&quot;&gt;&lt;a href=&quot;#第一步：建立一个tex文件&quot; class=&quot;headerlink&quot; title=&quot;第一步：建立一个tex文件&quot;&gt;&lt;/a&gt;第一步：建立一个tex文件&lt;/h2&gt;&lt;p&gt;任何一种你想要
    
    </summary>
    
      <category term="Latex" scheme="http://yoursite.com/categories/Latex/"/>
    
    
      <category term="Latex" scheme="http://yoursite.com/tags/Latex/"/>
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>今天的月亮很美</title>
    <link href="http://yoursite.com/2015/10/01/%E4%BB%8A%E5%A4%A9%E7%9A%84%E6%9C%88%E4%BA%AE%E5%BE%88%E7%BE%8E/"/>
    <id>http://yoursite.com/2015/10/01/今天的月亮很美/</id>
    <published>2015-10-01T13:09:42.000Z</published>
    <updated>2015-10-21T01:40:05.000Z</updated>
    
    <content type="html">&lt;p&gt;前几天中秋节，在美帝幸运地看到了血月和月全食之后。突然想起了夏目漱石问学生如何翻译“i love you”这个问题。他给学生的答案是“今天的月亮很美”。想起曾经和人谈论过这个问题，当时觉得有种听到“今天的风儿真是喧嚣”的感觉。其实我觉得我现在能理解了这种观点。就仿佛是我期待着下雪，想到下雪后的第一件事就是拍张照片，然后告诉某人，“下雪了”，这是一样的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前几天中秋节，在美帝幸运地看到了血月和月全食之后。突然想起了夏目漱石问学生如何翻译“i love you”这个问题。他给学生的答案是“今天的月亮很美”。想起曾经和人谈论过这个问题，当时觉得有种听到“今天的风儿真是喧嚣”的感觉。其实我觉得我现在能理解了这种观点。就仿佛是我期待
    
    </summary>
    
      <category term="Mood" scheme="http://yoursite.com/categories/Mood/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>TableView上方总是有一截留白的解决方法</title>
    <link href="http://yoursite.com/2015/09/29/TableView%E4%B8%8A%E6%96%B9%E6%80%BB%E6%98%AF%E6%9C%89%E4%B8%80%E6%88%AA%E7%95%99%E7%99%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2015/09/29/TableView上方总是有一截留白的解决方法/</id>
    <published>2015-09-29T13:07:41.000Z</published>
    <updated>2015-10-21T01:43:15.000Z</updated>
    
    <content type="html">&lt;p&gt;不知道从哪个版本（大概是iOS8）开始，如果你用了autolayout，当你设置某个tableview（或者任意scrollview）顶部约束为顶格的适合，它总会多出来一个留白，其实解决方法很简单，在该viewcontroller的.m文件中把automaticallyAdjustsScrollViewInsets这个属性设置成false就可以了。鬼知道谁设计的留白。。。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不知道从哪个版本（大概是iOS8）开始，如果你用了autolayout，当你设置某个tableview（或者任意scrollview）顶部约束为顶格的适合，它总会多出来一个留白，其实解决方法很简单，在该viewcontroller的.m文件中把automaticallyAd
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="TableView" scheme="http://yoursite.com/tags/TableView/"/>
    
  </entry>
  
</feed>
