<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://since1992.org/"/>
  <updated>2016-06-24T03:14:18.000Z</updated>
  <id>http://since1992.org/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-19-Remove Nth Node From End of List</title>
    <link href="http://since1992.org/2016/06/24/Leetcode-19-Remove-Nth-Node-From-End-of-List/"/>
    <id>http://since1992.org/2016/06/24/Leetcode-19-Remove-Nth-Node-From-End-of-List/</id>
    <published>2016-06-24T03:11:57.000Z</published>
    <updated>2016-06-24T03:14:18.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;   Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;/p&gt;
&lt;p&gt;   After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;br&gt;Note:&lt;br&gt;Given n will always be valid.&lt;br&gt;Try to do this in one pass.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;移除倒数第N个结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用双指针，让快指针先走，主要要删除的结点为首尾的情况。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Definition for singly-linked list.&lt;/li&gt;
&lt;li&gt;struct ListNode {&lt;/li&gt;
&lt;li&gt;int val;&lt;/li&gt;
&lt;li&gt;ListNode *next;&lt;/li&gt;
&lt;li&gt;ListNode(int x) : val(x), next(NULL) {}&lt;/li&gt;
&lt;li&gt;&lt;p&gt;};&lt;br&gt;*/&lt;br&gt;class Solution {&lt;br&gt; public:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ListNode* removeNthFromEnd(ListNode* head, int n) {
    if(!head-&amp;gt;next&amp;amp;&amp;amp;n==1) return NULL;
    ListNode* fast = head;
    ListNode* slow = fast;
    for(int i=0;i&amp;lt;n;i++)
    fast=fast-&amp;gt;next;
    if(!fast) return head-&amp;gt;next;
    while(fast-&amp;gt;next){
        fast=fast-&amp;gt;next;
        slow=slow-&amp;gt;next;
    }
    slow-&amp;gt;next=slow-&amp;gt;next-&amp;gt;next;
    return head;

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; };&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;   Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;/p&gt;
&lt;p&gt;   After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;br&gt;Note:&lt;br&gt;Given n will always be valid.&lt;br&gt;Try to do this in one pass.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-205-Isomorphic Strings</title>
    <link href="http://since1992.org/2016/06/24/Leetcode-205-Isomorphic-Strings/"/>
    <id>http://since1992.org/2016/06/24/Leetcode-205-Isomorphic-Strings/</id>
    <published>2016-06-24T02:12:59.000Z</published>
    <updated>2016-06-24T02:17:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;/p&gt;
&lt;p&gt;Two strings are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;p&gt;All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given “egg”, “add”, return true.&lt;/p&gt;
&lt;p&gt;Given “foo”, “bar”, return false.&lt;/p&gt;
&lt;p&gt;Given “paper”, “title”, return true.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个字符串，判断它们是否是相似的。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用两个哈希表判断两个字符之间是否是一一对应的即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isIsomorphic(string s, string t) {
        std::map&amp;lt;char,char&amp;gt; m;
        std::map&amp;lt;char,char&amp;gt; mr;
        std::map&amp;lt;char,char&amp;gt;::iterator it;
        std::map&amp;lt;char,char&amp;gt;::iterator itr;
        for(int i = 0; i &amp;lt; s.length(); i++)
        {  
           it  = m.find(s[i]);
           itr = mr.find(t[i]);
           if(it!=m.end()||itr!=mr.end())
           {
               if(m[s[i]]!=t[i]||mr[t[i]]!=s[i]) return false;
           }else{
               m[s[i]]=t[i];
               mr[t[i]]=s[i];
           }
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;/p&gt;
&lt;p&gt;Two strings are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;p&gt;All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given “egg”, “add”, return true.&lt;/p&gt;
&lt;p&gt;Given “foo”, “bar”, return false.&lt;/p&gt;
&lt;p&gt;Given “paper”, “title”, return true.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-223-Rectangle Area</title>
    <link href="http://since1992.org/2016/06/23/Leetcode-223-Rectangle-Area/"/>
    <id>http://since1992.org/2016/06/23/Leetcode-223-Rectangle-Area/</id>
    <published>2016-06-23T13:15:40.000Z</published>
    <updated>2016-06-23T14:07:10.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Find the total area covered by two rectilinear rectangles in a 2D plane.&lt;/p&gt;
&lt;p&gt;Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.&lt;br&gt;&lt;a href=&quot;https://leetcode.com/static/images/problemset/rectangle_area.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;br&gt;Assume that the total area is never beyond the maximum possible value of int.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;求出两个矩形覆盖的面积值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;分重叠与无重叠两种情况讨论，很简单。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        int AreaA = (C-A)*(D-B);
        int AreaB = (G-E)*(H-F);
        if(A&amp;gt;=G||C&amp;lt;=E||B&amp;gt;=H||F&amp;gt;=D) return AreaA+AreaB;
        int cover = max(min(C,G)-max(A,E),0)*max(min(D,H)-max(F,B),0);
        return AreaA+AreaB-cover;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Find the total area covered by two rectilinear rectangles in a 2D plane.&lt;/p&gt;
&lt;p&gt;Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.&lt;br&gt;&lt;a href=&quot;https://leetcode.com/static/images/problemset/rectangle_area.png&quot;&gt;&lt;/a&gt;&lt;br&gt;Assume that the total area is never beyond the maximum possible value of int.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-88-Merge Sorted Array</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-88-Merge-Sorted-Array/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-88-Merge-Sorted-Array/</id>
    <published>2016-06-19T10:17:53.000Z</published>
    <updated>2016-06-19T10:19:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;合并两个排了序的数组到nums1。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题简单，从后开始往前合并即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) {
        while(m&amp;gt;0&amp;amp;&amp;amp;n&amp;gt;0)
        {
            if(nums1[m-1]&amp;gt;nums2[n-1]){
                nums1[m+n-1]=nums1[m-1];
                m--;
            }else{
                nums1[m+n-1]=nums2[n-1];
                n--;
            }

        }
        if(n&amp;gt;0)
        {
            for(int i=0;i&amp;lt;n;i++)
            nums1[i]=nums2[i];
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-299-Bulls and Cows</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-299-Bulls-and-Cows/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-299-Bulls-and-Cows/</id>
    <published>2016-06-19T10:06:23.000Z</published>
    <updated>2016-06-19T10:19:46.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulls_and_Cows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bulls and Cows&lt;/a&gt; game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1807”&lt;br&gt;Friend’s guess: “7810”&lt;br&gt;Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)&lt;br&gt;Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.&lt;/p&gt;
&lt;p&gt;Please note that both secret number and friend’s guess may contain duplicate digits, for example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1123”&lt;br&gt;Friend’s guess: “0111”&lt;br&gt;In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.&lt;br&gt;You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;朋友猜你所想的数字，如果数字与位置均正确记为A，如果数字正确位置错误记为B。输出”XAYB“的结果&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用两个数组统计每个数字出现的次数，然后就可以输出结果了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string getHint(string secret, string guess) {
        if(!secret.length()||!guess.length()) return &amp;quot;0A0B&amp;quot;;
        vector&amp;lt;int&amp;gt;countS(10,0);
        vector&amp;lt;int&amp;gt;countG(10,0);
        int A=0;
        int B=0;
        for(int i=0;i&amp;lt;secret.length();i++)
        {
            if(secret[i]==guess[i])
            A++;
            else{
                countS[secret[i]-&amp;apos;0&amp;apos;]++;
                countG[guess[i]-&amp;apos;0&amp;apos;]++;
            }
        }
        for(int i=0;i&amp;lt;10;i++)
        {
            B+=min(countS[i],countG[i]);
        }
        string res=&amp;quot;&amp;quot;;
        res+=num2str(A);
        res+=&amp;apos;A&amp;apos;;
        res+=num2str(B);
        res+=&amp;apos;B&amp;apos;;
        return res;
    }
    string num2str(int n)
    {
        if(n==0) return &amp;quot;0&amp;quot;;
        string res=&amp;quot;&amp;quot;;
        while(n&amp;gt;0)
        {
            res=(char)((n%10)+&amp;apos;0&amp;apos;)+res;
            n/=10;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulls_and_Cows&quot;&gt;Bulls and Cows&lt;/a&gt; game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1807”&lt;br&gt;Friend’s guess: “7810”&lt;br&gt;Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)&lt;br&gt;Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.&lt;/p&gt;
&lt;p&gt;Please note that both secret number and friend’s guess may contain duplicate digits, for example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1123”&lt;br&gt;Friend’s guess: “0111”&lt;br&gt;In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.&lt;br&gt;You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-219-Contains Duplicate II</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-219-Contains-Duplicate-II/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-219-Contains-Duplicate-II/</id>
    <published>2016-06-19T09:50:00.000Z</published>
    <updated>2016-06-19T10:19:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组和一个数字N，求数组里又没有间隔N以下的相等值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;维护一个大小为K的滑动窗口，只需要O（n）的时间即可。注意K大于数组容量的情况。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        if(nums.empty()||k&amp;lt;1) return false;
        set&amp;lt;int&amp;gt; s;
        if(k&amp;gt;nums.size())
        {
            for(int i=0;i&amp;lt;nums.size();i++){
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);

            }
              return false;  
        }
        else
        {
            for(int i=0;i&amp;lt;k;i++)
            {
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);
            }
            for(int j=k;j&amp;lt;nums.size();j++)
            {

                if(s.find(nums[j])!=s.end())
                return true;
                else{
                s.insert(nums[j]);
                s.erase(nums[j-k]);
                }
            }
            return false;
        }


    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-160-Intersection of Two Linked Lists</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-160-Intersection-of-Two-Linked-Lists/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-160-Intersection-of-Two-Linked-Lists/</id>
    <published>2016-06-19T09:38:27.000Z</published>
    <updated>2016-06-19T10:19:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;The linked lists must retain their original structure after the function returns.&lt;br&gt;You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;Your code should preferably run in O(n) time and use only O(1) memory.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给两个单向链表，返回他们的交接处，如果没有交接，则返回空指针，只能使用O(1)的额外空间，且不可以修改原链表。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;统计出两个链表的节点数，让长的那个从头去掉相差额的结点，则相遇即相交。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA||!headB) return NULL;
        int counta=0;
        int countb=0;
        ListNode* a= headA;
        ListNode* b= headB;
        while(a)
        {
            counta++;
            a=a-&amp;gt;next;
        }
        while(b)
        {
            countb++;
            b=b-&amp;gt;next;
        }
        int dif = counta-countb;

            for(int i=abs(dif);i&amp;gt;0;i--)
            {
                if(dif &amp;gt; 0)
                    headA=headA-&amp;gt;next;
                else headB=headB-&amp;gt;next;
            }
        while(headA&amp;amp;&amp;amp;headB&amp;amp;&amp;amp;headA!=headB)
        {
            headA=headA-&amp;gt;next;
            headB=headB-&amp;gt;next;
        }
        ListNode * res;
        headA==headB?res=headA:res=NULL;
        return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;The linked lists must retain their original structure after the function returns.&lt;br&gt;You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;Your code should preferably run in O(n) time and use only O(1) memory.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-225-Implement Stack using Queues</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-225-Implement-Stack-using-Queues/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-225-Implement-Stack-using-Queues/</id>
    <published>2016-06-19T09:03:06.000Z</published>
    <updated>2016-06-19T09:05:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;empty() – Return whether the stack is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;用队列实现栈的操作。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;和&lt;a href=&quot;/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/&quot;&gt;这道题&lt;/a&gt;类似，注意对应变量关系即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Stack {

public:
    queue&amp;lt;int&amp;gt; q1;
    queue&amp;lt;int&amp;gt; q2;
    int count = 0;
    // Push element x onto stack.
    void push(int x) {
        q1.push(x);
        count++;
    }

    // Removes the element on top of the stack.
    void pop() {
        while(count&amp;gt;1)
        {
            q2.push(q1.front());
            q1.pop();
            count--;
        }
        q1.pop();
        count--;
        while(!q2.empty())
        {
            q1.push(q2.front());
            count++;
            q2.pop();
        }
    }

    // Get the top element.
    int top() {
      return q1.back();

    }

    // Return whether the stack is empty.
    bool empty() {
        return q1.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;empty() – Return whether the stack is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
      <category term="Design" scheme="http://since1992.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-111-Minimum Depth of Binary Tree</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-111-Minimum-Depth-of-Binary-Tree/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-111-Minimum-Depth-of-Binary-Tree/</id>
    <published>2016-06-19T08:49:34.000Z</published>
    <updated>2016-06-19T10:19:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;p&gt;The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵树，找出它从根节点到某一叶子节点的最短路径。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题和&lt;a href=&quot;/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/&quot;&gt;找出最长路径&lt;/a&gt;的做法不太一样。不能直接取左右较短者加一，因为有可能某个子树是空的。细心判断即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        int minl = minDepth(root-&amp;gt;left);
        int minr = minDepth(root-&amp;gt;right);
        int minx = min(minl,minr);
        minx==0?minx=minl+minr:minx=minx;
        return minx+1;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;p&gt;The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-12-Path Sum</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-112-Path-Sum/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-112-Path-Sum/</id>
    <published>2016-06-19T08:15:00.000Z</published>
    <updated>2016-06-19T08:53:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given the below binary tree and sum = 22,&lt;br&gt;              5&lt;br&gt;             / \&lt;br&gt;            4   8&lt;br&gt;           /   / \&lt;br&gt;          11  13  4&lt;br&gt;         /  \      \&lt;br&gt;        7    2      1&lt;br&gt;return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，判断是否有从根到叶子节点的路径和等于给定值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的递归调用函数即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(!root) return false;
        sum-=root-&amp;gt;val;
        return hasPathSum(root-&amp;gt;left,sum)||hasPathSum(root-&amp;gt;right,sum)||(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right&amp;amp;&amp;amp;sum==0);
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given the below binary tree and sum = 22,&lt;br&gt;              5&lt;br&gt;             / \&lt;br&gt;            4   8&lt;br&gt;           /   / \&lt;br&gt;          11  13  4&lt;br&gt;         /  \      \&lt;br&gt;        7    2      1&lt;br&gt;return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-9-Palindrome Number</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-9-Palindrome-Number/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-9-Palindrome-Number/</id>
    <published>2016-06-19T07:46:50.000Z</published>
    <updated>2016-06-19T07:48:43.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Determine whether an integer is a palindrome. Do this without extra space.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;判断一个整数是否是对称数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;首先负数肯定不是对称的。然后可以把数字转化成字符串，存成两个正\反序的字符串，如果这两个字符串相等，则是对称的。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;class Solution {&lt;br&gt;    public:&lt;br&gt;        bool isPalindrome(int x) {&lt;br&gt;            if(x&lt;0) return=&quot;&quot; false;=&quot;&quot; string=&quot;&quot; a=&quot;&quot; ,b=&quot;&quot; ;=&quot;&quot; while(x=&quot;&quot;&gt;0)&lt;br&gt;            {&lt;br&gt;                a+=(char)(x%10+’0’);&lt;br&gt;                b=(char)(x%10+’0’)+b;&lt;br&gt;                x/=10;&lt;br&gt;            }&lt;br&gt;            return a==b;&lt;br&gt;        }&lt;br&gt;    };&lt;/0)&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Determine whether an integer is a palindrome. Do this without extra space.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-119-Pascal&#39;s Triangle II</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-119-Pascal-s-Triangle-II/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-119-Pascal-s-Triangle-II/</id>
    <published>2016-06-19T04:09:19.000Z</published>
    <updated>2016-06-19T04:10:57.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an index k, return the kth row of the Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given k = 3,&lt;br&gt;Return [1,3,3,1].&lt;br&gt;Note:&lt;br&gt;Could you optimize your algorithm to use only O(k) extra space?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字N，返回帕斯卡三角的第N行结果。只能使用 O(k)的额外空间。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用循环累加的办法生成对应行即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; getRow(int rowIndex) {
        vector&amp;lt;int&amp;gt; row(1,1);
        if(rowIndex&amp;lt;1) return row;
        for(int i=1;i&amp;lt;=rowIndex;i++)
        {
            int prev1=row[0];
            int prev2;
            for(int j=1;j&amp;lt;i;j++)
                {
                    prev2=row[j];
                    row[j]+=prev1;
                    prev1=prev2;
                }
            row.push_back(1);
        }
        return row;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an index k, return the kth row of the Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given k = 3,&lt;br&gt;Return [1,3,3,1].&lt;br&gt;Note:&lt;br&gt;Could you optimize your algorithm to use only O(k) extra space?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-172-Factorial Trailing Zeroes</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-172-Factorial-Trailing-Zeroes/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-172-Factorial-Trailing-Zeroes/</id>
    <published>2016-06-19T03:35:30.000Z</published>
    <updated>2016-06-19T03:37:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;p&gt;Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个整数N，返回n的阶乘的结果中末尾0的个数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;其实很简单，就是考的1-n中有几个5的因子，注意到5的次幂有不止1个因子5即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int trailingZeroes(int n) {
        int count=0;
        while(n&amp;gt;1)
        {
            count+=n/5;
            n/=5;
        }
       return count; 
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;p&gt;Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-102-Binary Tree Level Order Traversal</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-102-Binary-Tree-Level-Order-Traversal/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2016-06-19T03:30:09.000Z</published>
    <updated>2016-06-19T03:32:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its level order traversal as:&lt;br&gt;    [&lt;br&gt;      [3],&lt;br&gt;      [9,20],&lt;br&gt;      [15,7]&lt;br&gt;    ]&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回层次遍历的结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题和&lt;a href=&quot;/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/&quot;&gt;这道题&lt;/a&gt;一样，没什么好说的，很简单利用一个队列完成BFS操作。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
        vector&amp;lt;int&amp;gt; tem;
        if(!root) return res;
        queue&amp;lt;TreeNode*&amp;gt; q;
        q.push(root);
        q.push(NULL);
        while(!q.empty())
        {
            TreeNode* t=q.front();
            q.pop();
            if(t)
            {
                tem.push_back(t-&amp;gt;val);
                if(t-&amp;gt;left)
                    q.push(t-&amp;gt;left);
                if(t-&amp;gt;right)
                    q.push(t-&amp;gt;right);
            }else{
                if(!q.empty())
                {
                    res.push_back(tem);
                    tem.clear();
                    q.push(NULL);
                }else{
                    res.push_back(tem);
                }
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its level order traversal as:&lt;br&gt;    [&lt;br&gt;      [3],&lt;br&gt;      [9,20],&lt;br&gt;      [15,7]&lt;br&gt;    ]&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="BFS" scheme="http://since1992.org/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-26-Remove Duplicates from Sorted Array</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-26-Remove-Duplicates-from-Sorted-Array/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-26-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2016-06-19T02:58:32.000Z</published>
    <updated>2016-06-19T03:01:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given input array nums = [1,1,2],&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个已排序的数组，去除重复元素， 然后返回新的长度，只能使用O(1)的额外空间。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的一次遍历即可。当某个数比它前一个数大的时候说明它是新的一个未重复元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int count=0;
        if(nums.empty()) return count;
        count++;
        for(int i=1;i&amp;lt;nums.size();i++)
        {
          if(nums[i]&amp;gt;nums[i-1])
            nums[count++]=nums[i];
        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given input array nums = [1,1,2],&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-118-Pascal&#39;s Triangle</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-118-Pascal-s-Triangle/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-118-Pascal-s-Triangle/</id>
    <published>2016-06-18T14:14:33.000Z</published>
    <updated>2016-06-18T14:16:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given numRows, generate the first numRows of Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given numRows = 5,&lt;br&gt;Return&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字N，生成前N行帕斯卡三角。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;至于什么是帕斯卡三角，可以参加&lt;a href=&quot;https://en.wikipedia.org/wiki/Pascal%27s_triangle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt;,找出规律以后写代码就容易了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans;
        if(numRows&amp;lt;=0) return ans;
        ans.resize(numRows);
        for(int i=0;i&amp;lt;numRows;i++)
        {
            ans[i].resize(i+1,1);
            for(int j=1;j&amp;lt;i;j++)
            ans[i][j]=ans[i-1][j]+ans[i-1][j-1];
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given numRows, generate the first numRows of Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given numRows = 5,&lt;br&gt;Return&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-232-Implement Queue using Stacks</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/</id>
    <published>2016-06-18T13:45:20.000Z</published>
    <updated>2016-06-18T13:47:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a queue using stacks.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x to the back of queue.&lt;br&gt;pop() – Removes the element from in front of queue.&lt;br&gt;peek() – Get the front element.&lt;br&gt;empty() – Return whether the queue is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.&lt;br&gt;Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.&lt;br&gt;You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;用栈实现队列的操作。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单，用两个栈即可取到任意一端的元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Queue {
    stack&amp;lt;int&amp;gt; s1;
    stack&amp;lt;int&amp;gt; s2;
public:
    // Push element x to the back of queue.
    void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        s2.pop();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }

    }

    // Get the front element.
    int peek(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        int p = s2.top();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }
        return p;
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return s1.empty();

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a queue using stacks.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x to the back of queue.&lt;br&gt;pop() – Removes the element from in front of queue.&lt;br&gt;peek() – Get the front element.&lt;br&gt;empty() – Return whether the queue is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.&lt;br&gt;Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.&lt;br&gt;You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
      <category term="Design" scheme="http://since1992.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-66-Plus One</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-66-Plus-One/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-66-Plus-One/</id>
    <published>2016-06-18T13:36:38.000Z</published>
    <updated>2016-06-18T13:37:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative number represented as an array of digits, plus one to the number.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个数组表示一个数字，返回它加一的结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的一道题，注意进位的处理，以及全9的情况即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) {
        int i = digits.size()-1;
        while(i&amp;gt;=0)
        {
            if(digits[i]&amp;lt;9){
                digits[i]++;
                return digits;
            }
            digits[i--]=0;

        }
        digits.insert(digits.begin(),1);
        return digits;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative number represented as an array of digits, plus one to the number.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-342-Power of Four</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-342-Power-of-Four/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-342-Power-of-Four/</id>
    <published>2016-06-18T11:18:22.000Z</published>
    <updated>2016-06-20T10:32:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given num = 16, return true. Given num = 5, return false.&lt;/p&gt;
&lt;p&gt;Follow up: Could you solve it without loops/recursion?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个32位的整数，判断它是否是4的幂。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本体与&lt;a href=&quot;/2016/06/07/Leetcode-231-Power-of-Two/&quot;&gt;求2的幂&lt;/a&gt;和&lt;a href=&quot;/2016/06/07/Leetcode-326-Power-of-Tree/&quot;&gt;求3的幂&lt;/a&gt;类似，解法可参加这两题。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isPowerOfFour(int num) {
        while(num&amp;gt;1&amp;amp;&amp;amp;num%4==0)
        {
            num/=4;
        }
        return num==1;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given num = 16, return true. Given num = 5, return false.&lt;/p&gt;
&lt;p&gt;Follow up: Could you solve it without loops/recursion?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-107-Binary Tree Level Order Traversal II</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/</id>
    <published>2016-06-18T10:26:12.000Z</published>
    <updated>2016-06-18T10:28:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its bottom-up level order traversal as:&lt;br&gt;    [&lt;br&gt;      [15,7],&lt;br&gt;      [9,20],&lt;br&gt;      [3]&lt;br&gt;    ]&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回从底至顶的层次遍历结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用一个辅助队列完成BFS.再反向存储数组即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Definition for a binary tree node.&lt;/li&gt;
&lt;li&gt;struct TreeNode {&lt;/li&gt;
&lt;li&gt;int val;&lt;/li&gt;
&lt;li&gt;TreeNode *left;&lt;/li&gt;
&lt;li&gt;TreeNode *right;&lt;/li&gt;
&lt;li&gt;TreeNode(int x) : val(x), left(NULL), right(NULL) {}&lt;/li&gt;
&lt;li&gt;};&lt;br&gt;*/&lt;br&gt;class Solution {&lt;br&gt; public:&lt;pre&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrderBottom(TreeNode* root) {
    vector&amp;lt;int&amp;gt; tem;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans;
    queue &amp;lt;TreeNode*&amp;gt; q;
    if(!root) return ans;
    q.push(root);
    q.push(NULL);
    while(!q.empty())
    {
        TreeNode * t = q.front();
        q.pop();
        if(t){
            tem.push_back(t-&amp;gt;val);
            if(t-&amp;gt;left)
            q.push(t-&amp;gt;left);
            if(t-&amp;gt;right)
            q.push(t-&amp;gt;right);
        }else
        {
            if(!q.empty()){
            ans.push_back(tem);
            tem.clear();
            q.push(NULL);}
            else
            ans.push_back(tem);
        }
    }
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    for(int i=ans.size()-1;i&amp;gt;=0;i--)
    res.push_back(ans[i]);
    return res;
}
&lt;/code&gt;&lt;/pre&gt; };&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its bottom-up level order traversal as:&lt;br&gt;    [&lt;br&gt;      [15,7],&lt;br&gt;      [9,20],&lt;br&gt;      [3]&lt;br&gt;    ]&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="BFS" scheme="http://since1992.org/tags/BFS/"/>
    
  </entry>
  
</feed>
