<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-06-10T15:18:54.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-121-Best Time to Buy and Sell Stock</title>
    <link href="http://yoursite.com/2016/06/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>http://yoursite.com/2016/06/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2016-06-10T15:17:29.000Z</published>
    <updated>2016-06-10T15:18:54.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;有一个数组表示一段时间内某只股票每天的价格，如果你只能买卖一次，求你能获得的最大利润&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;依次找到最小值，然后再记录最大差值，返回最大差值即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {
        if(prices.size()&amp;lt;2) return 0;
        vector&amp;lt;int&amp;gt;dp(prices.size(),0);
        int max=INT_MIN;
        int min=prices[0];
        for(int i=1;i&amp;lt;prices.size();i++)
        {
            if(prices[i]&amp;lt;min) min=prices[i];
            dp[i]=prices[i]-min;
            if(dp[i]&amp;gt;max)
            max=dp[i];

        }
        return max;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-153-Find Minimum in Rotated Sorted Array</title>
    <link href="http://yoursite.com/2016/06/10/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://yoursite.com/2016/06/10/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2016-06-10T14:53:48.000Z</published>
    <updated>2016-06-10T14:56:57.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).&lt;/p&gt;
&lt;p&gt;Find the minimum element.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;某个排好序的数组从某一点开始到数组结尾，被全体移动到数组的最开始位置。求这个数组的最小值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;求数组的最小值，一般情况下需要遍历一次数组，即用O(n)的时间，不过这道题给定的是预先排好序的数组，而且是被移动的是整个子序列，所以我们可以使用二分查找的办法，把时间复杂度缩短到O(logn)。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if(nums.size()==1) return nums[0];
        int begin=0,end=nums.size()-1,mid=begin+(end-begin)/2;
        while(begin&amp;lt;end)
        {
            if(nums[mid]&amp;gt;nums[mid+1]) return nums[mid+1];
            else if(nums[mid]&amp;lt;nums[end])
            {
                end=mid;
                mid=begin+(end-begin)/2;
            }
            else if(nums[mid]&amp;gt;nums[end])
            {
                begin=mid;
                mid=begin+(end-begin)/2;
            }

        }
        return nums[end];

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).&lt;/p&gt;
&lt;p&gt;Find the minimum element.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-116-Populating Next Right Pointers in Each Node</title>
    <link href="http://yoursite.com/2016/06/10/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/"/>
    <id>http://yoursite.com/2016/06/10/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/</id>
    <published>2016-06-10T14:41:03.000Z</published>
    <updated>2016-06-10T14:45:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may only use constant extra space.&lt;br&gt;You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).&lt;br&gt;For example,&lt;br&gt;Given the following perfect binary tree,&lt;br&gt;             1&lt;br&gt;           /  \&lt;br&gt;          2    3&lt;br&gt;         / \  / \&lt;br&gt;        4  5  6  7&lt;br&gt;After calling your function, the tree should look like:&lt;br&gt;             1 -&amp;gt; NULL&lt;br&gt;           /  \&lt;br&gt;          2 -&amp;gt; 3 -&amp;gt; NULL&lt;br&gt;         / \  / \&lt;br&gt;        4-&amp;gt;5-&amp;gt;6-&amp;gt;7 -&amp;gt; NULL&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一棵树添加右指针，每一行的末尾指向NULL。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的DFS的问题，利用一个队列，完成层次遍历即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(!root) return;
        queue&amp;lt;TreeLinkNode*&amp;gt; q;
        q.push(root);
        q.push(NULL);
        while(!q.empty())
        {
            TreeLinkNode *tem = q.front();
            q.pop();

            if(tem)
            {
                tem-&amp;gt;next=q.front();
                if(tem-&amp;gt;left)
                    q.push(tem-&amp;gt;left);
                if(tem-&amp;gt;right)
                    q.push(tem-&amp;gt;right);

            }
            else
            {
                if(!q.empty())
                {
                    q.push(NULL);
                    continue;
                }
                else break;
            }
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may only use constant extra space.&lt;br&gt;You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).&lt;br&gt;For example,&lt;br&gt;Given the following perfect binary tree,&lt;br&gt;             1&lt;br&gt;           /  \&lt;br&gt;          2    3&lt;br&gt;         / \  / \&lt;br&gt;        4  5  6  7&lt;br&gt;After calling your function, the tree should look like:&lt;br&gt;             1 -&amp;gt; NULL&lt;br&gt;           /  \&lt;br&gt;          2 -&amp;gt; 3 -&amp;gt; NULL&lt;br&gt;         / \  / \&lt;br&gt;        4-&amp;gt;5-&amp;gt;6-&amp;gt;7 -&amp;gt; NULL&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-62-Unique Paths</title>
    <link href="http://yoursite.com/2016/06/10/Leetcode-62-Unique-Paths/"/>
    <id>http://yoursite.com/2016/06/10/Leetcode-62-Unique-Paths/</id>
    <published>2016-06-10T14:21:16.000Z</published>
    <updated>2016-06-10T14:45:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;/p&gt;
&lt;p&gt;How many possible unique paths are there?&lt;br&gt;&lt;a href=&quot;http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;如图所示，机器人从最左上角走到最右下角，它只能往右或者往下走，求它有多少种不重复的走法。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的二维动态规划问题。对于第一行和第一列来说，走到该格子只能沿着直线走，所以走到这些格子的方法数为1.而其他的格子，因为只能往右和往下走，那么第（i,j）格可以由（i,j-1）往下走一步或者(i-1,j)往右走一步达到，所以该格子的方法数应该是这辆格数字的和。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;class Solution {&lt;br&gt;    public:&lt;br&gt;        int uniquePaths(int m, int n) {&lt;br&gt;            vector&lt;int&gt; a(m,1);&lt;br&gt;            vector&lt;vector&lt;int&gt;&amp;gt; map;&lt;br&gt;            for(int i=0;i&amp;lt;n;i++)&lt;br&gt;            map.push_back(a);&lt;br&gt;            for(int i=1;i&amp;lt;n;i++)&lt;br&gt;                for(int j=1;j&amp;lt;m;j++)&lt;br&gt;                    map[i][j]=map[i-1][j]+map[i][j-1];&lt;br&gt;            return map[n-1][m-1];&lt;br&gt;        }&lt;br&gt;    };&lt;/vector&lt;int&gt;&lt;/int&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;/p&gt;
&lt;p&gt;How many possible unique paths are there?&lt;br&gt;&lt;a href=&quot;http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-89-Gray Code</title>
    <link href="http://yoursite.com/2016/06/10/Leetcode-89-Gray-Code/"/>
    <id>http://yoursite.com/2016/06/10/Leetcode-89-Gray-Code/</id>
    <published>2016-06-10T01:32:25.000Z</published>
    <updated>2016-06-10T14:45:45.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The gray code is a binary numeral system where two successive values differ in only one bit.&lt;/p&gt;
&lt;p&gt;Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.&lt;/p&gt;
&lt;p&gt;For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 - 0
01 - 1
11 - 3
10 - 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:&lt;br&gt;For a given n, a gray code sequence is not uniquely defined.&lt;/p&gt;
&lt;p&gt;For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.&lt;/p&gt;
&lt;p&gt;For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;灰码是指邻近的数字只有一位相差，输入一个数字，求出该数字位数相符的灰码序列。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;首先，对于什么是灰码，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt;。我觉得和&lt;a href=&quot;/2016/05/23/Leetcode-338-Counting-Bits/&quot;&gt;这道题&lt;/a&gt;比较相似。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; grayCode(int n) {
            vector&amp;lt;int&amp;gt; res;
            res.push_back(0);
            for(int i=0;i&amp;lt;n;i++)
                {
                    int high=1&amp;lt;&amp;lt;i;
                    int size=res.size();
                    for(int j=size-1;j&amp;gt;=0;j--)
                        res.push_back(high+res[j]);
                }
            return res;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The gray code is a binary numeral system where two successive values differ in only one bit.&lt;/p&gt;
&lt;p&gt;Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.&lt;/p&gt;
&lt;p&gt;For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 - 0
01 - 1
11 - 3
10 - 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:&lt;br&gt;For a given n, a gray code sequence is not uniquely defined.&lt;/p&gt;
&lt;p&gt;For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.&lt;/p&gt;
&lt;p&gt;For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-53-Maximum Subarray</title>
    <link href="http://yoursite.com/2016/06/09/Leetcode-53-Maximum-Subarray/"/>
    <id>http://yoursite.com/2016/06/09/Leetcode-53-Maximum-Subarray/</id>
    <published>2016-06-09T09:26:20.000Z</published>
    <updated>2016-06-10T14:45:50.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;
&lt;p&gt;For example, given the array [−2,1,−3,4,−1,2,1,−5,4],&lt;br&gt;the contiguous subarray [4,−1,2,1] has the largest sum = 6.&lt;/p&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;More practice:&lt;br&gt;If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;对于给定的一个数组，找出其子序列中和最大的一个。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题如果做动态规划，则复杂度为O(n)，对于当前和来讲，如果加上某个元素时和为负数，则舍弃。另用一个变量来储存历史中最大的和。注意考虑到最大和有可能是负数，初始化时应该把max初始化为INT_MIN.&lt;/p&gt;
&lt;p&gt;Follow up: 如果想用分治法来解这道题，那么可以这样做：最大的和要么存在于前半个数组中，要么存在于后半个数组中，要么存在于中间往两边延伸。求出这三种情况的最大值中最大那个，即为我们所求。代码请读者自己完成。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            vector&amp;lt;int&amp;gt; dp(nums.size(),0);
            int sum=0;
            int max=INT_MIN;
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                       sum+=nums[i];
                       if(sum&amp;gt;max)
                           max=sum;
                       if(sum&amp;lt;0)
                           sum=0;
                }
            return max;

    }

};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;
&lt;p&gt;For example, given the array [−2,1,−3,4,−1,2,1,−5,4],&lt;br&gt;the contiguous subarray [4,−1,2,1] has the largest sum = 6.&lt;/p&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;More practice:&lt;br&gt;If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Divide and Conqure" scheme="http://yoursite.com/tags/Divide-and-Conqure/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-309-Best Time to Buy and Sell Stock With Cooldown</title>
    <link href="http://yoursite.com/2016/06/09/Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-With-Cooldown/"/>
    <id>http://yoursite.com/2016/06/09/Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-With-Cooldown/</id>
    <published>2016-06-09T08:55:17.000Z</published>
    <updated>2016-06-10T14:45:50.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:&lt;/p&gt;
&lt;p&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;br&gt;After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)&lt;br&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;有一个数组表示第I天某只股票的价格。设计一个算法求出买卖这只股票的最大收益，买入之前必须先卖出，卖出后第二天不能进行买入操作。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个典型的动态规划问题。我们可以如下分析动态规划问题：&lt;br&gt;状态：买入，卖出，所以我们需要2个数组buy[n],sell[n]分别记录第N天如果买入/卖出，已经获得的最大收益。&lt;br&gt;状态转移方程：对于买入来说，如果今天没有买入，则获益和昨天一样（因为没有发生交易），如果今天买入了，则I-2天之前必须要卖出，则获益为sell[i-2]-price[i]，两种情况下最大值即为当天的buy[i]值（buy[i]=max(buy[i-1],sell[i-2]-prices[i]).&lt;br&gt;对于卖出来说，如果今天没有卖出，则收益和昨天一样（因为没有发生交易），以及如果昨天买入了，今天卖出，则总收益为sell[i-1]+prices[i]，两种情况下最大值即为当天的sell[i]值。而股票收益仅当你不持有股票时才能体现出来，所以我们要的值即为sell数组的最后一个值。&lt;br&gt;初始状态：对于两个数组来说，Buy[0]即第一天买入，收益当然为-prices[0],而buy[1]则表示按照低价买入，所以应当为前两天价格低者的相反数。对于Sell[0]而言，第一天因为之前没有持有股票，所以sell[0]=0，而sell[1]则表示第2天卖出股票的最大收益，那么如果第二天的股价低于第一天，则为0，若高于第一天，则为差价。&lt;br&gt;Follow up:&lt;br&gt;当然了，我们不难发现，状态方程里每天的收益仅仅和前两天的买入/卖出收益相关，所以我们可以improve我们的空间复杂度从O（n）到O(1)。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {
            if(prices.size()&amp;lt;2) return 0;
            vector&amp;lt;int&amp;gt; buy(prices.size(),0);
            vector&amp;lt;int&amp;gt; sell(prices.size(),0);
            buy[0]=-prices[0];
            buy[1]=max(-prices[0],-prices[1]);
            sell[0]=0;
            sell[1]=max(0,prices[1]-prices[0]);
            for(int i=2;i&amp;lt;prices.size();i++)
                {
                    buy[i]=max(buy[i-1],sell[i-2]-prices[i]);
                    sell[i]=max(sell[i-1],buy[i-1]+prices[i]);
                }
            return sell.back();
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:&lt;/p&gt;
&lt;p&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;br&gt;After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)&lt;br&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-350-Intersection of Two Arrays II</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-350-Intersection-of-Two-Arrays-II/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-350-Intersection-of-Two-Arrays-II/</id>
    <published>2016-06-07T15:39:24.000Z</published>
    <updated>2016-06-07T15:48:27.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;br&gt;The result can be in any order.&lt;br&gt;Follow up:&lt;br&gt;What if the given array is already sorted? How would you optimize your algorithm?&lt;br&gt;What if nums1’s size is small compared to nums2’s size? Which algorithm is better?&lt;br&gt;What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个数组，写一个函数来返回两个数组的交集，如果有重复的也需要返回。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题和&lt;a href=&quot;/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/&quot;&gt;这道题&lt;/a&gt;略有不同。本题需要返回交集中的重复数字。其实类似于这类集合的交、并集问题，&lt;a href=&quot;https://www.quora.com/Programming-Interview-Questions-How-do-you-find-out-intersection-between-two-arrays-when-they-are-sorted-when-they-are-not-sorted&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;讲的非常详细，推荐读一读。一个简单的算法，先对数组进行排序，然后使用双指针，当遍历完短数组后结束。这样复杂度为O(nlogn+mlogm)。如果是已排好序的数组，或者某一个数组已排好序，可以对未排序数组的每个元素在已排序数组里进行二分查找，复杂度为O(m*logn).本文提供排序后双指针的解法。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; intersect(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) {
            vector&amp;lt;int&amp;gt; res;
            if(nums1.empty()||nums2.empty()) return res;
            sort(nums1.begin(),nums1.end());
            sort(nums2.begin(),nums2.end());
            int i=0,j=0;
               while(i&amp;lt;nums1.size()&amp;amp;&amp;amp;j&amp;lt;nums2.size())
                   {
                       if(nums1[i]==nums2[j]){
                         res.push_back(nums1[i]);
                         i++;
                         j++;
                   }
                       else if(nums1[i]&amp;gt;nums2[j]) j++;
                       else i++;
           }
               return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;br&gt;The result can be in any order.&lt;br&gt;Follow up:&lt;br&gt;What if the given array is already sorted? How would you optimize your algorithm?&lt;br&gt;What if nums1’s size is small compared to nums2’s size? Which algorithm is better?&lt;br&gt;What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-141-Linked List Cycle</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-141-Linked-List-Cycle/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-141-Linked-List-Cycle/</id>
    <published>2016-06-07T14:50:05.000Z</published>
    <updated>2016-06-07T14:52:35.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个链表，判断它是否包含一个环&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;环链表的特征很多，最常用的判断方法是双指针法。让快慢两个指针同时在链表中遍历，如果存在环，那么两个指针一定会相遇。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        bool hasCycle(ListNode *head) {
            if(!head||!head-&amp;gt;next) return false;
            ListNode* fast=head-&amp;gt;next;
            ListNode* slow=head;
            while(slow&amp;amp;&amp;amp;fast&amp;amp;&amp;amp;slow!=fast)
                {
                    if(fast-&amp;gt;next)
                        fast=fast-&amp;gt;next-&amp;gt;next;
                    else return false;
                    slow=slow-&amp;gt;next;
                }
            return slow==fast;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-70-Climbing Stairs</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-70-Climbing-Stairs/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-70-Climbing-Stairs/</id>
    <published>2016-06-07T14:45:30.000Z</published>
    <updated>2016-06-07T14:49:15.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;你在爬一个楼梯，每一步要么爬一阶要么爬两阶，求爬到楼梯的顶部有多少种方法。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的动态规划问题，后面的每一步都是前两个数的和，因为要么爬一阶要么爬两阶，那么除开最后一步，就变成和子问题一样的问题了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int climbStairs(int n) {
            vector&amp;lt;int&amp;gt; res(n+1);
            res[0]=1;
            res[1]=1;
            for(int i=2;i&amp;lt;=n;i++)
                res[i]=res[i-1]+res[i-2];
            return res[n];

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-202-Happy Number</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-202-Happy-Number/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-202-Happy-Number/</id>
    <published>2016-06-07T14:25:52.000Z</published>
    <updated>2016-06-07T14:43:01.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write an algorithm to determine if a number is “happy”.&lt;/p&gt;
&lt;p&gt;A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;
&lt;p&gt;Example: 19 is a happy number&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;快乐数的定义是这样的，循环做这个步骤：把某个正整数的每个位上的数字的平方相加。当这个循环包含了1的时候，它就是快乐数，判断一个数字是不是快乐数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;根据快乐数的定义，利用一个哈希表来记录出现过的数字，一旦出现循环，如果不是在1的地方循环，则这个数不是快乐数。很简单的题，细心，争取bugfree.&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isHappy(int n) {
            set&amp;lt;int&amp;gt; s;
            int sum=helper(n);
            while (s.find(sum)==s.end())
                {
                    s.insert(sum);
                    sum=helper(sum);
                }
            return sum==1;

            }
        int helper(int n)
            {
                int res=0;
                while(n&amp;gt;0)
                    {
                        res+=((n%10)*(n%10));
                        n/=10;
                    }
                return res;
                }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write an algorithm to determine if a number is “happy”.&lt;/p&gt;
&lt;p&gt;A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;
&lt;p&gt;Example: 19 is a happy number&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-263-Ugly Number</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-263-Ugly-Number/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-263-Ugly-Number/</id>
    <published>2016-06-07T14:22:04.000Z</published>
    <updated>2016-06-07T14:25:17.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to check whether a given number is an ugly number.&lt;/p&gt;
&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.&lt;/p&gt;
&lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;
&lt;p&gt;Credits:&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;丑数是指那些只有2，3，5作为质因子的数字，判断一个数是不是丑数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;循环剔除所有2，3，5因子，看剩下的是否是1.&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isUgly(int num) {
            if(num==0) return false;
            while(num%5==0)
                num/=5;
            while(num%3==0)
                num/=3;
            while(num%2==0)
                num/=2;
            return num==1;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to check whether a given number is an ugly number.&lt;/p&gt;
&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.&lt;/p&gt;
&lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;
&lt;p&gt;Credits:&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-83-Remove Duplicates from Sorted List</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-83-Remove-Duplicates-from-Sorted-List/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-83-Remove-Duplicates-from-Sorted-List/</id>
    <published>2016-06-07T14:18:03.000Z</published>
    <updated>2016-06-07T14:21:30.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted linked list, delete all duplicates such that each element appear only once.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个已排序的链表，删除所有重复的结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;遍历整个链表，发现某个结点的下一个结点的值和它一样时，把它的下一个结点指向再后一个结点。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* deleteDuplicates(ListNode* head) {
                ListNode* p = head;
                if(!head) return head;
                while(p&amp;amp;&amp;amp;p-&amp;gt;next)
                    {
                        if(p-&amp;gt;val==p-&amp;gt;next-&amp;gt;val) 
                            p-&amp;gt;next=p-&amp;gt;next-&amp;gt;next;
                        else
                            p=p-&amp;gt;next;
                    }
                return head;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted linked list, delete all duplicates such that each element appear only once.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-231-Power of Two</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-231-Power-of-Two/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-231-Power-of-Two/</id>
    <published>2016-06-07T14:14:16.000Z</published>
    <updated>2016-06-07T14:17:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of two.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个整数，判断是否是2的整数幂。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;和&lt;a href=&quot;/2016/06/07/Leetcode-326-Power-of-Tree/&quot;&gt;这道题&lt;/a&gt;类似，只是判断是否是2的整数幂。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isPowerOfTwo(int n) {
            while(n&amp;gt;1)
                {
                    if(n%2&amp;gt;0) return false;
                    n/=2;
                }
            return n==1;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of two.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-326-Power of Tree</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-326-Power-of-Tree/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-326-Power-of-Tree/</id>
    <published>2016-06-07T14:11:14.000Z</published>
    <updated>2016-06-07T14:13:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个整数，判断它是不是3的幂&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的循环，判断最后是否得到1.&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isPowerOfThree(int n) {

            while(n&amp;gt;1)
                {
                    if(n%3&amp;gt;0) return false;
                    n/=3;
                }
            return n==1;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-337-House Robber III</title>
    <link href="http://yoursite.com/2016/05/27/Leetcode-337-House-Robber-III/"/>
    <id>http://yoursite.com/2016/05/27/Leetcode-337-House-Robber-III/</id>
    <published>2016-05-27T03:47:41.000Z</published>
    <updated>2016-06-07T14:09:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Determine the maximum amount of money the thief can rob tonight without alerting the police.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;一个树状的结构里，两个相邻的父，子结点不可以被同时偷，求盗贼的最大收益。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题可以使用动态规划,使用一个辅助函数返回是否抢该节点的两个收益最大值。动态转移方程为，左右均不偷+根节点或者偷左右不偷根节点，取最大值。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int rob(TreeNode* root) {
            vector&amp;lt;int&amp;gt; res = helper(root);
            return max(res[0],res[1]); 
    }

        vector&amp;lt;int&amp;gt; helper(TreeNode* root)
            {
                vector&amp;lt;int&amp;gt; res(2,0);
                if(!root) return res;
                vector&amp;lt;int&amp;gt; left = helper(root-&amp;gt;left);
                vector&amp;lt;int&amp;gt; right = helper(root-&amp;gt;right);
                res[0]= max(left[1],left[0])+max(right[1],right[0]);
                res[1]= left[0]+right[0]+root-&amp;gt;val;
                return res;
            }

    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Determine the maximum amount of money the thief can rob tonight without alerting the police.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-22-Generate Parentheses</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-22-Generate-Parentheses/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-22-Generate-Parentheses/</id>
    <published>2016-05-26T11:33:14.000Z</published>
    <updated>2016-05-26T14:39:10.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;/p&gt;
&lt;p&gt;“((()))”, “(()())”, “(())()”, “()(())”, “()()()”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字，返回该数字对括号能产生的所有合法括号组合。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;使用回溯法，生成所有组合。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;string&amp;gt; generateParenthesis(int n) {
            vector&amp;lt;string&amp;gt; res;
            string tem;
            helper(res,tem,0,0,n);
            return res;

        }
        void helper(vector&amp;lt;string&amp;gt;&amp;amp;res,string&amp;amp; s,int left,int right,int n)
            {
                if(left==n&amp;amp;&amp;amp;right==n) {res.push_back(s);}

                if(left&amp;lt;n) {s.push_back(&amp;apos;(&amp;apos;); helper(res,s,left+1,right,n);s.pop_back();}
                if(right&amp;lt;left) {s.push_back(&amp;apos;)&amp;apos;); helper(res,s,left,right+1,n);s.pop_back();}

            }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;/p&gt;
&lt;p&gt;“((()))”, “(()())”, “(())()”, “()(())”, “()()()”&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-35-Search Insert Position</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-35-Search-Insert-Position/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-35-Search-Insert-Position/</id>
    <published>2016-05-26T11:28:02.000Z</published>
    <updated>2016-05-26T11:32:34.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.&lt;br&gt;[1,3,5,6], 5 → 2&lt;br&gt;[1,3,5,6], 2 → 1&lt;br&gt;[1,3,5,6], 7 → 4&lt;br&gt;[1,3,5,6], 0 → 0&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个排好序的数组和一个值，返回它的下标，如果它在数组里，否则，则返回该值应该被插入的位置。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;找到第一个大于该值的位置，返回之前一个位置。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
            if(target&amp;lt;nums[0]) return 0;
            if(target&amp;gt;nums[nums.size()-1]) return nums.size();
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                    if(nums[i]==target) return i;
                    else if(nums[i]&amp;lt;target) continue;
                    else if(nums[i-1]&amp;lt;target) return i;  
                }
            return 0;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.&lt;br&gt;[1,3,5,6], 5 → 2&lt;br&gt;[1,3,5,6], 2 → 1&lt;br&gt;[1,3,5,6], 7 → 4&lt;br&gt;[1,3,5,6], 0 → 0&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-108-Convert Sorted Array to Binary Search Tree</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</id>
    <published>2016-05-26T10:54:00.000Z</published>
    <updated>2016-05-26T11:27:33.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个已排序数组，把它转化成一个平衡BST。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用DFS和递归调用函数生成。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            return helper(nums,0,nums.size()-1);
    }
        TreeNode* helper(vector&amp;lt;int&amp;gt; &amp;amp;nums,int begin,int end)
                {
                if(begin&amp;gt;end) return NULL;
                if(begin==end) return new TreeNode(nums[begin]);
                int mid = begin + (end-begin)/2;
                 TreeNode* res = new TreeNode(nums[mid]);
                 res-&amp;gt;left = helper(nums,begin,mid-1);
                 res-&amp;gt;right = helper(nums,mid+1,end);
                 return res;
                }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-235-Lowest Common Ancester of a Binary Search Tree</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-235-Lowest-Common-Ancester-of-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-235-Lowest-Common-Ancester-of-a-Binary-Search-Tree/</id>
    <published>2016-05-26T10:49:18.000Z</published>
    <updated>2016-05-26T10:52:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;找到两个节点的最低相同祖先。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先求出两条路径，再找到最后一个相同元素即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            vector&amp;lt;TreeNode*&amp;gt; p1;
            vector&amp;lt;TreeNode*&amp;gt; q1;
            findpath(p1,p,root);
            findpath(q1,q,root);
            for(int i=p1.size()-1;i&amp;gt;=0;i--)
                {
                    if(find(q1.begin(),q1.end(),p1[i])!=q1.end())
                        return p1[i];
                }
            return NULL;


        }
        void findpath(vector&amp;lt;TreeNode*&amp;gt;&amp;amp; path,TreeNode* p, TreeNode* root)
            {
                TreeNode* current = root;
                while(current-&amp;gt;val!=p-&amp;gt;val)
                    {
                        path.push_back(current);
                        if(current-&amp;gt;val&amp;gt;p-&amp;gt;val)
                            current=current-&amp;gt;left;
                        else current=current-&amp;gt;right;
                        }
                path.push_back(p);
            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
</feed>
