<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://since1992.org/"/>
  <updated>2016-06-19T10:19:42.000Z</updated>
  <id>http://since1992.org/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-88-Merge Sorted Array</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-88-Merge-Sorted-Array/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-88-Merge-Sorted-Array/</id>
    <published>2016-06-19T10:17:53.000Z</published>
    <updated>2016-06-19T10:19:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;合并两个排了序的数组到nums1。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题简单，从后开始往前合并即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) {
        while(m&amp;gt;0&amp;amp;&amp;amp;n&amp;gt;0)
        {
            if(nums1[m-1]&amp;gt;nums2[n-1]){
                nums1[m+n-1]=nums1[m-1];
                m--;
            }else{
                nums1[m+n-1]=nums2[n-1];
                n--;
            }

        }
        if(n&amp;gt;0)
        {
            for(int i=0;i&amp;lt;n;i++)
            nums1[i]=nums2[i];
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-299-Bulls and Cows</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-299-Bulls-and-Cows/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-299-Bulls-and-Cows/</id>
    <published>2016-06-19T10:06:23.000Z</published>
    <updated>2016-06-19T10:19:46.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulls_and_Cows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bulls and Cows&lt;/a&gt; game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1807”&lt;br&gt;Friend’s guess: “7810”&lt;br&gt;Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)&lt;br&gt;Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.&lt;/p&gt;
&lt;p&gt;Please note that both secret number and friend’s guess may contain duplicate digits, for example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1123”&lt;br&gt;Friend’s guess: “0111”&lt;br&gt;In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.&lt;br&gt;You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;朋友猜你所想的数字，如果数字与位置均正确记为A，如果数字正确位置错误记为B。输出”XAYB“的结果&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用两个数组统计每个数字出现的次数，然后就可以输出结果了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string getHint(string secret, string guess) {
        if(!secret.length()||!guess.length()) return &amp;quot;0A0B&amp;quot;;
        vector&amp;lt;int&amp;gt;countS(10,0);
        vector&amp;lt;int&amp;gt;countG(10,0);
        int A=0;
        int B=0;
        for(int i=0;i&amp;lt;secret.length();i++)
        {
            if(secret[i]==guess[i])
            A++;
            else{
                countS[secret[i]-&amp;apos;0&amp;apos;]++;
                countG[guess[i]-&amp;apos;0&amp;apos;]++;
            }
        }
        for(int i=0;i&amp;lt;10;i++)
        {
            B+=min(countS[i],countG[i]);
        }
        string res=&amp;quot;&amp;quot;;
        res+=num2str(A);
        res+=&amp;apos;A&amp;apos;;
        res+=num2str(B);
        res+=&amp;apos;B&amp;apos;;
        return res;
    }
    string num2str(int n)
    {
        if(n==0) return &amp;quot;0&amp;quot;;
        string res=&amp;quot;&amp;quot;;
        while(n&amp;gt;0)
        {
            res=(char)((n%10)+&amp;apos;0&amp;apos;)+res;
            n/=10;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulls_and_Cows&quot;&gt;Bulls and Cows&lt;/a&gt; game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1807”&lt;br&gt;Friend’s guess: “7810”&lt;br&gt;Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)&lt;br&gt;Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.&lt;/p&gt;
&lt;p&gt;Please note that both secret number and friend’s guess may contain duplicate digits, for example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1123”&lt;br&gt;Friend’s guess: “0111”&lt;br&gt;In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.&lt;br&gt;You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-219-Contains Duplicate II</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-219-Contains-Duplicate-II/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-219-Contains-Duplicate-II/</id>
    <published>2016-06-19T09:50:00.000Z</published>
    <updated>2016-06-19T10:19:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组和一个数字N，求数组里又没有间隔N以下的相等值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;维护一个大小为K的滑动窗口，只需要O（n）的时间即可。注意K大于数组容量的情况。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        if(nums.empty()||k&amp;lt;1) return false;
        set&amp;lt;int&amp;gt; s;
        if(k&amp;gt;nums.size())
        {
            for(int i=0;i&amp;lt;nums.size();i++){
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);

            }
              return false;  
        }
        else
        {
            for(int i=0;i&amp;lt;k;i++)
            {
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);
            }
            for(int j=k;j&amp;lt;nums.size();j++)
            {

                if(s.find(nums[j])!=s.end())
                return true;
                else{
                s.insert(nums[j]);
                s.erase(nums[j-k]);
                }
            }
            return false;
        }


    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-160-Intersection of Two Linked Lists</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-160-Intersection-of-Two-Linked-Lists/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-160-Intersection-of-Two-Linked-Lists/</id>
    <published>2016-06-19T09:38:27.000Z</published>
    <updated>2016-06-19T10:19:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;The linked lists must retain their original structure after the function returns.&lt;br&gt;You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;Your code should preferably run in O(n) time and use only O(1) memory.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给两个单向链表，返回他们的交接处，如果没有交接，则返回空指针，只能使用O(1)的额外空间，且不可以修改原链表。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;统计出两个链表的节点数，让长的那个从头去掉相差额的结点，则相遇即相交。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA||!headB) return NULL;
        int counta=0;
        int countb=0;
        ListNode* a= headA;
        ListNode* b= headB;
        while(a)
        {
            counta++;
            a=a-&amp;gt;next;
        }
        while(b)
        {
            countb++;
            b=b-&amp;gt;next;
        }
        int dif = counta-countb;

            for(int i=abs(dif);i&amp;gt;0;i--)
            {
                if(dif &amp;gt; 0)
                    headA=headA-&amp;gt;next;
                else headB=headB-&amp;gt;next;
            }
        while(headA&amp;amp;&amp;amp;headB&amp;amp;&amp;amp;headA!=headB)
        {
            headA=headA-&amp;gt;next;
            headB=headB-&amp;gt;next;
        }
        ListNode * res;
        headA==headB?res=headA:res=NULL;
        return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;The linked lists must retain their original structure after the function returns.&lt;br&gt;You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;Your code should preferably run in O(n) time and use only O(1) memory.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-225-Implement Stack using Queues</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-225-Implement-Stack-using-Queues/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-225-Implement-Stack-using-Queues/</id>
    <published>2016-06-19T09:03:06.000Z</published>
    <updated>2016-06-19T09:05:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;empty() – Return whether the stack is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;用队列实现栈的操作。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;和&lt;a href=&quot;/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/&quot;&gt;这道题&lt;/a&gt;类似，注意对应变量关系即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Stack {

public:
    queue&amp;lt;int&amp;gt; q1;
    queue&amp;lt;int&amp;gt; q2;
    int count = 0;
    // Push element x onto stack.
    void push(int x) {
        q1.push(x);
        count++;
    }

    // Removes the element on top of the stack.
    void pop() {
        while(count&amp;gt;1)
        {
            q2.push(q1.front());
            q1.pop();
            count--;
        }
        q1.pop();
        count--;
        while(!q2.empty())
        {
            q1.push(q2.front());
            count++;
            q2.pop();
        }
    }

    // Get the top element.
    int top() {
      return q1.back();

    }

    // Return whether the stack is empty.
    bool empty() {
        return q1.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;empty() – Return whether the stack is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
      <category term="Design" scheme="http://since1992.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-111-Minimum Depth of Binary Tree</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-111-Minimum-Depth-of-Binary-Tree/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-111-Minimum-Depth-of-Binary-Tree/</id>
    <published>2016-06-19T08:49:34.000Z</published>
    <updated>2016-06-19T10:19:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;p&gt;The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵树，找出它从根节点到某一叶子节点的最短路径。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题和&lt;a href=&quot;/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/&quot;&gt;找出最长路径&lt;/a&gt;的做法不太一样。不能直接取左右较短者加一，因为有可能某个子树是空的。细心判断即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        int minl = minDepth(root-&amp;gt;left);
        int minr = minDepth(root-&amp;gt;right);
        int minx = min(minl,minr);
        minx==0?minx=minl+minr:minx=minx;
        return minx+1;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its minimum depth.&lt;/p&gt;
&lt;p&gt;The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-12-Path Sum</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-112-Path-Sum/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-112-Path-Sum/</id>
    <published>2016-06-19T08:15:00.000Z</published>
    <updated>2016-06-19T08:53:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given the below binary tree and sum = 22,&lt;br&gt;              5&lt;br&gt;             / \&lt;br&gt;            4   8&lt;br&gt;           /   / \&lt;br&gt;          11  13  4&lt;br&gt;         /  \      \&lt;br&gt;        7    2      1&lt;br&gt;return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，判断是否有从根到叶子节点的路径和等于给定值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的递归调用函数即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(!root) return false;
        sum-=root-&amp;gt;val;
        return hasPathSum(root-&amp;gt;left,sum)||hasPathSum(root-&amp;gt;right,sum)||(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right&amp;amp;&amp;amp;sum==0);
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given the below binary tree and sum = 22,&lt;br&gt;              5&lt;br&gt;             / \&lt;br&gt;            4   8&lt;br&gt;           /   / \&lt;br&gt;          11  13  4&lt;br&gt;         /  \      \&lt;br&gt;        7    2      1&lt;br&gt;return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-9-Palindrome Number</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-9-Palindrome-Number/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-9-Palindrome-Number/</id>
    <published>2016-06-19T07:46:50.000Z</published>
    <updated>2016-06-19T07:48:43.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Determine whether an integer is a palindrome. Do this without extra space.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;判断一个整数是否是对称数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;首先负数肯定不是对称的。然后可以把数字转化成字符串，存成两个正\反序的字符串，如果这两个字符串相等，则是对称的。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;class Solution {&lt;br&gt;    public:&lt;br&gt;        bool isPalindrome(int x) {&lt;br&gt;            if(x&lt;0) return=&quot;&quot; false;=&quot;&quot; string=&quot;&quot; a=&quot;&quot; ,b=&quot;&quot; ;=&quot;&quot; while(x=&quot;&quot;&gt;0)&lt;br&gt;            {&lt;br&gt;                a+=(char)(x%10+’0’);&lt;br&gt;                b=(char)(x%10+’0’)+b;&lt;br&gt;                x/=10;&lt;br&gt;            }&lt;br&gt;            return a==b;&lt;br&gt;        }&lt;br&gt;    };&lt;/0)&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Determine whether an integer is a palindrome. Do this without extra space.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-119-Pascal&#39;s Triangle II</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-119-Pascal-s-Triangle-II/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-119-Pascal-s-Triangle-II/</id>
    <published>2016-06-19T04:09:19.000Z</published>
    <updated>2016-06-19T04:10:57.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an index k, return the kth row of the Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given k = 3,&lt;br&gt;Return [1,3,3,1].&lt;br&gt;Note:&lt;br&gt;Could you optimize your algorithm to use only O(k) extra space?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字N，返回帕斯卡三角的第N行结果。只能使用 O(k)的额外空间。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用循环累加的办法生成对应行即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; getRow(int rowIndex) {
        vector&amp;lt;int&amp;gt; row(1,1);
        if(rowIndex&amp;lt;1) return row;
        for(int i=1;i&amp;lt;=rowIndex;i++)
        {
            int prev1=row[0];
            int prev2;
            for(int j=1;j&amp;lt;i;j++)
                {
                    prev2=row[j];
                    row[j]+=prev1;
                    prev1=prev2;
                }
            row.push_back(1);
        }
        return row;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an index k, return the kth row of the Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given k = 3,&lt;br&gt;Return [1,3,3,1].&lt;br&gt;Note:&lt;br&gt;Could you optimize your algorithm to use only O(k) extra space?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-172-Factorial Trailing Zeroes</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-172-Factorial-Trailing-Zeroes/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-172-Factorial-Trailing-Zeroes/</id>
    <published>2016-06-19T03:35:30.000Z</published>
    <updated>2016-06-19T03:37:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;p&gt;Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个整数N，返回n的阶乘的结果中末尾0的个数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;其实很简单，就是考的1-n中有几个5的因子，注意到5的次幂有不止1个因子5即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int trailingZeroes(int n) {
        int count=0;
        while(n&amp;gt;1)
        {
            count+=n/5;
            n/=5;
        }
       return count; 
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;p&gt;Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-102-Binary Tree Level Order Traversal</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-102-Binary-Tree-Level-Order-Traversal/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2016-06-19T03:30:09.000Z</published>
    <updated>2016-06-19T03:32:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its level order traversal as:&lt;br&gt;    [&lt;br&gt;      [3],&lt;br&gt;      [9,20],&lt;br&gt;      [15,7]&lt;br&gt;    ]&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回层次遍历的结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题和&lt;a href=&quot;/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/&quot;&gt;这道题&lt;/a&gt;一样，没什么好说的，很简单利用一个队列完成BFS操作。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
        vector&amp;lt;int&amp;gt; tem;
        if(!root) return res;
        queue&amp;lt;TreeNode*&amp;gt; q;
        q.push(root);
        q.push(NULL);
        while(!q.empty())
        {
            TreeNode* t=q.front();
            q.pop();
            if(t)
            {
                tem.push_back(t-&amp;gt;val);
                if(t-&amp;gt;left)
                    q.push(t-&amp;gt;left);
                if(t-&amp;gt;right)
                    q.push(t-&amp;gt;right);
            }else{
                if(!q.empty())
                {
                    res.push_back(tem);
                    tem.clear();
                    q.push(NULL);
                }else{
                    res.push_back(tem);
                }
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its level order traversal as:&lt;br&gt;    [&lt;br&gt;      [3],&lt;br&gt;      [9,20],&lt;br&gt;      [15,7]&lt;br&gt;    ]&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="BFS" scheme="http://since1992.org/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-26-Remove Duplicates from Sorted Array</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-26-Remove-Duplicates-from-Sorted-Array/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-26-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2016-06-19T02:58:32.000Z</published>
    <updated>2016-06-19T03:01:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given input array nums = [1,1,2],&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个已排序的数组，去除重复元素， 然后返回新的长度，只能使用O(1)的额外空间。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的一次遍历即可。当某个数比它前一个数大的时候说明它是新的一个未重复元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int count=0;
        if(nums.empty()) return count;
        count++;
        for(int i=1;i&amp;lt;nums.size();i++)
        {
          if(nums[i]&amp;gt;nums[i-1])
            nums[count++]=nums[i];
        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given input array nums = [1,1,2],&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-118-Pascal&#39;s Triangle</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-118-Pascal-s-Triangle/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-118-Pascal-s-Triangle/</id>
    <published>2016-06-18T14:14:33.000Z</published>
    <updated>2016-06-18T14:16:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given numRows, generate the first numRows of Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given numRows = 5,&lt;br&gt;Return&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字N，生成前N行帕斯卡三角。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;至于什么是帕斯卡三角，可以参加&lt;a href=&quot;https://en.wikipedia.org/wiki/Pascal%27s_triangle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt;,找出规律以后写代码就容易了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans;
        if(numRows&amp;lt;=0) return ans;
        ans.resize(numRows);
        for(int i=0;i&amp;lt;numRows;i++)
        {
            ans[i].resize(i+1,1);
            for(int j=1;j&amp;lt;i;j++)
            ans[i][j]=ans[i-1][j]+ans[i-1][j-1];
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given numRows, generate the first numRows of Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given numRows = 5,&lt;br&gt;Return&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-232-Implement Queue using Stacks</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/</id>
    <published>2016-06-18T13:45:20.000Z</published>
    <updated>2016-06-18T13:47:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a queue using stacks.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x to the back of queue.&lt;br&gt;pop() – Removes the element from in front of queue.&lt;br&gt;peek() – Get the front element.&lt;br&gt;empty() – Return whether the queue is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.&lt;br&gt;Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.&lt;br&gt;You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;用栈实现队列的操作。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单，用两个栈即可取到任意一端的元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Queue {
    stack&amp;lt;int&amp;gt; s1;
    stack&amp;lt;int&amp;gt; s2;
public:
    // Push element x to the back of queue.
    void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        s2.pop();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }

    }

    // Get the front element.
    int peek(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        int p = s2.top();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }
        return p;
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return s1.empty();

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a queue using stacks.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x to the back of queue.&lt;br&gt;pop() – Removes the element from in front of queue.&lt;br&gt;peek() – Get the front element.&lt;br&gt;empty() – Return whether the queue is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.&lt;br&gt;Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.&lt;br&gt;You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
      <category term="Design" scheme="http://since1992.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-66-Plus One</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-66-Plus-One/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-66-Plus-One/</id>
    <published>2016-06-18T13:36:38.000Z</published>
    <updated>2016-06-18T13:37:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative number represented as an array of digits, plus one to the number.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个数组表示一个数字，返回它加一的结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的一道题，注意进位的处理，以及全9的情况即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) {
        int i = digits.size()-1;
        while(i&amp;gt;=0)
        {
            if(digits[i]&amp;lt;9){
                digits[i]++;
                return digits;
            }
            digits[i--]=0;

        }
        digits.insert(digits.begin(),1);
        return digits;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative number represented as an array of digits, plus one to the number.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-342-Power of Four</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-342-Power-of-Four/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-342-Power-of-Four/</id>
    <published>2016-06-18T11:18:22.000Z</published>
    <updated>2016-06-18T12:33:17.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given num = 16, return true. Given num = 5, return false.&lt;/p&gt;
&lt;p&gt;Follow up: Could you solve it without loops/recursion?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个32位的整数，判断它是否是4的幂。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本体与&lt;a href=&quot;/2016/06/07/Leetcode-231-Power-of-Two/&quot;&gt;求2的幂&lt;/a&gt;和&lt;a href=&quot;/2016/06/07/Leetcode-326-Power-of-Tree/&quot;&gt;求3的幂&lt;/a&gt;类似，解法可参加这两题。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isPowerOfFour(int num) {
        while(num&amp;gt;1&amp;amp;&amp;amp;num%4==0)
        {
            num/=4;
        }
        return num==1;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given num = 16, return true. Given num = 5, return false.&lt;/p&gt;
&lt;p&gt;Follow up: Could you solve it without loops/recursion?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Matt" scheme="http://since1992.org/tags/Matt/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-107-Binary Tree Level Order Traversal II</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/</id>
    <published>2016-06-18T10:26:12.000Z</published>
    <updated>2016-06-18T10:28:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its bottom-up level order traversal as:&lt;br&gt;    [&lt;br&gt;      [15,7],&lt;br&gt;      [9,20],&lt;br&gt;      [3]&lt;br&gt;    ]&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回从底至顶的层次遍历结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用一个辅助队列完成BFS.再反向存储数组即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Definition for a binary tree node.&lt;/li&gt;
&lt;li&gt;struct TreeNode {&lt;/li&gt;
&lt;li&gt;int val;&lt;/li&gt;
&lt;li&gt;TreeNode *left;&lt;/li&gt;
&lt;li&gt;TreeNode *right;&lt;/li&gt;
&lt;li&gt;TreeNode(int x) : val(x), left(NULL), right(NULL) {}&lt;/li&gt;
&lt;li&gt;};&lt;br&gt;*/&lt;br&gt;class Solution {&lt;br&gt; public:&lt;pre&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrderBottom(TreeNode* root) {
    vector&amp;lt;int&amp;gt; tem;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans;
    queue &amp;lt;TreeNode*&amp;gt; q;
    if(!root) return ans;
    q.push(root);
    q.push(NULL);
    while(!q.empty())
    {
        TreeNode * t = q.front();
        q.pop();
        if(t){
            tem.push_back(t-&amp;gt;val);
            if(t-&amp;gt;left)
            q.push(t-&amp;gt;left);
            if(t-&amp;gt;right)
            q.push(t-&amp;gt;right);
        }else
        {
            if(!q.empty()){
            ans.push_back(tem);
            tem.clear();
            q.push(NULL);}
            else
            ans.push_back(tem);
        }
    }
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    for(int i=ans.size()-1;i&amp;gt;=0;i--)
    res.push_back(ans[i]);
    return res;
}
&lt;/code&gt;&lt;/pre&gt; };&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its bottom-up level order traversal as:&lt;br&gt;    [&lt;br&gt;      [15,7],&lt;br&gt;      [9,20],&lt;br&gt;      [3]&lt;br&gt;    ]&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="BFS" scheme="http://since1992.org/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-101-Symmetric Tree</title>
    <link href="http://since1992.org/2016/06/16/Leetcode-101-Symmetric-Tree/"/>
    <id>http://since1992.org/2016/06/16/Leetcode-101-Symmetric-Tree/</id>
    <published>2016-06-16T04:16:10.000Z</published>
    <updated>2016-06-18T14:20:31.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;
&lt;p&gt;For example, this binary tree [1,2,2,3,4,4,3] is symmetric:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1
   / \
  2   2
 / \ / \
3  4 4  3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But the following [1,2,2,null,3,null,3] is not:&lt;br&gt;        1&lt;br&gt;       / \&lt;br&gt;      2   2&lt;br&gt;       \   \&lt;br&gt;       3    3&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵树，检查它是否是中心对称的。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单，运用一个辅助函数检查两棵树是否对称即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isM(root-&amp;gt;left,root-&amp;gt;right);

    }
    bool isM(TreeNode* a,TreeNode* b)
    {
        if(!a&amp;amp;&amp;amp;!b) return true;
        if((a&amp;amp;&amp;amp;!b)||(b&amp;amp;&amp;amp;!a)) return false;
        if(a-&amp;gt;val!=b-&amp;gt;val) return false;
        return isM(a-&amp;gt;left,b-&amp;gt;right)&amp;amp;&amp;amp;isM(a-&amp;gt;right,b-&amp;gt;left);
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;
&lt;p&gt;For example, this binary tree [1,2,2,3,4,4,3] is symmetric:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1
   / \
  2   2
 / \ / \
3  4 4  3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But the following [1,2,2,null,3,null,3] is not:&lt;br&gt;        1&lt;br&gt;       / \&lt;br&gt;      2   2&lt;br&gt;       \   \&lt;br&gt;       3    3&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-27-Remove Element</title>
    <link href="http://since1992.org/2016/06/16/Leetcode-27-Remove-Element/"/>
    <id>http://since1992.org/2016/06/16/Leetcode-27-Remove-Element/</id>
    <published>2016-06-16T03:59:47.000Z</published>
    <updated>2016-06-16T04:07:13.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array and a value, remove all instances of that value in place and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;The order of elements can be changed. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given input array nums = [3,2,2,3], val = 3&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组和一个特定的值，移除数组中所有该值，并返回剩余值的个数。你只能只用O(1)的额外空间，数字的顺序可以改变。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题和&lt;a href=&quot;2016/05/23/Leetcode-283-Move-Zeroes/&quot;&gt;这道题&lt;/a&gt;很类似，只是删除特定的值而已。我们的策略就是把所有的特定值都移动到数组的末尾。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) {
        int p=0;
        for(int i=0;i&amp;lt;nums.size();i++)
        {
            if(nums[i]!=val)
                swap(nums[i],nums[p++]);
        }
        return p;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array and a value, remove all instances of that value in place and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;The order of elements can be changed. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given input array nums = [3,2,2,3], val = 3&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-110-Balanced Binary Tree</title>
    <link href="http://since1992.org/2016/06/12/Leetcode-110-Balanced-Binary-Tree/"/>
    <id>http://since1992.org/2016/06/12/Leetcode-110-Balanced-Binary-Tree/</id>
    <published>2016-06-12T03:11:11.000Z</published>
    <updated>2016-06-12T03:13:20.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，判断它是否平衡。一个平衡的二叉树的左右子树的深度差小于或等于1.&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的DFS问题，先判断左右子树是否为平衡二叉树，再判断它们的高度差是否在1以内。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        if(isBalanced(root-&amp;gt;left)&amp;amp;&amp;amp;isBalanced(root-&amp;gt;right))
            if(abs(height(root-&amp;gt;left)-height(root-&amp;gt;right))&amp;lt;2)
                return true;
        return false;

    }
    int height(TreeNode* root)
    {
        if(!root) return 0;
        return 1+max(height(root-&amp;gt;left),height(root-&amp;gt;right));
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
</feed>
