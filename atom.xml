<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-26T11:36:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-22-Generate Parentheses</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-22-Generate-Parentheses/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-22-Generate-Parentheses/</id>
    <published>2016-05-26T11:33:14.000Z</published>
    <updated>2016-05-26T11:36:01.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;/p&gt;
&lt;p&gt;“((()))”, “(()())”, “(())()”, “()(())”, “()()()”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字，返回该数字对括号能产生的所有合法括号组合。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;使用回溯法，生成所有组合。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;string&amp;gt; generateParenthesis(int n) {
            vector&amp;lt;string&amp;gt; res;
            string tem;
            helper(res,tem,0,0,n);
            return res;

        }
        void helper(vector&amp;lt;string&amp;gt;&amp;amp;res,string&amp;amp; s,int left,int right,int n)
            {
                if(left==n&amp;amp;&amp;amp;right==n) {res.push_back(s);}

                if(left&amp;lt;n) {s.push_back(&amp;apos;(&amp;apos;); helper(res,s,left+1,right,n);s.pop_back();}
                if(right&amp;lt;left) {s.push_back(&amp;apos;)&amp;apos;); helper(res,s,left,right+1,n);s.pop_back();}

            }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;/p&gt;
&lt;p&gt;“((()))”, “(()())”, “(())()”, “()(())”, “()()()”&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-35-Search Insert Position</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-35-Search-Insert-Position/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-35-Search-Insert-Position/</id>
    <published>2016-05-26T11:28:02.000Z</published>
    <updated>2016-05-26T11:32:34.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.&lt;br&gt;[1,3,5,6], 5 → 2&lt;br&gt;[1,3,5,6], 2 → 1&lt;br&gt;[1,3,5,6], 7 → 4&lt;br&gt;[1,3,5,6], 0 → 0&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个排好序的数组和一个值，返回它的下标，如果它在数组里，否则，则返回该值应该被插入的位置。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;找到第一个大于该值的位置，返回之前一个位置。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
            if(target&amp;lt;nums[0]) return 0;
            if(target&amp;gt;nums[nums.size()-1]) return nums.size();
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                    if(nums[i]==target) return i;
                    else if(nums[i]&amp;lt;target) continue;
                    else if(nums[i-1]&amp;lt;target) return i;  
                }
            return 0;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.&lt;br&gt;[1,3,5,6], 5 → 2&lt;br&gt;[1,3,5,6], 2 → 1&lt;br&gt;[1,3,5,6], 7 → 4&lt;br&gt;[1,3,5,6], 0 → 0&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-108-Convert Sorted Array to Binary Search Tree</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</id>
    <published>2016-05-26T10:54:00.000Z</published>
    <updated>2016-05-26T11:27:33.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个已排序数组，把它转化成一个平衡BST。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用DFS和递归调用函数生成。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            return helper(nums,0,nums.size()-1);
    }
        TreeNode* helper(vector&amp;lt;int&amp;gt; &amp;amp;nums,int begin,int end)
                {
                if(begin&amp;gt;end) return NULL;
                if(begin==end) return new TreeNode(nums[begin]);
                int mid = begin + (end-begin)/2;
                 TreeNode* res = new TreeNode(nums[mid]);
                 res-&amp;gt;left = helper(nums,begin,mid-1);
                 res-&amp;gt;right = helper(nums,mid+1,end);
                 return res;
                }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-235-Lowest Common Ancester of a Binary Search Tree</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-235-Lowest-Common-Ancester-of-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-235-Lowest-Common-Ancester-of-a-Binary-Search-Tree/</id>
    <published>2016-05-26T10:49:18.000Z</published>
    <updated>2016-05-26T10:52:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;找到两个节点的最低相同祖先。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先求出两条路径，再找到最后一个相同元素即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            vector&amp;lt;TreeNode*&amp;gt; p1;
            vector&amp;lt;TreeNode*&amp;gt; q1;
            findpath(p1,p,root);
            findpath(q1,q,root);
            for(int i=p1.size()-1;i&amp;gt;=0;i--)
                {
                    if(find(q1.begin(),q1.end(),p1[i])!=q1.end())
                        return p1[i];
                }
            return NULL;


        }
        void findpath(vector&amp;lt;TreeNode*&amp;gt;&amp;amp; path,TreeNode* p, TreeNode* root)
            {
                TreeNode* current = root;
                while(current-&amp;gt;val!=p-&amp;gt;val)
                    {
                        path.push_back(current);
                        if(current-&amp;gt;val&amp;gt;p-&amp;gt;val)
                            current=current-&amp;gt;left;
                        else current=current-&amp;gt;right;
                        }
                path.push_back(p);
            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-96-Unique Binary Search Trees</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-96-Unique-Binary-Search-Trees/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-96-Unique-Binary-Search-Trees/</id>
    <published>2016-05-26T10:35:53.000Z</published>
    <updated>2016-05-26T10:44:25.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given n = 3, there are a total of 5 unique BST’s.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个数字，求有多少个不同的二叉搜索树。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用动态规划，两边的可能性相乘的和即为总数。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int numTrees(int n) {
            vector&amp;lt;int&amp;gt; ans(n+1,0);
            ans[0]=1;
            ans[1]=1;
            for(int i=2;i&amp;lt;=n;i++)
                {
                    for(int j=0;j&amp;lt;=i;j++)
                        ans[i]+=ans[j]*ans[i-j-1];
                   }
            return ans[n];
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given n = 3, there are a total of 5 unique BST’s.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-137-Single Number II</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-137-Single-Number-II/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-137-Single-Number-II/</id>
    <published>2016-05-26T10:25:53.000Z</published>
    <updated>2016-05-26T10:34:31.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;一个数组中每个元素都出现了3次除了一个只出现了一次，找到这个元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用2个哈希表，第一次出现就放入第一个，第二次出现把第一个表里删除再插入第二个表，第三次出现把第二个表里删除。这样那个单独元素就会在第一个哈希表里。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            set&amp;lt;int&amp;gt; first;
            set&amp;lt;int&amp;gt; second;
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                    if(second.find(nums[i])!=second.end()){
                        second.erase(nums[i]);
                    }else
                        {
                            if(first.find(nums[i])!=first.end())
                                    {
                                    first.erase(nums[i]);
                                    second.insert(nums[i]);
                                }else first.insert(nums[i]);
                        }
                }
            return *first.begin();

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-230-Kth Smallest Element in a BST</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-230-Kth-Smallest-Element-in-a-BST/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-230-Kth-Smallest-Element-in-a-BST/</id>
    <published>2016-05-26T10:21:30.000Z</published>
    <updated>2016-05-26T11:32:55.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;Try to utilize the property of a BST.&lt;br&gt;What if you could modify the BST node’s structure?&lt;br&gt;The optimal runtime complexity is O(height of BST).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个BST,找出第K小的元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先遍历一次，按顺序存下来，再返回特定坐标即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int kthSmallest(TreeNode* root, int k) {
            stack&amp;lt;TreeNode*&amp;gt; st;
            vector&amp;lt;int&amp;gt; ans;
            while(!st.empty()||root)
                {
                    while(root)
                        {
                            st.push(root);
                            root=root-&amp;gt;left;
                        }
            TreeNode* tem=st.top();
            ans.push_back(tem-&amp;gt;val);
            st.pop();
            if(tem-&amp;gt;right)
                root=tem-&amp;gt;right;

                    }
            return ans[k-1];

    }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;Try to utilize the property of a BST.&lt;br&gt;What if you could modify the BST node’s structure?&lt;br&gt;The optimal runtime complexity is O(height of BST).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-328-Odd Even Linked List</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-328-Odd-Even-Linked-List/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-328-Odd-Even-Linked-List/</id>
    <published>2016-05-26T09:39:52.000Z</published>
    <updated>2016-05-26T10:15:59.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL,&lt;br&gt;return 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;The first node is considered odd, the second node even and so on …&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个单向链表，返回所有奇数结点，再接上所有偶数结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先分别构建两个子串，再连起来。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* oddEvenList(ListNode* head) {
            if(!head||!head-&amp;gt;next) return head;
            ListNode* odd=head;
            ListNode* eve=head-&amp;gt;next;
            ListNode* tem=eve;
            while(odd-&amp;gt;next&amp;amp;&amp;amp;eve-&amp;gt;next)
                {
                    odd-&amp;gt;next=eve-&amp;gt;next;
                    eve-&amp;gt;next=odd-&amp;gt;next-&amp;gt;next;
                    if(odd-&amp;gt;next)
                        odd=odd-&amp;gt;next;
                    if(eve-&amp;gt;next)
                        eve=eve-&amp;gt;next;
                }
            odd-&amp;gt;next=tem;
            eve-&amp;gt;next=NULL;
            return head;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL,&lt;br&gt;return 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;The first node is considered odd, the second node even and so on …&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-287-Find the Duplicate Number</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-287-Find-the-Duplicate-Number/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-287-Find-the-Duplicate-Number/</id>
    <published>2016-05-26T09:32:33.000Z</published>
    <updated>2016-05-26T09:38:10.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must not modify the array (assume the array is read only).&lt;br&gt;You must use only constant, O(1) extra space.&lt;br&gt;Your runtime complexity should be less than O(n2).&lt;br&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;有一个大小为n+1的数组，数字均在1-n之间，证明一定至少有一个重复的数字，假设只有一个重复数字，找到它。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题有许多种解法。如果数组不能被改动，则可以利用二分查找，统计不大于mid的数个数，如果超过mid个，则这个重复的数字一定在1-mid之间，否则在mid-n之间。&lt;br&gt;如果数组可以被改动，可以使用循环标记的算法，把每个数字的值作为下标，标负，当发现标负的值的时候，该值即为重复值。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int findDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int begin=1,end=nums.size()-1;
            int mid= begin+(end-begin)/2;
            while(end-begin&amp;gt;0)
                {
                    if(helper(nums,mid))
                        {
                            end=mid;
                            mid=begin+(end-begin)/2;
                        }else
                            {
                                begin=mid+1;
                                mid=begin+(end-begin)/2;
                            }
                }
            return begin;

        }
        bool helper(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target)
            {
                int count = 0;
                    for(int i=0;i&amp;lt;nums.size();i++)
                    if(nums[i]&amp;lt;=target) count++;
                        return count&amp;gt;target;
            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must not modify the array (assume the array is read only).&lt;br&gt;You must use only constant, O(1) extra space.&lt;br&gt;Your runtime complexity should be less than O(n2).&lt;br&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-12-Integer to Roman</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-12-Integer-to-Roman/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-12-Integer-to-Roman/</id>
    <published>2016-05-26T09:27:41.000Z</published>
    <updated>2016-05-26T09:29:52.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, convert it to a roman numeral.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;把十进制数字转化为罗马数字。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先找到不同的转化点，再依次转化&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        string intToRoman(int num) {
            string res=&amp;quot;&amp;quot;;
            int nums[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};
            string s[13]={&amp;quot;M&amp;quot;,&amp;quot;CM&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;CD&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;XC&amp;quot;,&amp;quot;L&amp;quot;,&amp;quot;XL&amp;quot;,&amp;quot;X&amp;quot;,&amp;quot;IX&amp;quot;,&amp;quot;V&amp;quot;,&amp;quot;IV&amp;quot;,&amp;quot;I&amp;quot;};
            for(int i=0;i&amp;lt;=13;i++)
                {
                    if(num&amp;gt;=nums[i])
                        {
                            for(int j=0;j&amp;lt;num/nums[i];j++)
                                res+=s[i];
                                num%=nums[i];
                        }
                }
            return res;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, convert it to a roman numeral.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-13-Roman to Integer</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-13-Roman-to-Integer/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-13-Roman-to-Integer/</id>
    <published>2016-05-26T08:12:59.000Z</published>
    <updated>2016-05-26T08:19:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个罗马数字，1-3999内，求对应的十进制数字&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单，如果左边的比右边的小，说明左边的需要减去，右边的比左边的小或者相等就累加&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int romanToInt(string s) {
            if(s.length()==0) return 0;
            if(s.length()==1) return letter2int(s[0]);
            int res=letter2int(s[0]);
            for(int i=1;i&amp;lt;s.length();i++)
                {
                    if(letter2int(s[i])&amp;gt;letter2int(s[i-1]))
                        res+=letter2int(s[i])-2*letter2int(s[i-1]);
                    else res+=letter2int(s[i]);
                }
            return res;

        }
        int letter2int(char a)
            {
                switch(a)
                    {
                        case &amp;apos;I&amp;apos;: return 1;
                        case &amp;apos;V&amp;apos;: return 5;
                        case &amp;apos;X&amp;apos;: return 10;
                        case &amp;apos;L&amp;apos;: return 50;
                        case &amp;apos;C&amp;apos;: return 100;
                        case &amp;apos;D&amp;apos;: return 500;
                        case &amp;apos;M&amp;apos;: return 1000;
                        default : return 0;
                    }
            }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-94-Binary Tree Inorder Traversal</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-94-Binary-Tree-Inorder-Traversal/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-94-Binary-Tree-Inorder-Traversal/</id>
    <published>2016-05-26T08:02:13.000Z</published>
    <updated>2016-05-26T08:05:12.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the inorder traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree {1,#,2,3},&lt;br&gt;           1&lt;br&gt;        \&lt;br&gt;         2&lt;br&gt;        /&lt;br&gt;           3&lt;br&gt;return [1,3,2].&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;中序遍历一个二叉树&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用递归的办法做很简单，这里选择一个辅助栈，用非递归的方法完成中序遍历。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) {
            stack&amp;lt;TreeNode*&amp;gt; s;
            vector&amp;lt;int&amp;gt; res;
            while(!s.empty()||root)
                {
                    s.push(root);
                    while(root-&amp;gt;left)
                        {
                            s.push(root-&amp;gt;left);
                            root=root-&amp;gt;left;
                        }
                    while(!s.empty())
                        {
                            root=s.top();
                            s.pop();
                            res.push_back(root-&amp;gt;val);
                    if(root-&amp;gt;right)
                        {
                            root=root-&amp;gt;right;
                            break;
                        }else root=NULL;
                        }
                }
            return res;

        }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the inorder traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree {1,#,2,3},&lt;br&gt;           1&lt;br&gt;        \&lt;br&gt;         2&lt;br&gt;        /&lt;br&gt;           3&lt;br&gt;return [1,3,2].&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-206-Reverse Linked List</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-206-Reverse-Linked-List/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-206-Reverse-Linked-List/</id>
    <published>2016-05-26T07:58:58.000Z</published>
    <updated>2016-05-26T08:01:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Reverse a singly linked list.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个单向链表&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;有许多方法可以反转一个单向链表，这里我们选择把每个结点都放在头结点之后一次，再从尾部连接头结点，最后再断环。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* reverseList(ListNode* head) {
            if(!head||!head-&amp;gt;next) return head;
            ListNode * current = head-&amp;gt;next;
            ListNode * next;
            while(current-&amp;gt;next)
                {
                    next = current-&amp;gt;next;
                    current-&amp;gt;next=next-&amp;gt;next;
                    next-&amp;gt;next=head-&amp;gt;next;
                    head-&amp;gt;next=next;
                }
            current-&amp;gt;next=head;
            ListNode *newhead=head-&amp;gt;next;
            head-&amp;gt;next=NULL;
            return newhead;   
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Reverse a singly linked list.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-144-Binary Tree Preorder Traversal</title>
    <link href="http://yoursite.com/2016/05/24/Leetcode-144-Binary-Tree-Preorder-Traversal/"/>
    <id>http://yoursite.com/2016/05/24/Leetcode-144-Binary-Tree-Preorder-Traversal/</id>
    <published>2016-05-24T03:15:59.000Z</published>
    <updated>2016-05-24T03:21:03.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the preorder traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree {1,#,2,3},&lt;br&gt;       1&lt;br&gt;      \&lt;br&gt;         2&lt;br&gt;        /&lt;br&gt;         3&lt;br&gt;return [1,2,3].&lt;/p&gt;
&lt;p&gt;Note: Recursive solution is trivial, could you do it iteratively?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;二叉树前序遍历。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;如果用递归做这道题很简单，这里本文提供一种非递归的解法。利用一个辅助栈，既然是先序遍历，那么右子树应该先入栈，接着是左子树。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) {
            stack&amp;lt;TreeNode*&amp;gt; s;
            vector&amp;lt;int&amp;gt; res;
            while(!s.empty()||root)
                {

                    if(root)
                        {
                            res.push_back(root-&amp;gt;val);
                            if(root-&amp;gt;right)
                                s.push(root-&amp;gt;right);
                            root=root-&amp;gt;left;
                        }
                    else{
                            root=s.top();
                            s.pop();
                        }
                }
            return res;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the preorder traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree {1,#,2,3},&lt;br&gt;       1&lt;br&gt;      \&lt;br&gt;         2&lt;br&gt;        /&lt;br&gt;         3&lt;br&gt;return [1,2,3].&lt;/p&gt;
&lt;p&gt;Note: Recursive solution is trivial, could you do it iteratively?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-268-Missing Number</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-268-Missing-Number/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-268-Missing-Number/</id>
    <published>2016-05-23T14:17:51.000Z</published>
    <updated>2016-05-23T14:22:25.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给你一个n个互异整数组成的数组，其中少掉了一个数字，求这个数字。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题有很多解法。对于O(n)的解法，可以求出和，再减去每个数字。对于位运算来说就是求所有的异或再与完整数组异或一次。本文给出数学的解法。&lt;br&gt;如果是排好序的数组，可以利用二分查找进而把复杂度降低到O（lgn）&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int n=nums.size();
            int res=n*(n+1)/2;
            for(int i=0;i&amp;lt;n;i++)
            res-=nums[i];

                return res;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-343-Integer Break</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-343-Integer-Break/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-343-Integer-Break/</id>
    <published>2016-05-23T13:55:31.000Z</published>
    <updated>2016-05-23T14:01:49.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.&lt;/p&gt;
&lt;p&gt;For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).&lt;/p&gt;
&lt;p&gt;Note: you may assume that n is not less than 2.&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;There is a simple O(n) solution to this problem.&lt;br&gt;You may check the breaking results of n ranging from 7 to 10 to discover the regularities.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个正整数，把它拆分成至少2个正整数的和，然后求这些正整数的乘积的最大值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;通过动态规划可以很简单的得出状态转移方程，当n为4以下的时候，只能拆分为1和n-1，4以上时，拆分为2，n-2或者3，n-3时，能够获得最大乘积。（其实这个稍微感觉一下，就是幂函数的增长速度是最快的一样）&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int integerBreak(int n) {
            vector&amp;lt;int&amp;gt; dp(n+1);
            if(n&amp;lt;4) return n-1;
            dp[2]=2;
            dp[3]=3;
            for(int i=4;i&amp;lt;=n;i++)
                dp[i]=max(dp[i-2]*2,dp[i-3]*3);

            return dp[n];
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.&lt;/p&gt;
&lt;p&gt;For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).&lt;/p&gt;
&lt;p&gt;Note: you may assume that n is not less than 2.&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;There is a simple O(n) solution to this problem.&lt;br&gt;You may check the breaking results of n ranging from 7 to 10 to discover the regularities.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-319-Bulb Switcher</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-319-Bulb-Switcher/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-319-Bulb-Switcher/</id>
    <published>2016-05-23T13:33:27.000Z</published>
    <updated>2016-05-23T13:53:03.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given n = 3. 

At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 

So you should return 1, because there is only one bulb is on.
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;有n个开关，第i次操作你拨动所有i整数倍序号的开关。问最后有几盏灯留下了。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;任何一个开关都会被拨动偶数次，除非它是一个完全平方数，本题目即是求不大于n的完全平方数有几个&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int bulbSwitch(int n) {
               return sqrt(n);

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given n = 3. 

At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 

So you should return 1, because there is only one bulb is on.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-169-Majority Element</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-169-Majority-Element/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-169-Majority-Element/</id>
    <published>2016-05-23T13:30:40.000Z</published>
    <updated>2016-05-23T13:32:30.000Z</updated>
    
    <content type="html">&lt;p&gt;Problem Description:&lt;br&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;h2 id=&quot;You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot;&gt;&lt;a href=&quot;#You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot; class=&quot;headerlink&quot; title=&quot;You may assume that the array is non-empty and the majority element always exist in the array.&quot;&gt;&lt;/a&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/h2&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个数组，里面有一个元素出现了至少⌊ n/2 ⌋次，找到这个元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;排序以后中间的那个元素肯定是所求元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            sort(nums.begin(),nums.end());
            return nums[nums.size()/2];
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Problem Description:&lt;br&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;h2 id=&quot;You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot;&gt;&lt;a href=&quot;#You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot; class=&quot;headerlink&quot; title=&quot;You may assume that the array is non-empty and the majority element always exist in the array.&quot;&gt;&lt;/a&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/h2&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-217-Contains Duplicate</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-217-Contains-Duplicate/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-217-Contains-Duplicate/</id>
    <published>2016-05-23T10:19:21.000Z</published>
    <updated>2016-05-23T10:22:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，找出其是否包含重复元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的利用一个哈希表存储所有未重复数字，当发现重复数字即可返回true,否则返回false&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            set&amp;lt;int&amp;gt; s;
            for(int i=0;i&amp;lt;nums.size();i++){
                if(s.find(nums[i])!=s.end()) return true;
                else s.insert(nums[i]);
            }
            return false;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-171-Excel Sheet Column Number</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-171-Excel-Sheet-Column-Number/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-171-Excel-Sheet-Column-Number/</id>
    <published>2016-05-23T10:16:28.000Z</published>
    <updated>2016-05-23T10:18:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;Given a column title as appear in an Excel sheet, return its corresponding column number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A -&amp;gt; 1
B -&amp;gt; 2
C -&amp;gt; 3
...
Z -&amp;gt; 26
AA -&amp;gt; 27
AB -&amp;gt; 28 
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的26进制转化问题。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int titleToNumber(string s) {
            int res=0;
            int high=s.length()-1;
            for(int i=0;i&amp;lt;s.length();i++)
                res+=pow(26,high-i)*(s[i]-&amp;apos;A&amp;apos;+1);

            return res;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
</feed>
