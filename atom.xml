<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://since1992.org/"/>
  <updated>2016-06-19T04:10:57.000Z</updated>
  <id>http://since1992.org/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-119-Pascal&#39;s Triangle II</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-119-Pascal-s-Triangle-II/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-119-Pascal-s-Triangle-II/</id>
    <published>2016-06-19T04:09:19.000Z</published>
    <updated>2016-06-19T04:10:57.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an index k, return the kth row of the Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given k = 3,&lt;br&gt;Return [1,3,3,1].&lt;br&gt;Note:&lt;br&gt;Could you optimize your algorithm to use only O(k) extra space?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字N，返回帕斯卡三角的第N行结果。只能使用 O(k)的额外空间。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用循环累加的办法生成对应行即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; getRow(int rowIndex) {
        vector&amp;lt;int&amp;gt; row(1,1);
        if(rowIndex&amp;lt;1) return row;
        for(int i=1;i&amp;lt;=rowIndex;i++)
        {
            int prev1=row[0];
            int prev2;
            for(int j=1;j&amp;lt;i;j++)
                {
                    prev2=row[j];
                    row[j]+=prev1;
                    prev1=prev2;
                }
            row.push_back(1);
        }
        return row;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an index k, return the kth row of the Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given k = 3,&lt;br&gt;Return [1,3,3,1].&lt;br&gt;Note:&lt;br&gt;Could you optimize your algorithm to use only O(k) extra space?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-172-Factorial Trailing Zeroes</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-172-Factorial-Trailing-Zeroes/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-172-Factorial-Trailing-Zeroes/</id>
    <published>2016-06-19T03:35:30.000Z</published>
    <updated>2016-06-19T03:37:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;p&gt;Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个整数N，返回n的阶乘的结果中末尾0的个数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;其实很简单，就是考的1-n中有几个5的因子，注意到5的次幂有不止1个因子5即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int trailingZeroes(int n) {
        int count=0;
        while(n&amp;gt;1)
        {
            count+=n/5;
            n/=5;
        }
       return count; 
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;p&gt;Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-102-Binary Tree Level Order Traversal</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-102-Binary-Tree-Level-Order-Traversal/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2016-06-19T03:30:09.000Z</published>
    <updated>2016-06-19T03:32:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its level order traversal as:&lt;br&gt;    [&lt;br&gt;      [3],&lt;br&gt;      [9,20],&lt;br&gt;      [15,7]&lt;br&gt;    ]&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回层次遍历的结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题和&lt;a href=&quot;/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/&quot;&gt;这道题&lt;/a&gt;一样，没什么好说的，很简单利用一个队列完成BFS操作。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
        vector&amp;lt;int&amp;gt; tem;
        if(!root) return res;
        queue&amp;lt;TreeNode*&amp;gt; q;
        q.push(root);
        q.push(NULL);
        while(!q.empty())
        {
            TreeNode* t=q.front();
            q.pop();
            if(t)
            {
                tem.push_back(t-&amp;gt;val);
                if(t-&amp;gt;left)
                    q.push(t-&amp;gt;left);
                if(t-&amp;gt;right)
                    q.push(t-&amp;gt;right);
            }else{
                if(!q.empty())
                {
                    res.push_back(tem);
                    tem.clear();
                    q.push(NULL);
                }else{
                    res.push_back(tem);
                }
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its level order traversal as:&lt;br&gt;    [&lt;br&gt;      [3],&lt;br&gt;      [9,20],&lt;br&gt;      [15,7]&lt;br&gt;    ]&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="BFS" scheme="http://since1992.org/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-26-Remove Duplicates from Sorted Array</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-26-Remove-Duplicates-from-Sorted-Array/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-26-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2016-06-19T02:58:32.000Z</published>
    <updated>2016-06-19T03:01:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given input array nums = [1,1,2],&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个已排序的数组，去除重复元素， 然后返回新的长度，只能使用O(1)的额外空间。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的一次遍历即可。当某个数比它前一个数大的时候说明它是新的一个未重复元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int count=0;
        if(nums.empty()) return count;
        count++;
        for(int i=1;i&amp;lt;nums.size();i++)
        {
          if(nums[i]&amp;gt;nums[i-1])
            nums[count++]=nums[i];
        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given input array nums = [1,1,2],&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-118-Pascal&#39;s Triangle</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-118-Pascal-s-Triangle/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-118-Pascal-s-Triangle/</id>
    <published>2016-06-18T14:14:33.000Z</published>
    <updated>2016-06-18T14:16:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given numRows, generate the first numRows of Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given numRows = 5,&lt;br&gt;Return&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字N，生成前N行帕斯卡三角。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;至于什么是帕斯卡三角，可以参加&lt;a href=&quot;https://en.wikipedia.org/wiki/Pascal%27s_triangle&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt;,找出规律以后写代码就容易了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans;
        if(numRows&amp;lt;=0) return ans;
        ans.resize(numRows);
        for(int i=0;i&amp;lt;numRows;i++)
        {
            ans[i].resize(i+1,1);
            for(int j=1;j&amp;lt;i;j++)
            ans[i][j]=ans[i-1][j]+ans[i-1][j-1];
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given numRows, generate the first numRows of Pascal’s triangle.&lt;/p&gt;
&lt;p&gt;For example, given numRows = 5,&lt;br&gt;Return&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-232-Implement Queue using Stacks</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/</id>
    <published>2016-06-18T13:45:20.000Z</published>
    <updated>2016-06-18T13:47:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a queue using stacks.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x to the back of queue.&lt;br&gt;pop() – Removes the element from in front of queue.&lt;br&gt;peek() – Get the front element.&lt;br&gt;empty() – Return whether the queue is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.&lt;br&gt;Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.&lt;br&gt;You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;用栈实现队列的操作。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单，用两个栈即可取到任意一端的元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Queue {
    stack&amp;lt;int&amp;gt; s1;
    stack&amp;lt;int&amp;gt; s2;
public:
    // Push element x to the back of queue.
    void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        s2.pop();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }

    }

    // Get the front element.
    int peek(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        int p = s2.top();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }
        return p;
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return s1.empty();

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a queue using stacks.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x to the back of queue.&lt;br&gt;pop() – Removes the element from in front of queue.&lt;br&gt;peek() – Get the front element.&lt;br&gt;empty() – Return whether the queue is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.&lt;br&gt;Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.&lt;br&gt;You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
      <category term="Design" scheme="http://since1992.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-66-Plus One</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-66-Plus-One/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-66-Plus-One/</id>
    <published>2016-06-18T13:36:38.000Z</published>
    <updated>2016-06-18T13:37:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative number represented as an array of digits, plus one to the number.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个数组表示一个数字，返回它加一的结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的一道题，注意进位的处理，以及全9的情况即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) {
        int i = digits.size()-1;
        while(i&amp;gt;=0)
        {
            if(digits[i]&amp;lt;9){
                digits[i]++;
                return digits;
            }
            digits[i--]=0;

        }
        digits.insert(digits.begin(),1);
        return digits;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative number represented as an array of digits, plus one to the number.&lt;/p&gt;
&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-342-Power of Four</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-342-Power-of-Four/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-342-Power-of-Four/</id>
    <published>2016-06-18T11:18:22.000Z</published>
    <updated>2016-06-18T12:33:17.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given num = 16, return true. Given num = 5, return false.&lt;/p&gt;
&lt;p&gt;Follow up: Could you solve it without loops/recursion?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个32位的整数，判断它是否是4的幂。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本体与&lt;a href=&quot;/2016/06/07/Leetcode-231-Power-of-Two/&quot;&gt;求2的幂&lt;/a&gt;和&lt;a href=&quot;/2016/06/07/Leetcode-326-Power-of-Tree/&quot;&gt;求3的幂&lt;/a&gt;类似，解法可参加这两题。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isPowerOfFour(int num) {
        while(num&amp;gt;1&amp;amp;&amp;amp;num%4==0)
        {
            num/=4;
        }
        return num==1;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given num = 16, return true. Given num = 5, return false.&lt;/p&gt;
&lt;p&gt;Follow up: Could you solve it without loops/recursion?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Matt" scheme="http://since1992.org/tags/Matt/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-107-Binary Tree Level Order Traversal II</title>
    <link href="http://since1992.org/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/"/>
    <id>http://since1992.org/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/</id>
    <published>2016-06-18T10:26:12.000Z</published>
    <updated>2016-06-18T10:28:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its bottom-up level order traversal as:&lt;br&gt;    [&lt;br&gt;      [15,7],&lt;br&gt;      [9,20],&lt;br&gt;      [3]&lt;br&gt;    ]&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回从底至顶的层次遍历结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用一个辅助队列完成BFS.再反向存储数组即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Definition for a binary tree node.&lt;/li&gt;
&lt;li&gt;struct TreeNode {&lt;/li&gt;
&lt;li&gt;int val;&lt;/li&gt;
&lt;li&gt;TreeNode *left;&lt;/li&gt;
&lt;li&gt;TreeNode *right;&lt;/li&gt;
&lt;li&gt;TreeNode(int x) : val(x), left(NULL), right(NULL) {}&lt;/li&gt;
&lt;li&gt;};&lt;br&gt;*/&lt;br&gt;class Solution {&lt;br&gt; public:&lt;pre&gt;&lt;code&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrderBottom(TreeNode* root) {
    vector&amp;lt;int&amp;gt; tem;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans;
    queue &amp;lt;TreeNode*&amp;gt; q;
    if(!root) return ans;
    q.push(root);
    q.push(NULL);
    while(!q.empty())
    {
        TreeNode * t = q.front();
        q.pop();
        if(t){
            tem.push_back(t-&amp;gt;val);
            if(t-&amp;gt;left)
            q.push(t-&amp;gt;left);
            if(t-&amp;gt;right)
            q.push(t-&amp;gt;right);
        }else
        {
            if(!q.empty()){
            ans.push_back(tem);
            tem.clear();
            q.push(NULL);}
            else
            ans.push_back(tem);
        }
    }
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    for(int i=ans.size()-1;i&amp;gt;=0;i--)
    res.push_back(ans[i]);
    return res;
}
&lt;/code&gt;&lt;/pre&gt; };&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;        3&lt;br&gt;       / \&lt;br&gt;      9  20&lt;br&gt;        /  \&lt;br&gt;       15   7&lt;br&gt;return its bottom-up level order traversal as:&lt;br&gt;    [&lt;br&gt;      [15,7],&lt;br&gt;      [9,20],&lt;br&gt;      [3]&lt;br&gt;    ]&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="BFS" scheme="http://since1992.org/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-101-Symmetric Tree</title>
    <link href="http://since1992.org/2016/06/16/Leetcode-101-Symmetric-Tree/"/>
    <id>http://since1992.org/2016/06/16/Leetcode-101-Symmetric-Tree/</id>
    <published>2016-06-16T04:16:10.000Z</published>
    <updated>2016-06-18T14:20:31.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;
&lt;p&gt;For example, this binary tree [1,2,2,3,4,4,3] is symmetric:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1
   / \
  2   2
 / \ / \
3  4 4  3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But the following [1,2,2,null,3,null,3] is not:&lt;br&gt;        1&lt;br&gt;       / \&lt;br&gt;      2   2&lt;br&gt;       \   \&lt;br&gt;       3    3&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵树，检查它是否是中心对称的。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单，运用一个辅助函数检查两棵树是否对称即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isM(root-&amp;gt;left,root-&amp;gt;right);

    }
    bool isM(TreeNode* a,TreeNode* b)
    {
        if(!a&amp;amp;&amp;amp;!b) return true;
        if((a&amp;amp;&amp;amp;!b)||(b&amp;amp;&amp;amp;!a)) return false;
        if(a-&amp;gt;val!=b-&amp;gt;val) return false;
        return isM(a-&amp;gt;left,b-&amp;gt;right)&amp;amp;&amp;amp;isM(a-&amp;gt;right,b-&amp;gt;left);
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;
&lt;p&gt;For example, this binary tree [1,2,2,3,4,4,3] is symmetric:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1
   / \
  2   2
 / \ / \
3  4 4  3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But the following [1,2,2,null,3,null,3] is not:&lt;br&gt;        1&lt;br&gt;       / \&lt;br&gt;      2   2&lt;br&gt;       \   \&lt;br&gt;       3    3&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-27-Remove Element</title>
    <link href="http://since1992.org/2016/06/16/Leetcode-27-Remove-Element/"/>
    <id>http://since1992.org/2016/06/16/Leetcode-27-Remove-Element/</id>
    <published>2016-06-16T03:59:47.000Z</published>
    <updated>2016-06-16T04:07:13.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array and a value, remove all instances of that value in place and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;The order of elements can be changed. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given input array nums = [3,2,2,3], val = 3&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组和一个特定的值，移除数组中所有该值，并返回剩余值的个数。你只能只用O(1)的额外空间，数字的顺序可以改变。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题和&lt;a href=&quot;2016/05/23/Leetcode-283-Move-Zeroes/&quot;&gt;这道题&lt;/a&gt;很类似，只是删除特定的值而已。我们的策略就是把所有的特定值都移动到数组的末尾。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) {
        int p=0;
        for(int i=0;i&amp;lt;nums.size();i++)
        {
            if(nums[i]!=val)
                swap(nums[i],nums[p++]);
        }
        return p;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array and a value, remove all instances of that value in place and return the new length.&lt;/p&gt;
&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;
&lt;p&gt;The order of elements can be changed. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given input array nums = [3,2,2,3], val = 3&lt;/p&gt;
&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 2.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-110-Balanced Binary Tree</title>
    <link href="http://since1992.org/2016/06/12/Leetcode-110-Balanced-Binary-Tree/"/>
    <id>http://since1992.org/2016/06/12/Leetcode-110-Balanced-Binary-Tree/</id>
    <published>2016-06-12T03:11:11.000Z</published>
    <updated>2016-06-12T03:13:20.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，判断它是否平衡。一个平衡的二叉树的左右子树的深度差小于或等于1.&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的DFS问题，先判断左右子树是否为平衡二叉树，再判断它们的高度差是否在1以内。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        if(isBalanced(root-&amp;gt;left)&amp;amp;&amp;amp;isBalanced(root-&amp;gt;right))
            if(abs(height(root-&amp;gt;left)-height(root-&amp;gt;right))&amp;lt;2)
                return true;
        return false;

    }
    int height(TreeNode* root)
    {
        if(!root) return 0;
        return 1+max(height(root-&amp;gt;left),height(root-&amp;gt;right));
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-24-Swap Nodes in Pairs</title>
    <link href="http://since1992.org/2016/06/12/Leetcode-24-Swap-Nodes-in-Pairs/"/>
    <id>http://since1992.org/2016/06/12/Leetcode-24-Swap-Nodes-in-Pairs/</id>
    <published>2016-06-12T02:57:01.000Z</published>
    <updated>2016-06-12T02:58:29.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.&lt;/p&gt;
&lt;p&gt;Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;交换每一对链表的顺序。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用一个递归的办法可以简单的完成这个问题，注意边界。 当然用非递归的办法也可以，不过写法并不够简洁，本文仅提供递归的解法。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head||!head-&amp;gt;next) return head;
        ListNode * nextp = head-&amp;gt;next-&amp;gt;next;
        ListNode * tem = head-&amp;gt;next;
        head-&amp;gt;next = swapPairs(nextp);
        tem-&amp;gt;next = head;
        return tem;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.&lt;/p&gt;
&lt;p&gt;Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-198-House Robber</title>
    <link href="http://since1992.org/2016/06/11/Leetcode-198-House-Robber/"/>
    <id>http://since1992.org/2016/06/11/Leetcode-198-House-Robber/</id>
    <published>2016-06-11T03:40:46.000Z</published>
    <updated>2016-06-11T03:43:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;一排房子每个房子有一个价值，一个小偷进行偷窃，不可以连续偷挨着的两家，求小偷的最大收益。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的一维动态规划问题。每个房子要么不偷，要么偷，如果不偷收益和前一个房子一样，如果偷则为前两个房子的最大收益加上这个房子的价值，两种情况下最大的收益即为到这个房子为止的最大收益。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if(nums.empty()) return 0;
        vector&amp;lt;int&amp;gt; dp(nums.size(),0);
        dp[0]=nums[0];
        dp[1]=nums[0]&amp;gt;nums[1]?nums[0]:nums[1];
        for(int i=2;i&amp;lt;nums.size();i++)
        {
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp.back();
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Dynamic Programming" scheme="http://since1992.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-345-Reverse Vowels of a String</title>
    <link href="http://since1992.org/2016/06/11/Leetcode-345-Reverse-Vowels-of-a-String/"/>
    <id>http://since1992.org/2016/06/11/Leetcode-345-Reverse-Vowels-of-a-String/</id>
    <published>2016-06-11T03:31:12.000Z</published>
    <updated>2016-06-11T03:35:52.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes a string as input and reverse only the vowels of a string.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;Given s = “hello”, return “holle”.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;Given s = “leetcode”, return “leotcede”.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个字符串中所有元音字母的位置。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;记录下来元音字母的顺序以及位置，在位置中倒序插入字母即可。当然也可以使用双指针，从头尾开始扫描，一旦扫描到两个元音字母，则交换他们，这种算法可以使得额外空间代价降低到O(1)。本文只提供第一种解法。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string reverseVowels(string s) {
        vector&amp;lt;char&amp;gt; c;
        vector&amp;lt;int&amp;gt; p;
        for(int i=0;i&amp;lt;s.length();i++)
        {
            if(isV(s[i]))
            {
                c.push_back(s[i]);
                p.push_back(i);
            }
        }
        for(int i=0;i&amp;lt;p.size();i++)
        {
            s[p[i]]=c[c.size()-1-i];
        }
        return s;

    }
    bool isV(char x)
    {
        return x==&amp;apos;a&amp;apos;||x==&amp;apos;e&amp;apos;||x==&amp;apos;i&amp;apos;||x==&amp;apos;o&amp;apos;||x==&amp;apos;u&amp;apos;||x==&amp;apos;A&amp;apos;||x==&amp;apos;E&amp;apos;||x==&amp;apos;I&amp;apos;||x==&amp;apos;O&amp;apos;||x==&amp;apos;U&amp;apos;;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes a string as input and reverse only the vowels of a string.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;Given s = “hello”, return “holle”.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;Given s = “leetcode”, return “leotcede”.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-21-Merge Two Sorted Lists</title>
    <link href="http://since1992.org/2016/06/11/Leetcode-21-Merge-Two-Sorted-Lists/"/>
    <id>http://since1992.org/2016/06/11/Leetcode-21-Merge-Two-Sorted-Lists/</id>
    <published>2016-06-11T03:21:44.000Z</published>
    <updated>2016-06-11T03:23:06.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;合并两个已排好序的单向链表&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;非常简单的链表基本操作，实现即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1) return l2;
        if(!l2) return l1;
        ListNode* l3;
        if(l1-&amp;gt;val&amp;lt;l2-&amp;gt;val)
        {
            l3=l1;
            l3-&amp;gt;next=mergeTwoLists(l1-&amp;gt;next,l2);
        }else{
            l3=l2;
            l3-&amp;gt;next=mergeTwoLists(l1,l2-&amp;gt;next);
        }
        return l3;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-121-Best Time to Buy and Sell Stock</title>
    <link href="http://since1992.org/2016/06/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>http://since1992.org/2016/06/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2016-06-10T15:17:29.000Z</published>
    <updated>2016-06-10T15:18:54.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;有一个数组表示一段时间内某只股票每天的价格，如果你只能买卖一次，求你能获得的最大利润&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;依次找到最小值，然后再记录最大差值，返回最大差值即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {
        if(prices.size()&amp;lt;2) return 0;
        vector&amp;lt;int&amp;gt;dp(prices.size(),0);
        int max=INT_MIN;
        int min=prices[0];
        for(int i=1;i&amp;lt;prices.size();i++)
        {
            if(prices[i]&amp;lt;min) min=prices[i];
            dp[i]=prices[i]-min;
            if(dp[i]&amp;gt;max)
            max=dp[i];

        }
        return max;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Dynamic Programming" scheme="http://since1992.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-153-Find Minimum in Rotated Sorted Array</title>
    <link href="http://since1992.org/2016/06/10/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://since1992.org/2016/06/10/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2016-06-10T14:53:48.000Z</published>
    <updated>2016-06-10T14:56:57.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).&lt;/p&gt;
&lt;p&gt;Find the minimum element.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;某个排好序的数组从某一点开始到数组结尾，被全体移动到数组的最开始位置。求这个数组的最小值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;求数组的最小值，一般情况下需要遍历一次数组，即用O(n)的时间，不过这道题给定的是预先排好序的数组，而且是被移动的是整个子序列，所以我们可以使用二分查找的办法，把时间复杂度缩短到O(logn)。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if(nums.size()==1) return nums[0];
        int begin=0,end=nums.size()-1,mid=begin+(end-begin)/2;
        while(begin&amp;lt;end)
        {
            if(nums[mid]&amp;gt;nums[mid+1]) return nums[mid+1];
            else if(nums[mid]&amp;lt;nums[end])
            {
                end=mid;
                mid=begin+(end-begin)/2;
            }
            else if(nums[mid]&amp;gt;nums[end])
            {
                begin=mid;
                mid=begin+(end-begin)/2;
            }

        }
        return nums[end];

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).&lt;/p&gt;
&lt;p&gt;Find the minimum element.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://since1992.org/tags/Medium/"/>
    
      <category term="Binary Search" scheme="http://since1992.org/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-116-Populating Next Right Pointers in Each Node</title>
    <link href="http://since1992.org/2016/06/10/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/"/>
    <id>http://since1992.org/2016/06/10/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/</id>
    <published>2016-06-10T14:41:03.000Z</published>
    <updated>2016-06-10T14:45:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may only use constant extra space.&lt;br&gt;You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).&lt;br&gt;For example,&lt;br&gt;Given the following perfect binary tree,&lt;br&gt;             1&lt;br&gt;           /  \&lt;br&gt;          2    3&lt;br&gt;         / \  / \&lt;br&gt;        4  5  6  7&lt;br&gt;After calling your function, the tree should look like:&lt;br&gt;             1 -&amp;gt; NULL&lt;br&gt;           /  \&lt;br&gt;          2 -&amp;gt; 3 -&amp;gt; NULL&lt;br&gt;         / \  / \&lt;br&gt;        4-&amp;gt;5-&amp;gt;6-&amp;gt;7 -&amp;gt; NULL&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一棵树添加右指针，每一行的末尾指向NULL。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的DFS的问题，利用一个队列，完成层次遍历即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(!root) return;
        queue&amp;lt;TreeLinkNode*&amp;gt; q;
        q.push(root);
        q.push(NULL);
        while(!q.empty())
        {
            TreeLinkNode *tem = q.front();
            q.pop();

            if(tem)
            {
                tem-&amp;gt;next=q.front();
                if(tem-&amp;gt;left)
                    q.push(tem-&amp;gt;left);
                if(tem-&amp;gt;right)
                    q.push(tem-&amp;gt;right);

            }
            else
            {
                if(!q.empty())
                {
                    q.push(NULL);
                    continue;
                }
                else break;
            }
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&lt;/p&gt;
&lt;p&gt;Initially, all next pointers are set to NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You may only use constant extra space.&lt;br&gt;You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).&lt;br&gt;For example,&lt;br&gt;Given the following perfect binary tree,&lt;br&gt;             1&lt;br&gt;           /  \&lt;br&gt;          2    3&lt;br&gt;         / \  / \&lt;br&gt;        4  5  6  7&lt;br&gt;After calling your function, the tree should look like:&lt;br&gt;             1 -&amp;gt; NULL&lt;br&gt;           /  \&lt;br&gt;          2 -&amp;gt; 3 -&amp;gt; NULL&lt;br&gt;         / \  / \&lt;br&gt;        4-&amp;gt;5-&amp;gt;6-&amp;gt;7 -&amp;gt; NULL&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
      <category term="Medium" scheme="http://since1992.org/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-62-Unique Paths</title>
    <link href="http://since1992.org/2016/06/10/Leetcode-62-Unique-Paths/"/>
    <id>http://since1992.org/2016/06/10/Leetcode-62-Unique-Paths/</id>
    <published>2016-06-10T14:21:16.000Z</published>
    <updated>2016-06-10T14:45:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;/p&gt;
&lt;p&gt;How many possible unique paths are there?&lt;br&gt;&lt;a href=&quot;http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;如图所示，机器人从最左上角走到最右下角，它只能往右或者往下走，求它有多少种不重复的走法。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的二维动态规划问题。对于第一行和第一列来说，走到该格子只能沿着直线走，所以走到这些格子的方法数为1.而其他的格子，因为只能往右和往下走，那么第（i,j）格可以由（i,j-1）往下走一步或者(i-1,j)往右走一步达到，所以该格子的方法数应该是这辆格数字的和。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;class Solution {&lt;br&gt;    public:&lt;br&gt;        int uniquePaths(int m, int n) {&lt;br&gt;            vector&lt;int&gt; a(m,1);&lt;br&gt;            vector&lt;vector&lt;int&gt;&amp;gt; map;&lt;br&gt;            for(int i=0;i&amp;lt;n;i++)&lt;br&gt;            map.push_back(a);&lt;br&gt;            for(int i=1;i&amp;lt;n;i++)&lt;br&gt;                for(int j=1;j&amp;lt;m;j++)&lt;br&gt;                    map[i][j]=map[i-1][j]+map[i][j-1];&lt;br&gt;            return map[n-1][m-1];&lt;br&gt;        }&lt;br&gt;    };&lt;/vector&lt;int&gt;&lt;/int&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;/p&gt;
&lt;p&gt;How many possible unique paths are there?&lt;br&gt;&lt;a href=&quot;http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://since1992.org/tags/Medium/"/>
    
      <category term="Dynamic Programming" scheme="http://since1992.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
