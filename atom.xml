<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-06-07T15:48:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-350-Intersection of Two Arrays II</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-350-Intersection-of-Two-Arrays-II/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-350-Intersection-of-Two-Arrays-II/</id>
    <published>2016-06-07T15:39:24.000Z</published>
    <updated>2016-06-07T15:48:27.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;br&gt;The result can be in any order.&lt;br&gt;Follow up:&lt;br&gt;What if the given array is already sorted? How would you optimize your algorithm?&lt;br&gt;What if nums1’s size is small compared to nums2’s size? Which algorithm is better?&lt;br&gt;What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个数组，写一个函数来返回两个数组的交集，如果有重复的也需要返回。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题和&lt;a href=&quot;/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/&quot;&gt;这道题&lt;/a&gt;略有不同。本题需要返回交集中的重复数字。其实类似于这类集合的交、并集问题，&lt;a href=&quot;https://www.quora.com/Programming-Interview-Questions-How-do-you-find-out-intersection-between-two-arrays-when-they-are-sorted-when-they-are-not-sorted&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;讲的非常详细，推荐读一读。一个简单的算法，先对数组进行排序，然后使用双指针，当遍历完短数组后结束。这样复杂度为O(nlogn+mlogm)。如果是已排好序的数组，或者某一个数组已排好序，可以对未排序数组的每个元素在已排序数组里进行二分查找，复杂度为O(m*logn).本文提供排序后双指针的解法。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; intersect(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) {
            vector&amp;lt;int&amp;gt; res;
            if(nums1.empty()||nums2.empty()) return res;
            sort(nums1.begin(),nums1.end());
            sort(nums2.begin(),nums2.end());
            int i=0,j=0;
               while(i&amp;lt;nums1.size()&amp;amp;&amp;amp;j&amp;lt;nums2.size())
                   {
                       if(nums1[i]==nums2[j]){
                         res.push_back(nums1[i]);
                         i++;
                         j++;
                   }
                       else if(nums1[i]&amp;gt;nums2[j]) j++;
                       else i++;
           }
               return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;br&gt;The result can be in any order.&lt;br&gt;Follow up:&lt;br&gt;What if the given array is already sorted? How would you optimize your algorithm?&lt;br&gt;What if nums1’s size is small compared to nums2’s size? Which algorithm is better?&lt;br&gt;What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-141-Linked List Cycle</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-141-Linked-List-Cycle/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-141-Linked-List-Cycle/</id>
    <published>2016-06-07T14:50:05.000Z</published>
    <updated>2016-06-07T14:52:35.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个链表，判断它是否包含一个环&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;环链表的特征很多，最常用的判断方法是双指针法。让快慢两个指针同时在链表中遍历，如果存在环，那么两个指针一定会相遇。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        bool hasCycle(ListNode *head) {
            if(!head||!head-&amp;gt;next) return false;
            ListNode* fast=head-&amp;gt;next;
            ListNode* slow=head;
            while(slow&amp;amp;&amp;amp;fast&amp;amp;&amp;amp;slow!=fast)
                {
                    if(fast-&amp;gt;next)
                        fast=fast-&amp;gt;next-&amp;gt;next;
                    else return false;
                    slow=slow-&amp;gt;next;
                }
            return slow==fast;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-70-Climbing Stairs</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-70-Climbing-Stairs/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-70-Climbing-Stairs/</id>
    <published>2016-06-07T14:45:30.000Z</published>
    <updated>2016-06-07T14:49:15.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;你在爬一个楼梯，每一步要么爬一阶要么爬两阶，求爬到楼梯的顶部有多少种方法。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;一个简单的动态规划问题，后面的每一步都是前两个数的和，因为要么爬一阶要么爬两阶，那么除开最后一步，就变成和子问题一样的问题了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int climbStairs(int n) {
            vector&amp;lt;int&amp;gt; res(n+1);
            res[0]=1;
            res[1]=1;
            for(int i=2;i&amp;lt;=n;i++)
                res[i]=res[i-1]+res[i-2];
            return res[n];

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-202-Happy Number</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-202-Happy-Number/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-202-Happy-Number/</id>
    <published>2016-06-07T14:25:52.000Z</published>
    <updated>2016-06-07T14:43:01.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write an algorithm to determine if a number is “happy”.&lt;/p&gt;
&lt;p&gt;A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;
&lt;p&gt;Example: 19 is a happy number&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;快乐数的定义是这样的，循环做这个步骤：把某个正整数的每个位上的数字的平方相加。当这个循环包含了1的时候，它就是快乐数，判断一个数字是不是快乐数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;根据快乐数的定义，利用一个哈希表来记录出现过的数字，一旦出现循环，如果不是在1的地方循环，则这个数不是快乐数。很简单的题，细心，争取bugfree.&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isHappy(int n) {
            set&amp;lt;int&amp;gt; s;
            int sum=helper(n);
            while (s.find(sum)==s.end())
                {
                    s.insert(sum);
                    sum=helper(sum);
                }
            return sum==1;

            }
        int helper(int n)
            {
                int res=0;
                while(n&amp;gt;0)
                    {
                        res+=((n%10)*(n%10));
                        n/=10;
                    }
                return res;
                }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write an algorithm to determine if a number is “happy”.&lt;/p&gt;
&lt;p&gt;A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;
&lt;p&gt;Example: 19 is a happy number&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-263-Ugly Number</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-263-Ugly-Number/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-263-Ugly-Number/</id>
    <published>2016-06-07T14:22:04.000Z</published>
    <updated>2016-06-07T14:25:17.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to check whether a given number is an ugly number.&lt;/p&gt;
&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.&lt;/p&gt;
&lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;
&lt;p&gt;Credits:&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;丑数是指那些只有2，3，5作为质因子的数字，判断一个数是不是丑数。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;循环剔除所有2，3，5因子，看剩下的是否是1.&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isUgly(int num) {
            if(num==0) return false;
            while(num%5==0)
                num/=5;
            while(num%3==0)
                num/=3;
            while(num%2==0)
                num/=2;
            return num==1;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to check whether a given number is an ugly number.&lt;/p&gt;
&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.&lt;/p&gt;
&lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;
&lt;p&gt;Credits:&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-83-Remove Duplicates from Sorted List</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-83-Remove-Duplicates-from-Sorted-List/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-83-Remove-Duplicates-from-Sorted-List/</id>
    <published>2016-06-07T14:18:03.000Z</published>
    <updated>2016-06-07T14:21:30.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted linked list, delete all duplicates such that each element appear only once.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个已排序的链表，删除所有重复的结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;遍历整个链表，发现某个结点的下一个结点的值和它一样时，把它的下一个结点指向再后一个结点。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* deleteDuplicates(ListNode* head) {
                ListNode* p = head;
                if(!head) return head;
                while(p&amp;amp;&amp;amp;p-&amp;gt;next)
                    {
                        if(p-&amp;gt;val==p-&amp;gt;next-&amp;gt;val) 
                            p-&amp;gt;next=p-&amp;gt;next-&amp;gt;next;
                        else
                            p=p-&amp;gt;next;
                    }
                return head;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted linked list, delete all duplicates such that each element appear only once.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-231-Power of Two</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-231-Power-of-Two/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-231-Power-of-Two/</id>
    <published>2016-06-07T14:14:16.000Z</published>
    <updated>2016-06-07T14:17:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of two.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个整数，判断是否是2的整数幂。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;和&lt;a href=&quot;/2016/06/07/Leetcode-326-Power-of-Tree/&quot;&gt;这道题&lt;/a&gt;类似，只是判断是否是2的整数幂。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isPowerOfTwo(int n) {
            while(n&amp;gt;1)
                {
                    if(n%2&amp;gt;0) return false;
                    n/=2;
                }
            return n==1;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of two.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-326-Power of Tree</title>
    <link href="http://yoursite.com/2016/06/07/Leetcode-326-Power-of-Tree/"/>
    <id>http://yoursite.com/2016/06/07/Leetcode-326-Power-of-Tree/</id>
    <published>2016-06-07T14:11:14.000Z</published>
    <updated>2016-06-07T14:13:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个整数，判断它是不是3的幂&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的循环，判断最后是否得到1.&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isPowerOfThree(int n) {

            while(n&amp;gt;1)
                {
                    if(n%3&amp;gt;0) return false;
                    n/=3;
                }
            return n==1;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-337-House Robber III</title>
    <link href="http://yoursite.com/2016/05/27/Leetcode-337-House-Robber-III/"/>
    <id>http://yoursite.com/2016/05/27/Leetcode-337-House-Robber-III/</id>
    <published>2016-05-27T03:47:41.000Z</published>
    <updated>2016-06-07T14:09:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Determine the maximum amount of money the thief can rob tonight without alerting the police.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;一个树状的结构里，两个相邻的父，子结点不可以被同时偷，求盗贼的最大收益。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题可以使用动态规划,使用一个辅助函数返回是否抢该节点的两个收益最大值。动态转移方程为，左右均不偷+根节点或者偷左右不偷根节点，取最大值。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int rob(TreeNode* root) {
            vector&amp;lt;int&amp;gt; res = helper(root);
            return max(res[0],res[1]); 
    }

        vector&amp;lt;int&amp;gt; helper(TreeNode* root)
            {
                vector&amp;lt;int&amp;gt; res(2,0);
                if(!root) return res;
                vector&amp;lt;int&amp;gt; left = helper(root-&amp;gt;left);
                vector&amp;lt;int&amp;gt; right = helper(root-&amp;gt;right);
                res[0]= max(left[1],left[0])+max(right[1],right[0]);
                res[1]= left[0]+right[0]+root-&amp;gt;val;
                return res;
            }

    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Determine the maximum amount of money the thief can rob tonight without alerting the police.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-22-Generate Parentheses</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-22-Generate-Parentheses/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-22-Generate-Parentheses/</id>
    <published>2016-05-26T11:33:14.000Z</published>
    <updated>2016-05-26T14:39:10.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;/p&gt;
&lt;p&gt;“((()))”, “(()())”, “(())()”, “()(())”, “()()()”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数字，返回该数字对括号能产生的所有合法括号组合。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;使用回溯法，生成所有组合。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;string&amp;gt; generateParenthesis(int n) {
            vector&amp;lt;string&amp;gt; res;
            string tem;
            helper(res,tem,0,0,n);
            return res;

        }
        void helper(vector&amp;lt;string&amp;gt;&amp;amp;res,string&amp;amp; s,int left,int right,int n)
            {
                if(left==n&amp;amp;&amp;amp;right==n) {res.push_back(s);}

                if(left&amp;lt;n) {s.push_back(&amp;apos;(&amp;apos;); helper(res,s,left+1,right,n);s.pop_back();}
                if(right&amp;lt;left) {s.push_back(&amp;apos;)&amp;apos;); helper(res,s,left,right+1,n);s.pop_back();}

            }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;/p&gt;
&lt;p&gt;“((()))”, “(()())”, “(())()”, “()(())”, “()()()”&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-35-Search Insert Position</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-35-Search-Insert-Position/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-35-Search-Insert-Position/</id>
    <published>2016-05-26T11:28:02.000Z</published>
    <updated>2016-05-26T11:32:34.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.&lt;br&gt;[1,3,5,6], 5 → 2&lt;br&gt;[1,3,5,6], 2 → 1&lt;br&gt;[1,3,5,6], 7 → 4&lt;br&gt;[1,3,5,6], 0 → 0&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个排好序的数组和一个值，返回它的下标，如果它在数组里，否则，则返回该值应该被插入的位置。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;找到第一个大于该值的位置，返回之前一个位置。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
            if(target&amp;lt;nums[0]) return 0;
            if(target&amp;gt;nums[nums.size()-1]) return nums.size();
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                    if(nums[i]==target) return i;
                    else if(nums[i]&amp;lt;target) continue;
                    else if(nums[i-1]&amp;lt;target) return i;  
                }
            return 0;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.&lt;br&gt;[1,3,5,6], 5 → 2&lt;br&gt;[1,3,5,6], 2 → 1&lt;br&gt;[1,3,5,6], 7 → 4&lt;br&gt;[1,3,5,6], 0 → 0&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-108-Convert Sorted Array to Binary Search Tree</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</id>
    <published>2016-05-26T10:54:00.000Z</published>
    <updated>2016-05-26T11:27:33.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个已排序数组，把它转化成一个平衡BST。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用DFS和递归调用函数生成。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            return helper(nums,0,nums.size()-1);
    }
        TreeNode* helper(vector&amp;lt;int&amp;gt; &amp;amp;nums,int begin,int end)
                {
                if(begin&amp;gt;end) return NULL;
                if(begin==end) return new TreeNode(nums[begin]);
                int mid = begin + (end-begin)/2;
                 TreeNode* res = new TreeNode(nums[mid]);
                 res-&amp;gt;left = helper(nums,begin,mid-1);
                 res-&amp;gt;right = helper(nums,mid+1,end);
                 return res;
                }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-235-Lowest Common Ancester of a Binary Search Tree</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-235-Lowest-Common-Ancester-of-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-235-Lowest-Common-Ancester-of-a-Binary-Search-Tree/</id>
    <published>2016-05-26T10:49:18.000Z</published>
    <updated>2016-05-26T10:52:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;找到两个节点的最低相同祖先。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先求出两条路径，再找到最后一个相同元素即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            vector&amp;lt;TreeNode*&amp;gt; p1;
            vector&amp;lt;TreeNode*&amp;gt; q1;
            findpath(p1,p,root);
            findpath(q1,q,root);
            for(int i=p1.size()-1;i&amp;gt;=0;i--)
                {
                    if(find(q1.begin(),q1.end(),p1[i])!=q1.end())
                        return p1[i];
                }
            return NULL;


        }
        void findpath(vector&amp;lt;TreeNode*&amp;gt;&amp;amp; path,TreeNode* p, TreeNode* root)
            {
                TreeNode* current = root;
                while(current-&amp;gt;val!=p-&amp;gt;val)
                    {
                        path.push_back(current);
                        if(current-&amp;gt;val&amp;gt;p-&amp;gt;val)
                            current=current-&amp;gt;left;
                        else current=current-&amp;gt;right;
                        }
                path.push_back(p);
            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-96-Unique Binary Search Trees</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-96-Unique-Binary-Search-Trees/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-96-Unique-Binary-Search-Trees/</id>
    <published>2016-05-26T10:35:53.000Z</published>
    <updated>2016-05-26T10:44:25.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given n = 3, there are a total of 5 unique BST’s.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个数字，求有多少个不同的二叉搜索树。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用动态规划，两边的可能性相乘的和即为总数。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int numTrees(int n) {
            vector&amp;lt;int&amp;gt; ans(n+1,0);
            ans[0]=1;
            ans[1]=1;
            for(int i=2;i&amp;lt;=n;i++)
                {
                    for(int j=0;j&amp;lt;=i;j++)
                        ans[i]+=ans[j]*ans[i-j-1];
                   }
            return ans[n];
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given n = 3, there are a total of 5 unique BST’s.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-137-Single Number II</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-137-Single-Number-II/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-137-Single-Number-II/</id>
    <published>2016-05-26T10:25:53.000Z</published>
    <updated>2016-05-26T10:34:31.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;一个数组中每个元素都出现了3次除了一个只出现了一次，找到这个元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用2个哈希表，第一次出现就放入第一个，第二次出现把第一个表里删除再插入第二个表，第三次出现把第二个表里删除。这样那个单独元素就会在第一个哈希表里。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            set&amp;lt;int&amp;gt; first;
            set&amp;lt;int&amp;gt; second;
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                    if(second.find(nums[i])!=second.end()){
                        second.erase(nums[i]);
                    }else
                        {
                            if(first.find(nums[i])!=first.end())
                                    {
                                    first.erase(nums[i]);
                                    second.insert(nums[i]);
                                }else first.insert(nums[i]);
                        }
                }
            return *first.begin();

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-230-Kth Smallest Element in a BST</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-230-Kth-Smallest-Element-in-a-BST/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-230-Kth-Smallest-Element-in-a-BST/</id>
    <published>2016-05-26T10:21:30.000Z</published>
    <updated>2016-05-26T11:32:55.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;Try to utilize the property of a BST.&lt;br&gt;What if you could modify the BST node’s structure?&lt;br&gt;The optimal runtime complexity is O(height of BST).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个BST,找出第K小的元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先遍历一次，按顺序存下来，再返回特定坐标即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int kthSmallest(TreeNode* root, int k) {
            stack&amp;lt;TreeNode*&amp;gt; st;
            vector&amp;lt;int&amp;gt; ans;
            while(!st.empty()||root)
                {
                    while(root)
                        {
                            st.push(root);
                            root=root-&amp;gt;left;
                        }
            TreeNode* tem=st.top();
            ans.push_back(tem-&amp;gt;val);
            st.pop();
            if(tem-&amp;gt;right)
                root=tem-&amp;gt;right;

                    }
            return ans[k-1];

    }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;Try to utilize the property of a BST.&lt;br&gt;What if you could modify the BST node’s structure?&lt;br&gt;The optimal runtime complexity is O(height of BST).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-328-Odd Even Linked List</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-328-Odd-Even-Linked-List/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-328-Odd-Even-Linked-List/</id>
    <published>2016-05-26T09:39:52.000Z</published>
    <updated>2016-05-26T10:15:59.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL,&lt;br&gt;return 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;The first node is considered odd, the second node even and so on …&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个单向链表，返回所有奇数结点，再接上所有偶数结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先分别构建两个子串，再连起来。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* oddEvenList(ListNode* head) {
            if(!head||!head-&amp;gt;next) return head;
            ListNode* odd=head;
            ListNode* eve=head-&amp;gt;next;
            ListNode* tem=eve;
            while(odd-&amp;gt;next&amp;amp;&amp;amp;eve-&amp;gt;next)
                {
                    odd-&amp;gt;next=eve-&amp;gt;next;
                    eve-&amp;gt;next=odd-&amp;gt;next-&amp;gt;next;
                    if(odd-&amp;gt;next)
                        odd=odd-&amp;gt;next;
                    if(eve-&amp;gt;next)
                        eve=eve-&amp;gt;next;
                }
            odd-&amp;gt;next=tem;
            eve-&amp;gt;next=NULL;
            return head;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;
&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL,&lt;br&gt;return 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The relative order inside both the even and odd groups should remain as it was in the input.&lt;br&gt;The first node is considered odd, the second node even and so on …&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-287-Find the Duplicate Number</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-287-Find-the-Duplicate-Number/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-287-Find-the-Duplicate-Number/</id>
    <published>2016-05-26T09:32:33.000Z</published>
    <updated>2016-05-26T09:38:10.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must not modify the array (assume the array is read only).&lt;br&gt;You must use only constant, O(1) extra space.&lt;br&gt;Your runtime complexity should be less than O(n2).&lt;br&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;有一个大小为n+1的数组，数字均在1-n之间，证明一定至少有一个重复的数字，假设只有一个重复数字，找到它。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题有许多种解法。如果数组不能被改动，则可以利用二分查找，统计不大于mid的数个数，如果超过mid个，则这个重复的数字一定在1-mid之间，否则在mid-n之间。&lt;br&gt;如果数组可以被改动，可以使用循环标记的算法，把每个数字的值作为下标，标负，当发现标负的值的时候，该值即为重复值。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int findDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int begin=1,end=nums.size()-1;
            int mid= begin+(end-begin)/2;
            while(end-begin&amp;gt;0)
                {
                    if(helper(nums,mid))
                        {
                            end=mid;
                            mid=begin+(end-begin)/2;
                        }else
                            {
                                begin=mid+1;
                                mid=begin+(end-begin)/2;
                            }
                }
            return begin;

        }
        bool helper(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target)
            {
                int count = 0;
                    for(int i=0;i&amp;lt;nums.size();i++)
                    if(nums[i]&amp;lt;=target) count++;
                        return count&amp;gt;target;
            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must not modify the array (assume the array is read only).&lt;br&gt;You must use only constant, O(1) extra space.&lt;br&gt;Your runtime complexity should be less than O(n2).&lt;br&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Hard" scheme="http://yoursite.com/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-12-Integer to Roman</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-12-Integer-to-Roman/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-12-Integer-to-Roman/</id>
    <published>2016-05-26T09:27:41.000Z</published>
    <updated>2016-05-26T09:29:52.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, convert it to a roman numeral.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;把十进制数字转化为罗马数字。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先找到不同的转化点，再依次转化&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        string intToRoman(int num) {
            string res=&amp;quot;&amp;quot;;
            int nums[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};
            string s[13]={&amp;quot;M&amp;quot;,&amp;quot;CM&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;CD&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;XC&amp;quot;,&amp;quot;L&amp;quot;,&amp;quot;XL&amp;quot;,&amp;quot;X&amp;quot;,&amp;quot;IX&amp;quot;,&amp;quot;V&amp;quot;,&amp;quot;IV&amp;quot;,&amp;quot;I&amp;quot;};
            for(int i=0;i&amp;lt;=13;i++)
                {
                    if(num&amp;gt;=nums[i])
                        {
                            for(int j=0;j&amp;lt;num/nums[i];j++)
                                res+=s[i];
                                num%=nums[i];
                        }
                }
            return res;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer, convert it to a roman numeral.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-13-Roman to Integer</title>
    <link href="http://yoursite.com/2016/05/26/Leetcode-13-Roman-to-Integer/"/>
    <id>http://yoursite.com/2016/05/26/Leetcode-13-Roman-to-Integer/</id>
    <published>2016-05-26T08:12:59.000Z</published>
    <updated>2016-05-26T08:19:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个罗马数字，1-3999内，求对应的十进制数字&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单，如果左边的比右边的小，说明左边的需要减去，右边的比左边的小或者相等就累加&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int romanToInt(string s) {
            if(s.length()==0) return 0;
            if(s.length()==1) return letter2int(s[0]);
            int res=letter2int(s[0]);
            for(int i=1;i&amp;lt;s.length();i++)
                {
                    if(letter2int(s[i])&amp;gt;letter2int(s[i-1]))
                        res+=letter2int(s[i])-2*letter2int(s[i-1]);
                    else res+=letter2int(s[i]);
                }
            return res;

        }
        int letter2int(char a)
            {
                switch(a)
                    {
                        case &amp;apos;I&amp;apos;: return 1;
                        case &amp;apos;V&amp;apos;: return 5;
                        case &amp;apos;X&amp;apos;: return 10;
                        case &amp;apos;L&amp;apos;: return 50;
                        case &amp;apos;C&amp;apos;: return 100;
                        case &amp;apos;D&amp;apos;: return 500;
                        case &amp;apos;M&amp;apos;: return 1000;
                        default : return 0;
                    }
            }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
</feed>
