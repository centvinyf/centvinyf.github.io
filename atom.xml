<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-23T14:22:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-268-Missing Number</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-268-Missing-Number/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-268-Missing-Number/</id>
    <published>2016-05-23T14:17:51.000Z</published>
    <updated>2016-05-23T14:22:25.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给你一个n个互异整数组成的数组，其中少掉了一个数字，求这个数字。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题有很多解法。对于O(n)的解法，可以求出和，再减去每个数字。对于位运算来说就是求所有的异或再与完整数组异或一次。本文给出数学的解法。&lt;br&gt;如果是排好序的数组，可以利用二分查找进而把复杂度降低到O（lgn）&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int n=nums.size();
            int res=n*(n+1)/2;
            for(int i=0;i&amp;lt;n;i++)
            res-=nums[i];

                return res;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given nums = [0, 1, 3] return 2.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-343-Integer Break</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-343-Integer-Break/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-343-Integer-Break/</id>
    <published>2016-05-23T13:55:31.000Z</published>
    <updated>2016-05-23T14:01:49.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.&lt;/p&gt;
&lt;p&gt;For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).&lt;/p&gt;
&lt;p&gt;Note: you may assume that n is not less than 2.&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;There is a simple O(n) solution to this problem.&lt;br&gt;You may check the breaking results of n ranging from 7 to 10 to discover the regularities.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个正整数，把它拆分成至少2个正整数的和，然后求这些正整数的乘积的最大值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;通过动态规划可以很简单的得出状态转移方程，当n为4以下的时候，只能拆分为1和n-1，4以上时，拆分为2，n-2或者3，n-3时，能够获得最大乘积。（其实这个稍微感觉一下，就是幂函数的增长速度是最快的一样）&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int integerBreak(int n) {
            vector&amp;lt;int&amp;gt; dp(n+1);
            if(n&amp;lt;4) return n-1;
            dp[2]=2;
            dp[3]=3;
            for(int i=4;i&amp;lt;=n;i++)
                dp[i]=max(dp[i-2]*2,dp[i-3]*3);

            return dp[n];
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.&lt;/p&gt;
&lt;p&gt;For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).&lt;/p&gt;
&lt;p&gt;Note: you may assume that n is not less than 2.&lt;/p&gt;
&lt;p&gt;Hint:&lt;/p&gt;
&lt;p&gt;There is a simple O(n) solution to this problem.&lt;br&gt;You may check the breaking results of n ranging from 7 to 10 to discover the regularities.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-319-Bulb Switcher</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-319-Bulb-Switcher/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-319-Bulb-Switcher/</id>
    <published>2016-05-23T13:33:27.000Z</published>
    <updated>2016-05-23T13:53:03.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given n = 3. 

At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 

So you should return 1, because there is only one bulb is on.
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;有n个开关，第i次操作你拨动所有i整数倍序号的开关。问最后有几盏灯留下了。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;任何一个开关都会被拨动偶数次，除非它是一个完全平方数，本题目即是求不大于n的完全平方数有几个&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int bulbSwitch(int n) {
               return sqrt(n);

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Given n = 3. 

At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 

So you should return 1, because there is only one bulb is on.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-169-Majority Element</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-169-Majority-Element/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-169-Majority-Element/</id>
    <published>2016-05-23T13:30:40.000Z</published>
    <updated>2016-05-23T13:32:30.000Z</updated>
    
    <content type="html">&lt;p&gt;Problem Description:&lt;br&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;h2 id=&quot;You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot;&gt;&lt;a href=&quot;#You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot; class=&quot;headerlink&quot; title=&quot;You may assume that the array is non-empty and the majority element always exist in the array.&quot;&gt;&lt;/a&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/h2&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给一个数组，里面有一个元素出现了至少⌊ n/2 ⌋次，找到这个元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;排序以后中间的那个元素肯定是所求元素。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            sort(nums.begin(),nums.end());
            return nums[nums.size()/2];
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Problem Description:&lt;br&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;h2 id=&quot;You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot;&gt;&lt;a href=&quot;#You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array&quot; class=&quot;headerlink&quot; title=&quot;You may assume that the array is non-empty and the majority element always exist in the array.&quot;&gt;&lt;/a&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/h2&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-217-Contains Duplicate</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-217-Contains-Duplicate/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-217-Contains-Duplicate/</id>
    <published>2016-05-23T10:19:21.000Z</published>
    <updated>2016-05-23T10:22:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，找出其是否包含重复元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的利用一个哈希表存储所有未重复数字，当发现重复数字即可返回true,否则返回false&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            set&amp;lt;int&amp;gt; s;
            for(int i=0;i&amp;lt;nums.size();i++){
                if(s.find(nums[i])!=s.end()) return true;
                else s.insert(nums[i]);
            }
            return false;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-171-Excel Sheet Column Number</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-171-Excel-Sheet-Column-Number/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-171-Excel-Sheet-Column-Number/</id>
    <published>2016-05-23T10:16:28.000Z</published>
    <updated>2016-05-23T10:18:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;Given a column title as appear in an Excel sheet, return its corresponding column number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A -&amp;gt; 1
B -&amp;gt; 2
C -&amp;gt; 3
...
Z -&amp;gt; 26
AA -&amp;gt; 27
AB -&amp;gt; 28 
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的26进制转化问题。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int titleToNumber(string s) {
            int res=0;
            int high=s.length()-1;
            for(int i=0;i&amp;lt;s.length();i++)
                res+=pow(26,high-i)*(s[i]-&amp;apos;A&amp;apos;+1);

            return res;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-242-Valid Anagram</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-242-Valid-Anagram/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-242-Valid-Anagram/</id>
    <published>2016-05-23T10:11:12.000Z</published>
    <updated>2016-05-23T10:15:33.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;s = “anagram”, t = “nagaram”, return true.&lt;br&gt;s = “rat”, t = “car”, return false.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume the string contains only lowercase alphabets.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个字符串，判定它们是否是异构体（即包含相同的字符）&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用哈希表，把字符串放入数组中排序，如果是异构体则排序后结果应该相同。或者利用两个向量变量统计每个字母出现的次数，看是否相同。本文给出第一种解法，第二种请读者自己完成。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool isAnagram(string s, string t) {
            if(s.length()!=t.length()) return false;
            vector&amp;lt;char&amp;gt;a;
            vector&amp;lt;char&amp;gt;b;
            for(int i=0;i&amp;lt;s.length();i++)
                {
                    a.push_back(s[i]);
                    b.push_back(t[i]);
                }
            sort(a.begin(),a.end());
            sort(b.begin(),b.end());
            for(int i =0;i&amp;lt;a.size();i++)
                if(a[i]!=b[i]) return false;
            return true;


            return true;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;s = “anagram”, t = “nagaram”, return true.&lt;br&gt;s = “rat”, t = “car”, return false.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume the string contains only lowercase alphabets.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-122-Best Time to Buy and Sell Stock II</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2016-05-23T10:07:30.000Z</published>
    <updated>2016-05-23T10:10:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;你有一个数组表示某只股票每天的市值，设计一个算法求出你过了这些天之后能够赚到的最大利润（再次买入之前必须售出）&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用贪心算法，只要是任何两天之内有的价值增加都能被加入总收益之中。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {
            int max=0;
            for(int i=1;i&amp;lt;prices.size();i++)
                prices[i]-prices[i-1]&amp;gt;0?max+=prices[i]-prices[i-1]:max+=0;
            return max;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-238-Product of Array Except Self</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-238-Product-of-Array-Except-Self/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-238-Product-of-Array-Except-Self/</id>
    <published>2016-05-23T10:02:07.000Z</published>
    <updated>2016-05-23T10:06:49.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;Solve it without division and in O(n).&lt;/p&gt;
&lt;p&gt;For example, given [1,2,3,4], return [24,12,8,6].&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，输出为其他数组中所有其他元素的乘积，不能使用除法，时间复杂度应为O(n)&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;使用动态规划，遍历2次数组，求出左边所有元素的乘积和右边所有元素的乘积，再把它们相乘即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; productExceptSelf(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            vector&amp;lt;int&amp;gt; res;
            if(nums.empty()) return res;
               vector&amp;lt;int&amp;gt; productleft(nums.size(),1);
            vector&amp;lt;int&amp;gt; productright(nums.size(),1);
            for(int i =1;i&amp;lt;nums.size();i++)
                   productleft[i]=productleft[i-1]*nums[i-1];
            for(int j=nums.size()-2;j&amp;gt;=0;j--)
                productright[j]=productright[j+1]*nums[j+1];
            for(int i =0;i&amp;lt;nums.size();i++)
                res.push_back(productleft[i]*productright[i]);
            return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of n integers where n &amp;gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].&lt;/p&gt;
&lt;p&gt;Solve it without division and in O(n).&lt;/p&gt;
&lt;p&gt;For example, given [1,2,3,4], return [24,12,8,6].&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-100-Same Tree</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-100-Same-Tree/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-100-Same-Tree/</id>
    <published>2016-05-23T09:45:16.000Z</published>
    <updated>2016-05-23T10:00:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary trees, write a function to check if they are equal or not.&lt;/p&gt;
&lt;p&gt;Two binary trees are considered equal if they are structurally identical and the nodes have the same value.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个二叉树，写一个函数来检查它们是否相同。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用函数，检查左右子树以及根节点的值是否相同。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        bool isSameTree(TreeNode* p, TreeNode* q) {
            if(!p&amp;amp;&amp;amp;!q) return true;
            if((p&amp;amp;&amp;amp;!q)||(!p&amp;amp;&amp;amp;q)) return false;
            return (p-&amp;gt;val==q-&amp;gt;val)&amp;amp;&amp;amp;isSameTree(p-&amp;gt;left,q-&amp;gt;left)&amp;amp;&amp;amp;isSameTree(p-&amp;gt;right,q-&amp;gt;right);

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary trees, write a function to check if they are equal or not.&lt;/p&gt;
&lt;p&gt;Two binary trees are considered equal if they are structurally identical and the nodes have the same value.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-237-Delete Node in a Linked List</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-237-Delete-Node-in-a-Linked-List/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-237-Delete-Node-in-a-Linked-List/</id>
    <published>2016-05-23T09:42:16.000Z</published>
    <updated>2016-05-23T09:44:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;删除一个链表中的结点，你只能获取该结点的指针。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;有点像脑筋急转弯。很简单，将这个结点的next结点拷贝到这个结点就可以了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        void deleteNode(ListNode* node) {
            node-&amp;gt;val=node-&amp;gt;next-&amp;gt;val;
            node-&amp;gt;next=node-&amp;gt;next-&amp;gt;next;
        }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-260-Single Number III</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-260-Single-Number-III/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-260-Single-Number-III/</id>
    <published>2016-05-23T09:33:28.000Z</published>
    <updated>2016-05-23T09:41:27.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The order of the result is not important. So in the above example, [5, 3] is also correct.&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，其中有两个元素只出现了一次，其他的元素出现了2次，找出这两个只出现过一次的元素。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;第一步与&lt;a href=&quot;/2016/05/23/Leetcode-136-Single-Number/&quot;&gt;simgle number I&lt;/a&gt; 一样，先求出所有的数字的^结果，此时假设这两个数是a和b,那么我们已经得到了a^b的结果。那么我们如何将这两个数分开呢。^运算的结果是同位相等为0，不等为1.那么我们就可以找出a和b不相等的最低位，然后把原数组分成两个子数组，接着使用我们&lt;a href=&quot;/2016/05/23/Leetcode-136-Single-Number/&quot;&gt;simgle number I&lt;/a&gt; 中使用的方法即可求解两个数。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        vector&amp;lt;int&amp;gt; singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int tem = 0;
            for(int i=0;i&amp;lt;nums.size();i++)
                tem^=nums[i];
            int last = tem-(tem&amp;amp;(tem-1));//求出tem中最低“1”位
            int first = 0; int second = 0;
            for(int i=0;i&amp;lt;nums.size();i++)
                {
                    if(nums[i]&amp;amp;last)
                        first^=nums[i];
                    else
                        second^=nums[i];
                }
            vector&amp;lt;int&amp;gt; ans;
            ans.push_back(first);
            ans.push_back(second);
            return ans;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;The order of the result is not important. So in the above example, [5, 3] is also correct.&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-283-Move Zeroes</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-283-Move-Zeroes/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-283-Move-Zeroes/</id>
    <published>2016-05-23T09:27:42.000Z</published>
    <updated>2016-05-23T13:32:41.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must do this in-place without making a copy of the array.&lt;br&gt;Minimize the total number of operations.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，写一个函数把所有的0都移动到数组的末端且非0元素的相对位置不变。&lt;br&gt;你没有额外的存储空间来复制一遍数组。且使移动操作次数最少。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用一个指针指向第一个0的坐标，如果不是0，则交换0坐标上的数字与当前数字&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int mark = 0;
            for(int i =0;i&amp;lt;nums.size();i++)
                {
                    if(nums[i]!=0)
                           swap(nums[i],nums[mark++]);     
                }

            }
        };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You must do this in-place without making a copy of the array.&lt;br&gt;Minimize the total number of operations.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-349-Intersection of Two Arrays</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/</id>
    <published>2016-05-23T09:19:50.000Z</published>
    <updated>2016-05-23T09:24:17.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result must be unique.&lt;br&gt;The result can be in any order.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;找到两个集合的交集，并且注意交集中每个元素只能出现一次。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的hash map的题，遍历a中每一个元素，只要在b中出现的，如果没有添加过，则添加到结果集合中。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; intersection(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) {
        vector&amp;lt;int&amp;gt; res;
        if(!nums1.empty()||!nums2.empty())
            for(int i=0;i&amp;lt;nums1.size();i++)
                {
                    if(find(nums2.begin(),nums2.end(),nums1[i])!=nums2.end())//if nums1[i] is in nums2
                        if(find(res.begin(),res.end(),nums1[i])==res.end())// if nums[i] not in res
                            res.push_back(nums1[i]);
                }
            return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Each element in the result must be unique.&lt;br&gt;The result can be in any order.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-226-Invert Binay Tree</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-226-Invert-Binay-Tree/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-226-Invert-Binay-Tree/</id>
    <published>2016-05-23T09:04:15.000Z</published>
    <updated>2016-05-23T13:32:45.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Invert a binary tree.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     4
   /   \
  2     7
 / \   / \
1   3 6   9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      4
    /   \
  7     2
 / \   / \
9   6 3   1
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;        
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个二叉树&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用函数本身即可，注意边界条件。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
           TreeNode* invertTree(TreeNode* root) {
            if(!root) return root;
            if(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right) return root;
            else{
                TreeNode* teml = invertTree(root-&amp;gt;right);
                TreeNode* temr = invertTree(root-&amp;gt;left);
                root-&amp;gt;left= teml;
                root-&amp;gt;right=temr;
                return root;
                    }

            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Invert a binary tree.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     4
   /   \
  2     7
 / \   / \
1   3 6   9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      4
    /   \
  7     2
 / \   / \
9   6 3   1
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Mark" scheme="http://yoursite.com/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-104-Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/</id>
    <published>2016-05-23T09:00:29.000Z</published>
    <updated>2016-05-23T09:17:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its maximum depth.&lt;/p&gt;
&lt;p&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个二叉树，返回它的最大深度&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用本函数，返回左右子树的最大深度中较大值+1即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int maxDepth(TreeNode* root) {
            if(!root) return 0;
            else
                return max(maxDepth(root-&amp;gt;left),maxDepth(root-&amp;gt;right))+1;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, find its maximum depth.&lt;/p&gt;
&lt;p&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-258-Add Digits</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-258-Add-Digits/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-258-Add-Digits/</id>
    <published>2016-05-23T08:51:32.000Z</published>
    <updated>2016-05-23T09:15:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个非负整数，重复累加它的每一位，直到生成的新数字只有一位。&lt;br&gt;例如：38-》3+8=11-》1+1=2.此时返回2.&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这里提供两种方法，第一种是正常的循环解题思路，另一种是数学的方法。数学方法请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_root&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇wiki文章&lt;/a&gt;.循环解法只需要按照题目要求累加每一位数字即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int addDigits(int num) {
            switch(num)
                {
                    case 0: return 0;
                    default: return (num-1)%9+1;
                }
            }
    };
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-136-Single Number</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-136-Single-Number/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-136-Single-Number/</id>
    <published>2016-05-23T08:47:34.000Z</published>
    <updated>2016-05-23T09:15:18.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears twice except for one. Find that single one.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，其中除了某一个数字以外其他数字都出现过两次，找出这个数字。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题方法有许多，这里本文介绍最简单的一种，使用位运算，一个数字a^b^b以后仍然为它本身。这样，把整个数组^一次即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
            int res=0;
            for(int i=0;i&amp;lt;nums.size();i++)
                res^=nums[i];

            return res;

        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, every element appears twice except for one. Find that single one.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Medium" scheme="http://yoursite.com/tags/Medium/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-292-Nim Game</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-292-Nim-Game/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-292-Nim-Game/</id>
    <published>2016-05-23T08:40:44.000Z</published>
    <updated>2016-05-23T09:16:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;
&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;
&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;你和朋友玩一个取石子的游戏，每一个人可以取1-3个石子，假如你们俩都能每一步做出最优选择，那么当你先取的时候，输入一个石子数，返回你是否能取得胜利。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题仔细分析其实并不难。当石子数为4的整数倍的时候，总是后手胜利，因为不管先手拿走了n(1-3)枚石子，你总是拿走4-n枚，即可获胜，其他情况下，先手可以把自己变为后手，即取走余数。所以想通了这一点之后这道题变得非常简单。即判断先手是否胜利的条件在于石子数能否被4整除。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        bool canWinNim(int n) {
            return n%4;
        }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;
&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;
&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-191-Number of 1 Bits</title>
    <link href="http://yoursite.com/2016/05/23/Leetcode-191-Number-of-1-Bits/"/>
    <id>http://yoursite.com/2016/05/23/Leetcode-191-Number-of-1-Bits/</id>
    <published>2016-05-23T08:06:57.000Z</published>
    <updated>2016-05-23T09:17:11.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).&lt;/p&gt;
&lt;p&gt;For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;写一个函数，返回某一数字二进制表示中1出现的次数&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用位运算中&amp;amp;操作符号，和指定数的每一位都单独&amp;amp;一次，如果是1，则会返回1，再使用一个计数器实现统计。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
    public:
        int hammingWeight(uint32_t n) {
            int count=0;
            for(int i=0;i&amp;lt;32;i++)
                if(n&amp;amp;1&amp;lt;&amp;lt;i) count++;

            return count;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).&lt;/p&gt;
&lt;p&gt;For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://yoursite.com/tags/Easy/"/>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
  </entry>
  
</feed>
