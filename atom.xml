<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://since1992.org/"/>
  <updated>2016-06-27T14:54:40.000Z</updated>
  <id>http://since1992.org/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-303-Range Sum Query- Immutable</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-303-Range-Sum-Query-Immutable/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-303-Range-Sum-Query-Immutable/</id>
    <published>2016-06-27T14:52:18.000Z</published>
    <updated>2016-06-27T14:54:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example:
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:&lt;br&gt;You may assume that the array does not change.&lt;br&gt;There are many calls to sumRange function.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，多次查询从i到j的和，实现它。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用一个数组存储从头到I的总和。那么i-j的和用从头到j和减去从头到i-1的和，即为所求。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class NumArray {
public:
    vector&amp;lt;int&amp;gt; dp;

    NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
     dp.resize(nums.size());
     if(!nums.empty()){
     dp[0]=nums[0];
     for(int i=1;i&amp;lt;nums.size();i++)
     dp[i]=dp[i-1]+nums[i];
     }
    }

    int sumRange(int i, int j) {
        return i==0?dp[j]:dp[j]-dp[i-1];
    }
};


// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
// numArray.sumRange(1, 2);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example:
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:&lt;br&gt;You may assume that the array does not change.&lt;br&gt;There are many calls to sumRange function.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Dynamic Programming" scheme="http://since1992.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-28-Implement strStr()</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-28-Implement-strStr/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-28-Implement-strStr/</id>
    <published>2016-06-27T14:37:57.000Z</published>
    <updated>2016-06-27T14:39:20.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;返回字符串中某子串的出现的第一个序列号。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;维护一个长度和子串相等的滑动窗口，比较它是否和子串相等即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.length()&amp;gt;haystack.size()) return -1;
        if(needle==&amp;quot;&amp;quot;) return 0;
        for(int i = 0 ; i &amp;lt;haystack.length();i++)
        {
            string win= haystack.substr(i,needle.size());
            if(win==needle) return i;
        }
        return -1;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-67-Add Binary</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-67-Add-Binary/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-67-Add-Binary/</id>
    <published>2016-06-27T14:30:12.000Z</published>
    <updated>2016-06-27T14:32:56.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary strings, return their sum (also a binary string).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个二进制数，求他们的和。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的字符串操作，注意进位和最后加完了还有进位的情况。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string addBinary(string a, string b) {
        string res=&amp;quot;&amp;quot;;
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0 ;
        if(i&amp;gt;j)
        {
            for(int x =0;x&amp;lt;i-j; x++)
            b=&amp;apos;0&amp;apos;+b;
        }else{
            for(int x =0 ;x&amp;lt;j-i;x++)
            a=&amp;apos;0&amp;apos;+a;
        }
        int len = a.length()-1;
        int cur;
        while(len&amp;gt;=0){
            cur = (a[len]-&amp;apos;0&amp;apos;)+(b[len]-&amp;apos;0&amp;apos;)+carry;
            carry=cur/2;
            cur%=2;
            res= (char)(cur+&amp;apos;0&amp;apos;) + res;
            len--;
        }
       if(carry==1) res= to_string(1)+res;
        return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary strings, return their sum (also a binary string).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-14-LongestCommon Prefix</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-14-LongestCommon-Prefix/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-14-LongestCommon-Prefix/</id>
    <published>2016-06-27T12:18:54.000Z</published>
    <updated>2016-06-27T12:20:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;找出一组字符串的最长前缀。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;从前往后依次搜索即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) {
        if(strs.empty()) return &amp;quot;&amp;quot;;
        string prefix = &amp;quot;&amp;quot;;
        for(int i = 0;i &amp;lt; strs[0].length(); i++)
        {
            char cur = strs[0][i];
            for(int j =  0 ;j &amp;lt; strs.size();j++){
            if(strs[j][i]==cur) {
                if(j==strs.size()-1) prefix+=cur;
            }else return prefix;
            }
        }
        return prefix;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-234-Palindrome Linked List</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-234-Palindrome-Linked-List/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-234-Palindrome-Linked-List/</id>
    <published>2016-06-27T11:52:06.000Z</published>
    <updated>2016-06-27T11:54:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do it in O(n) time and O(1) space?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;判断一个单向链表是否是回文的。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;存下来每一个结点的值，判断是否是对称的即可。至于follow up,可以考虑反转后半个链表，然后挨个比对是否和前半部分相等即可。本文只给出第一种解法。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector&amp;lt;int&amp;gt; v;
        while(head)
        {
            v.push_back(head-&amp;gt;val);
            head=head-&amp;gt;next;
        }
        for(int i = 0;i&amp;lt; v.size()/2 ; i++)
        if(v[i]!=v[v.size()-1-i]) return false;
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do it in O(n) time and O(1) space?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-203-Remove Linked List Elements</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-203-Remove-Linked-List-Elements/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-203-Remove-Linked-List-Elements/</id>
    <published>2016-06-27T10:24:58.000Z</published>
    <updated>2016-06-27T10:26:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;/p&gt;
&lt;p&gt;Example&lt;br&gt;    Given: 1 –&amp;gt; 2 –&amp;gt; 6 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5 –&amp;gt; 6, val = 6&lt;br&gt;    Return: 1 –&amp;gt; 2 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;去掉单向链表中所有值与给定值相等的结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;保存之前的结点，然后扫描每个节点即可。注意头结点是否会被去掉的问题。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(!head) return head;
        ListNode * prev = head;
        ListNode * cur = prev-&amp;gt;next;
        while(prev-&amp;gt;next)
        {
            if(cur-&amp;gt;val == val){
                prev-&amp;gt;next =  cur-&amp;gt;next;
                cur=prev-&amp;gt;next;
            }else{
                prev= cur;
                cur = prev-&amp;gt;next;
            }
        }
       if(head-&amp;gt;val == val) return head-&amp;gt;next;
       return head;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;/p&gt;
&lt;p&gt;Example&lt;br&gt;    Given: 1 –&amp;gt; 2 –&amp;gt; 6 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5 –&amp;gt; 6, val = 6&lt;br&gt;    Return: 1 –&amp;gt; 2 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-190-Reverse Bits</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-190-Reverse-Bits/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-190-Reverse-Bits/</id>
    <published>2016-06-27T10:13:40.000Z</published>
    <updated>2016-06-27T10:15:23.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个32位整数（原来是0,1,2,3,…32, 变成 32,31,30…,1）&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的位运算操作。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0 ;
        int mask = 1 ;
        for(int i = 0 ; i &amp;lt;  32 ; i ++)
        {
            if( n &amp;amp; mask ) res += 1 ;
            if(i &amp;lt; 31)res &amp;lt;&amp;lt;=  1 ;
            mask &amp;lt;&amp;lt;= 1;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Bit Manipulation" scheme="http://since1992.org/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-257-Binary Tree Paths</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-257-Binary-Tree-Paths/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-257-Binary-Tree-Paths/</id>
    <published>2016-06-27T09:55:50.000Z</published>
    <updated>2016-06-27T09:57:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return all root-to-leaf paths.&lt;/p&gt;
&lt;p&gt;For example, given the following binary tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
 /   \
2     3
 \
  5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All root-to-leaf paths are:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回所有的从根结点到叶子节点的路径。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用深度优先搜索，每当走到叶子节点便返回路径。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;string&amp;gt; binaryTreePaths(TreeNode* root) {
        vector&amp;lt;string&amp;gt; res;
        if(root)
            dfs(root,res,&amp;quot;&amp;quot;);
        return res;
    }
    void dfs(TreeNode* root, vector&amp;lt;string&amp;gt; &amp;amp;res, string path){
        path+=to_string(root-&amp;gt;val);
        if(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right)
            res.push_back(path);
        else {
            if(root-&amp;gt;left)
                dfs(root-&amp;gt;left,res,path+&amp;quot;-&amp;gt;&amp;quot;);
            if(root-&amp;gt;right)
                dfs(root-&amp;gt;right,res,path+&amp;quot;-&amp;gt;&amp;quot;);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return all root-to-leaf paths.&lt;/p&gt;
&lt;p&gt;For example, given the following binary tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
 /   \
2     3
 \
  5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All root-to-leaf paths are:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
      <category term="Mark" scheme="http://since1992.org/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-58-Length of Last Word</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-58-Length-of-Last-Word/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-58-Length-of-Last-Word/</id>
    <published>2016-06-27T09:08:01.000Z</published>
    <updated>2016-06-27T09:09:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.&lt;/p&gt;
&lt;p&gt;If the last word does not exist, return 0.&lt;/p&gt;
&lt;p&gt;Note: A word is defined as a character sequence consists of non-space characters only.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given s = “Hello World”,&lt;br&gt;return 5.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;返回一个字符串中最后一个单词的长度。如果不存在，则返回0&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先去掉尾部空格再计算最后一个单词长度即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int lengthOfLastWord(string s) {
        if(s==&amp;quot;&amp;quot;) return 0;
        int i = s.length()-1;
        int count = 0;
        while(i&amp;gt;=0){
            if(count==0&amp;amp;&amp;amp;s[i]==&amp;apos; &amp;apos;) i--;
            else if(s[i]!=&amp;apos; &amp;apos;){
                i--;count++;
            }else if(count&amp;gt;0&amp;amp;&amp;amp;s[i]==&amp;apos; &amp;apos;) break;

        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.&lt;/p&gt;
&lt;p&gt;If the last word does not exist, return 0.&lt;/p&gt;
&lt;p&gt;Note: A word is defined as a character sequence consists of non-space characters only.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given s = “Hello World”,&lt;br&gt;return 5.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-38-Count and Sway</title>
    <link href="http://since1992.org/2016/06/26/Leetcode-38-Count-and-Say/"/>
    <id>http://since1992.org/2016/06/26/Leetcode-38-Count-and-Say/</id>
    <published>2016-06-26T09:09:00.000Z</published>
    <updated>2016-06-26T09:11:55.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers beginning as follows:&lt;br&gt;1, 11, 21, 1211, 111221, …&lt;/p&gt;
&lt;p&gt;1 is read off as “one 1” or 11.&lt;br&gt;11 is read off as “two 1s” or 21.&lt;br&gt;21 is read off as “one 2, then one 1” or 1211.&lt;br&gt;Given an integer n, generate the nth sequence.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;边数边说出上一次的结果。 1读作 “1 1”，11读作“ 2 1”，21读作“1 2 1 1”&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用该函数，利用上一次的计算结果来读数即可。注意：数字转化成字符串的时候不可以直接 +’0’,因为有可能会是超过一位数。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string countAndSay(int n) {
        if(n==0) return &amp;quot;&amp;quot;;
        if(n==1) return &amp;quot;1&amp;quot;;
        string res=&amp;quot;&amp;quot;;
        string prev = countAndSay(n-1);
        int count = 1;
        char cur=prev[0];
        for(int i = 1 ; i &amp;lt; prev.length(); i++)
        {
            if(prev[i]==cur) count++;
            else
            {
                res+=i2s(count);
                res+=cur;
                count = 1;
                cur=prev[i];
            }
        }
        res+=i2s(count);
        res+=cur;
        return res;

    }
    string i2s(int n)
    {
        string res = &amp;quot;&amp;quot;;
        while(n&amp;gt;0){
            res+=(char)(n%10+&amp;apos;0&amp;apos;);
            n/=10;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers beginning as follows:&lt;br&gt;1, 11, 21, 1211, 111221, …&lt;/p&gt;
&lt;p&gt;1 is read off as “one 1” or 11.&lt;br&gt;11 is read off as “two 1s” or 21.&lt;br&gt;21 is read off as “one 2, then one 1” or 1211.&lt;br&gt;Given an integer n, generate the nth sequence.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-20-Valid Parentheses</title>
    <link href="http://since1992.org/2016/06/26/Leetcode-20-Valid-Parentheses/"/>
    <id>http://since1992.org/2016/06/26/Leetcode-20-Valid-Parentheses/</id>
    <published>2016-06-26T08:35:11.000Z</published>
    <updated>2016-06-26T08:36:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个字符串，判断它是否是一个合法的括号组。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;经典的栈匹配的问题。仔细即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isValid(string s) {
        stack&amp;lt;char&amp;gt;st;
        for(int i = 0; i &amp;lt; s.length(); i ++)
        {
            switch(s[i]){
                case &amp;apos;(&amp;apos;:
                case &amp;apos;[&amp;apos;:
                case &amp;apos;{&amp;apos;: st.push(s[i]);break;
                case &amp;apos;)&amp;apos;: 
                    if(st.empty()) return false;
                    if(st.top()!=&amp;apos;(&amp;apos;) return false;
                    else st.pop();
                    break;
                case &amp;apos;}&amp;apos;:
                    if(st.empty()) return false;
                    if(st.top()!=&amp;apos;{&amp;apos;) return false;
                    else st.pop();
                    break;
                case &amp;apos;]&amp;apos;:
                    if(st.empty()) return false;
                    if(st.top()!=&amp;apos;[&amp;apos;) return false;
                    else st.pop();
                    break;
                default: continue;
            }
        }
        return st.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-290-Word Pattern</title>
    <link href="http://since1992.org/2016/06/26/Leetcode-290-Word-Pattern/"/>
    <id>http://since1992.org/2016/06/26/Leetcode-290-Word-Pattern/</id>
    <published>2016-06-26T08:11:29.000Z</published>
    <updated>2016-06-26T08:36:43.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a pattern and a string str, find if str follows the same pattern.&lt;/p&gt;
&lt;p&gt;Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;pattern = “abba”, str = “dog cat cat dog” should return true.&lt;br&gt;pattern = “abba”, str = “dog cat cat fish” should return false.&lt;br&gt;pattern = “aaaa”, str = “dog cat cat dog” should return false.&lt;br&gt;pattern = “abba”, str = “dog dog dog dog” should return false.&lt;br&gt;Notes:&lt;br&gt;You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个模式和一个字符串，判定字符串是否和模式相匹配。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本体和&lt;a href=&quot;/2016/06/24/Leetcode-205-Isomorphic-Strings/&quot;&gt;这道题&lt;/a&gt;很相似，只是需要对字符串做一个预处理。仔细即可&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;  class Solution {&lt;br&gt;  public:&lt;br&gt;      bool wordPattern(string pattern, string str) {&lt;br&gt;          vector&lt;string&gt; s;&lt;br&gt;          helper(str,s);&lt;br&gt;          map&lt;char,string&gt; m;&lt;br&gt;          map&lt;string,char&gt; mr;&lt;br&gt;          map&lt;char,string&gt;::iterator it;&lt;br&gt;          map&lt;string,char&gt;::iterator itr;&lt;br&gt;          if(pattern.length()!=s.size()) return false;&lt;br&gt;          for(int i = 0; i &amp;lt; pattern.length(); i++)&lt;br&gt;          {&lt;br&gt;             it  = m.find(pattern[i]);&lt;br&gt;             itr = mr.find(s[i]);&lt;br&gt;             if(it!=m.end()||itr!=mr.end())&lt;br&gt;             {&lt;br&gt;                 if(m[pattern[i]]!=s[i]||mr[s[i]]!=pattern[i]) return false;&lt;br&gt;             }else{&lt;br&gt;                 m[pattern[i]]=s[i];&lt;br&gt;                 mr[s[i]]=pattern[i];&lt;br&gt;             }&lt;br&gt;          }&lt;br&gt;          return true;&lt;/string,char&gt;&lt;/char,string&gt;&lt;/string,char&gt;&lt;/char,string&gt;&lt;/string&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
void helper(string &amp;amp;str,vector&amp;lt;string&amp;gt;&amp;amp;s)
{
    string tem=&amp;quot;&amp;quot;;
    for(int i = 0;i&amp;lt;str.length();i++)
    {
        if(str[i]!=&amp;apos; &amp;apos;)tem+=str[i];
        else{
            s.push_back(tem);
            tem=&amp;quot;&amp;quot;;
        }
    }
    if(tem!=&amp;quot;&amp;quot;) s.push_back(tem);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  };&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a pattern and a string str, find if str follows the same pattern.&lt;/p&gt;
&lt;p&gt;Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;pattern = “abba”, str = “dog cat cat dog” should return true.&lt;br&gt;pattern = “abba”, str = “dog cat cat fish” should return false.&lt;br&gt;pattern = “aaaa”, str = “dog cat cat dog” should return false.&lt;br&gt;pattern = “abba”, str = “dog dog dog dog” should return false.&lt;br&gt;Notes:&lt;br&gt;You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-19-Remove Nth Node From End of List</title>
    <link href="http://since1992.org/2016/06/24/Leetcode-19-Remove-Nth-Node-From-End-of-List/"/>
    <id>http://since1992.org/2016/06/24/Leetcode-19-Remove-Nth-Node-From-End-of-List/</id>
    <published>2016-06-24T03:11:57.000Z</published>
    <updated>2016-06-24T03:19:59.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;   Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;/p&gt;
&lt;p&gt;   After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;br&gt;Note:&lt;br&gt;Given n will always be valid.&lt;br&gt;Try to do this in one pass.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;移除倒数第N个结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用双指针，让快指针先走，主要要删除的结点为首尾的情况。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Definition for singly-linked list.&lt;/li&gt;
&lt;li&gt;struct ListNode {&lt;/li&gt;
&lt;li&gt;int val;&lt;/li&gt;
&lt;li&gt;ListNode *next;&lt;/li&gt;
&lt;li&gt;ListNode(int x) : val(x), next(NULL) {}&lt;/li&gt;
&lt;li&gt;&lt;p&gt;};&lt;br&gt;*/&lt;br&gt;class Solution {&lt;br&gt; public:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ListNode* removeNthFromEnd(ListNode* head, int n) {
    if(!head-&amp;gt;next&amp;amp;&amp;amp;n==1) return NULL;
    ListNode* fast = head;
    ListNode* slow = fast;
    for(int i=0;i&amp;lt;n;i++)
    fast=fast-&amp;gt;next;
    if(!fast) return head-&amp;gt;next;
    while(fast-&amp;gt;next){
        fast=fast-&amp;gt;next;
        slow=slow-&amp;gt;next;
    }
    slow-&amp;gt;next=slow-&amp;gt;next-&amp;gt;next;
    return head;

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; };&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;   Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;/p&gt;
&lt;p&gt;   After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;br&gt;Note:&lt;br&gt;Given n will always be valid.&lt;br&gt;Try to do this in one pass.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-205-Isomorphic Strings</title>
    <link href="http://since1992.org/2016/06/24/Leetcode-205-Isomorphic-Strings/"/>
    <id>http://since1992.org/2016/06/24/Leetcode-205-Isomorphic-Strings/</id>
    <published>2016-06-24T02:12:59.000Z</published>
    <updated>2016-06-24T02:17:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;/p&gt;
&lt;p&gt;Two strings are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;p&gt;All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given “egg”, “add”, return true.&lt;/p&gt;
&lt;p&gt;Given “foo”, “bar”, return false.&lt;/p&gt;
&lt;p&gt;Given “paper”, “title”, return true.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个字符串，判断它们是否是相似的。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用两个哈希表判断两个字符之间是否是一一对应的即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isIsomorphic(string s, string t) {
        std::map&amp;lt;char,char&amp;gt; m;
        std::map&amp;lt;char,char&amp;gt; mr;
        std::map&amp;lt;char,char&amp;gt;::iterator it;
        std::map&amp;lt;char,char&amp;gt;::iterator itr;
        for(int i = 0; i &amp;lt; s.length(); i++)
        {  
           it  = m.find(s[i]);
           itr = mr.find(t[i]);
           if(it!=m.end()||itr!=mr.end())
           {
               if(m[s[i]]!=t[i]||mr[t[i]]!=s[i]) return false;
           }else{
               m[s[i]]=t[i];
               mr[t[i]]=s[i];
           }
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;/p&gt;
&lt;p&gt;Two strings are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;p&gt;All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given “egg”, “add”, return true.&lt;/p&gt;
&lt;p&gt;Given “foo”, “bar”, return false.&lt;/p&gt;
&lt;p&gt;Given “paper”, “title”, return true.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-223-Rectangle Area</title>
    <link href="http://since1992.org/2016/06/23/Leetcode-223-Rectangle-Area/"/>
    <id>http://since1992.org/2016/06/23/Leetcode-223-Rectangle-Area/</id>
    <published>2016-06-23T13:15:40.000Z</published>
    <updated>2016-06-23T14:07:10.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Find the total area covered by two rectilinear rectangles in a 2D plane.&lt;/p&gt;
&lt;p&gt;Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.&lt;br&gt;&lt;a href=&quot;https://leetcode.com/static/images/problemset/rectangle_area.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;br&gt;Assume that the total area is never beyond the maximum possible value of int.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;求出两个矩形覆盖的面积值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;分重叠与无重叠两种情况讨论，很简单。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        int AreaA = (C-A)*(D-B);
        int AreaB = (G-E)*(H-F);
        if(A&amp;gt;=G||C&amp;lt;=E||B&amp;gt;=H||F&amp;gt;=D) return AreaA+AreaB;
        int cover = max(min(C,G)-max(A,E),0)*max(min(D,H)-max(F,B),0);
        return AreaA+AreaB-cover;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Find the total area covered by two rectilinear rectangles in a 2D plane.&lt;/p&gt;
&lt;p&gt;Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.&lt;br&gt;&lt;a href=&quot;https://leetcode.com/static/images/problemset/rectangle_area.png&quot;&gt;&lt;/a&gt;&lt;br&gt;Assume that the total area is never beyond the maximum possible value of int.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-88-Merge Sorted Array</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-88-Merge-Sorted-Array/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-88-Merge-Sorted-Array/</id>
    <published>2016-06-19T10:17:53.000Z</published>
    <updated>2016-06-19T10:19:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;合并两个排了序的数组到nums1。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本题简单，从后开始往前合并即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) {
        while(m&amp;gt;0&amp;amp;&amp;amp;n&amp;gt;0)
        {
            if(nums1[m-1]&amp;gt;nums2[n-1]){
                nums1[m+n-1]=nums1[m-1];
                m--;
            }else{
                nums1[m+n-1]=nums2[n-1];
                n--;
            }

        }
        if(n&amp;gt;0)
        {
            for(int i=0;i&amp;lt;n;i++)
            nums1[i]=nums2[i];
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-299-Bulls and Cows</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-299-Bulls-and-Cows/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-299-Bulls-and-Cows/</id>
    <published>2016-06-19T10:06:23.000Z</published>
    <updated>2016-06-19T10:19:46.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulls_and_Cows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Bulls and Cows&lt;/a&gt; game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1807”&lt;br&gt;Friend’s guess: “7810”&lt;br&gt;Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)&lt;br&gt;Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.&lt;/p&gt;
&lt;p&gt;Please note that both secret number and friend’s guess may contain duplicate digits, for example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1123”&lt;br&gt;Friend’s guess: “0111”&lt;br&gt;In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.&lt;br&gt;You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;朋友猜你所想的数字，如果数字与位置均正确记为A，如果数字正确位置错误记为B。输出”XAYB“的结果&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;用两个数组统计每个数字出现的次数，然后就可以输出结果了。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string getHint(string secret, string guess) {
        if(!secret.length()||!guess.length()) return &amp;quot;0A0B&amp;quot;;
        vector&amp;lt;int&amp;gt;countS(10,0);
        vector&amp;lt;int&amp;gt;countG(10,0);
        int A=0;
        int B=0;
        for(int i=0;i&amp;lt;secret.length();i++)
        {
            if(secret[i]==guess[i])
            A++;
            else{
                countS[secret[i]-&amp;apos;0&amp;apos;]++;
                countG[guess[i]-&amp;apos;0&amp;apos;]++;
            }
        }
        for(int i=0;i&amp;lt;10;i++)
        {
            B+=min(countS[i],countG[i]);
        }
        string res=&amp;quot;&amp;quot;;
        res+=num2str(A);
        res+=&amp;apos;A&amp;apos;;
        res+=num2str(B);
        res+=&amp;apos;B&amp;apos;;
        return res;
    }
    string num2str(int n)
    {
        if(n==0) return &amp;quot;0&amp;quot;;
        string res=&amp;quot;&amp;quot;;
        while(n&amp;gt;0)
        {
            res=(char)((n%10)+&amp;apos;0&amp;apos;)+res;
            n/=10;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are playing the following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bulls_and_Cows&quot;&gt;Bulls and Cows&lt;/a&gt; game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1807”&lt;br&gt;Friend’s guess: “7810”&lt;br&gt;Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)&lt;br&gt;Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.&lt;/p&gt;
&lt;p&gt;Please note that both secret number and friend’s guess may contain duplicate digits, for example:&lt;/p&gt;
&lt;p&gt;Secret number:  “1123”&lt;br&gt;Friend’s guess: “0111”&lt;br&gt;In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.&lt;br&gt;You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-219-Contains Duplicate II</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-219-Contains-Duplicate-II/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-219-Contains-Duplicate-II/</id>
    <published>2016-06-19T09:50:00.000Z</published>
    <updated>2016-06-19T10:19:47.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组和一个数字N，求数组里又没有间隔N以下的相等值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;维护一个大小为K的滑动窗口，只需要O（n）的时间即可。注意K大于数组容量的情况。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        if(nums.empty()||k&amp;lt;1) return false;
        set&amp;lt;int&amp;gt; s;
        if(k&amp;gt;nums.size())
        {
            for(int i=0;i&amp;lt;nums.size();i++){
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);

            }
              return false;  
        }
        else
        {
            for(int i=0;i&amp;lt;k;i++)
            {
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);
            }
            for(int j=k;j&amp;lt;nums.size();j++)
            {

                if(s.find(nums[j])!=s.end())
                return true;
                else{
                s.insert(nums[j]);
                s.erase(nums[j-k]);
                }
            }
            return false;
        }


    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Array" scheme="http://since1992.org/tags/Array/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-160-Intersection of Two Linked Lists</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-160-Intersection-of-Two-Linked-Lists/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-160-Intersection-of-Two-Linked-Lists/</id>
    <published>2016-06-19T09:38:27.000Z</published>
    <updated>2016-06-19T10:19:48.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;The linked lists must retain their original structure after the function returns.&lt;br&gt;You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;Your code should preferably run in O(n) time and use only O(1) memory.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给两个单向链表，返回他们的交接处，如果没有交接，则返回空指针，只能使用O(1)的额外空间，且不可以修改原链表。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;统计出两个链表的节点数，让长的那个从头去掉相差额的结点，则相遇即相交。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA||!headB) return NULL;
        int counta=0;
        int countb=0;
        ListNode* a= headA;
        ListNode* b= headB;
        while(a)
        {
            counta++;
            a=a-&amp;gt;next;
        }
        while(b)
        {
            countb++;
            b=b-&amp;gt;next;
        }
        int dif = counta-countb;

            for(int i=abs(dif);i&amp;gt;0;i--)
            {
                if(dif &amp;gt; 0)
                    headA=headA-&amp;gt;next;
                else headB=headB-&amp;gt;next;
            }
        while(headA&amp;amp;&amp;amp;headB&amp;amp;&amp;amp;headA!=headB)
        {
            headA=headA-&amp;gt;next;
            headB=headB-&amp;gt;next;
        }
        ListNode * res;
        headA==headB?res=headA:res=NULL;
        return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;
&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;br&gt;The linked lists must retain their original structure after the function returns.&lt;br&gt;You may assume there are no cycles anywhere in the entire linked structure.&lt;br&gt;Your code should preferably run in O(n) time and use only O(1) memory.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-225-Implement Stack using Queues</title>
    <link href="http://since1992.org/2016/06/19/Leetcode-225-Implement-Stack-using-Queues/"/>
    <id>http://since1992.org/2016/06/19/Leetcode-225-Implement-Stack-using-Queues/</id>
    <published>2016-06-19T09:03:06.000Z</published>
    <updated>2016-06-19T09:05:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;empty() – Return whether the stack is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;用队列实现栈的操作。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;和&lt;a href=&quot;/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/&quot;&gt;这道题&lt;/a&gt;类似，注意对应变量关系即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Stack {

public:
    queue&amp;lt;int&amp;gt; q1;
    queue&amp;lt;int&amp;gt; q2;
    int count = 0;
    // Push element x onto stack.
    void push(int x) {
        q1.push(x);
        count++;
    }

    // Removes the element on top of the stack.
    void pop() {
        while(count&amp;gt;1)
        {
            q2.push(q1.front());
            q1.pop();
            count--;
        }
        q1.pop();
        count--;
        while(!q2.empty())
        {
            q1.push(q2.front());
            count++;
            q2.pop();
        }
    }

    // Get the top element.
    int top() {
      return q1.back();

    }

    // Return whether the stack is empty.
    bool empty() {
        return q1.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;empty() – Return whether the stack is empty.&lt;br&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
      <category term="Design" scheme="http://since1992.org/tags/Design/"/>
    
  </entry>
  
</feed>
