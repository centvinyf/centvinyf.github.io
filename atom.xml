<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>帆的小窝</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://since1992.org/"/>
  <updated>2016-07-02T09:41:45.000Z</updated>
  <id>http://since1992.org/</id>
  
  <author>
    <name>Fan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-168-Excel Sheet Column Title</title>
    <link href="http://since1992.org/2016/07/02/Leetcode-168-Excel-Sheet-Column-Title/"/>
    <id>http://since1992.org/2016/07/02/Leetcode-168-Excel-Sheet-Column-Title/</id>
    <published>2016-07-02T09:39:53.000Z</published>
    <updated>2016-07-02T09:41:45.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a positive integer, return its corresponding column title as appear in an Excel sheet.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 -&amp;gt; A
2 -&amp;gt; B
3 -&amp;gt; C
...
26 -&amp;gt; Z
27 -&amp;gt; AA
28 -&amp;gt; AB 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个正整数，返回对应的Excel表头&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;实质上就是一个十进制对26进制的转换问题，注意26整数幂的特殊情况对应的行即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string convertToTitle(int n) {
        string res=&amp;quot;&amp;quot;;
        while(n&amp;gt;0)
        {
            int rest = n%26;
            n/=26;
            if(rest==0){
                n--;
                res=&amp;apos;Z&amp;apos;+res;
            }else res= (char)(&amp;apos;A&amp;apos;-1+rest)+res;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a positive integer, return its corresponding column title as appear in an Excel sheet.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 -&amp;gt; A
2 -&amp;gt; B
3 -&amp;gt; C
...
26 -&amp;gt; Z
27 -&amp;gt; AA
28 -&amp;gt; AB 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-6-ZigZag Conversion</title>
    <link href="http://since1992.org/2016/07/02/Leetcode-6-ZigZag-Conversion/"/>
    <id>http://since1992.org/2016/07/02/Leetcode-6-ZigZag-Conversion/</id>
    <published>2016-07-02T09:20:56.000Z</published>
    <updated>2016-07-02T09:22:20.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then read line by line: “PAHNAPLSIIGYIR”&lt;br&gt;Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string convert(string text, int nRows);
convert(&amp;quot;PAYPALISHIRING&amp;quot;, 3) should return &amp;quot;PAHNAPLSIIGYIR&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个字符串和一个要生成的行数，给出之字打印的结果。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的字符串操作，利用一个辅助数组，存储每一行的结果，再依次连接起来即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string convert(string s, int numRows) {
        if(s.empty()||numRows&amp;lt;1) return &amp;quot;&amp;quot;;
        if(numRows==1) return s;
       vector&amp;lt;string&amp;gt; res(numRows);
       int i = 0;
       int j = 0;
       int dif=1;
       while(i&amp;lt;s.length())
       {
           res[j].push_back(s[i]);
           if(j==numRows-1){
               dif=-1;

           }else if(j==0){
               dif = 1;

           }
           j+=dif;
           i++;
       }
       string ans=&amp;quot;&amp;quot;;
       for(int i = 0;i&amp;lt;numRows;i++)
       ans+=res[i];
       return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then read line by line: “PAHNAPLSIIGYIR”&lt;br&gt;Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string convert(string text, int nRows);
convert(&amp;quot;PAYPALISHIRING&amp;quot;, 3) should return &amp;quot;PAHNAPLSIIGYIR&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-189-Rotate Array</title>
    <link href="http://since1992.org/2016/07/02/Leetcode-189-Rotate-Array/"/>
    <id>http://since1992.org/2016/07/02/Leetcode-189-Rotate-Array/</id>
    <published>2016-07-02T08:47:42.000Z</published>
    <updated>2016-07-02T08:51:44.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Rotate an array of n elements to the right by k steps.&lt;/p&gt;
&lt;p&gt;For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;把一个数组的后N个数移动到数组的最前面。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用插入的方式从后往前依次插入数组最前端即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        for(int i=0;i&amp;lt;k;i++)
        {
            nums.insert(nums.begin(),nums.back());
            nums.erase(nums.begin()+nums.size()-1);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Rotate an array of n elements to the right by k steps.&lt;/p&gt;
&lt;p&gt;For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-278-First Bad Version</title>
    <link href="http://since1992.org/2016/07/02/Leetcode-278-First-Bad-Version/"/>
    <id>http://since1992.org/2016/07/02/Leetcode-278-First-Bad-Version/</id>
    <published>2016-07-02T03:15:23.000Z</published>
    <updated>2016-07-02T03:40:37.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;从某一个版本开始全部都是坏的版本，找到第一个坏版本。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用二分查找，注意边界条件即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        if(n==2) return isBadVersion(1)? 1:2;
        int begin = 1;
        int end = n;
        int mid = begin+(end-begin)/2;
        while(begin&amp;lt;end){
        if(isBadVersion(mid))
        {
            end=mid;
            mid = begin+(end-begin)/2;
        }else{
            begin = mid+1;
            mid = begin+(end-begin)/2;
        }
        }
        return mid;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Binary Search" scheme="http://since1992.org/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-155-Min Stack</title>
    <link href="http://since1992.org/2016/07/02/Leetcode-155-Min-Stack/"/>
    <id>http://since1992.org/2016/07/02/Leetcode-155-Min-Stack/</id>
    <published>2016-07-02T02:53:54.000Z</published>
    <updated>2016-07-02T02:56:54.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;getMin() – Retrieve the minimum element in the stack.&lt;br&gt;Example:&lt;br&gt;    MinStack minStack = new MinStack();&lt;br&gt;    minStack.push(-2);&lt;br&gt;    minStack.push(0);&lt;br&gt;    minStack.push(-3);&lt;br&gt;    minStack.getMin();   –&amp;gt; Returns -3.&lt;br&gt;    minStack.pop();&lt;br&gt;    minStack.top();      –&amp;gt; Returns 0.&lt;br&gt;    minStack.getMin();   –&amp;gt; Returns -2.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;设计一个栈，支持push,pop,top和在O(1)时间内找到最小值。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用一个栈存储到此为止的最小值。注意如果有重复的最小值需要多次push，因为如果出现3 2 1 2 1这样的用例，若不重复入栈则会出错。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class MinStack {
public:
stack&amp;lt;int&amp;gt; st;
stack&amp;lt;int&amp;gt; minSt;
    /** initialize your data structure here. */
    MinStack() {

    }

    void push(int x) {
        st.push(x);
        if(minSt.empty()||x&amp;lt;=minSt.top()) minSt.push(x);
    }

    void pop() {
        if(minSt.top()==st.top()) minSt.pop();
        st.pop();
    }

    int top() {
        return st.top();
    }

    int getMin() {
        return minSt.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&lt;/p&gt;
&lt;p&gt;push(x) – Push element x onto stack.&lt;br&gt;pop() – Removes the element on top of the stack.&lt;br&gt;top() – Get the top element.&lt;br&gt;getMin() – Retrieve the minimum element in the stack.&lt;br&gt;Example:&lt;br&gt;    MinStack minStack = new MinStack();&lt;br&gt;    minStack.push(-2);&lt;br&gt;    minStack.push(0);&lt;br&gt;    minStack.push(-3);&lt;br&gt;    minStack.getMin();   –&amp;gt; Returns -3.&lt;br&gt;    minStack.pop();&lt;br&gt;    minStack.top();      –&amp;gt; Returns 0.&lt;br&gt;    minStack.getMin();   –&amp;gt; Returns -2.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
      <category term="Design" scheme="http://since1992.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-7-Reverse Integer</title>
    <link href="http://since1992.org/2016/07/01/Leetcode-7-Reverse-Integer/"/>
    <id>http://since1992.org/2016/07/01/Leetcode-7-Reverse-Integer/</id>
    <published>2016-07-01T09:39:08.000Z</published>
    <updated>2016-07-01T09:40:01.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;Example1: x = 123, return 321&lt;br&gt;Example2: x = -123, return -321&lt;/p&gt;
&lt;p&gt;click to show spoilers.&lt;/p&gt;
&lt;p&gt;Have you thought about this?&lt;br&gt;Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!&lt;/p&gt;
&lt;p&gt;If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.&lt;/p&gt;
&lt;p&gt;Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?&lt;/p&gt;
&lt;p&gt;For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个数字。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;很简单的数学题目，注意overflow的情况即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int reverse(int x) {
        int res=0;
        while(abs(x)&amp;gt;0)
        {
            if(res&amp;gt;INT_MAX/10||res&amp;lt;INT_MIN/10) return 0;
            res*=10;
            res+=x%10;
            x/=10;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;Example1: x = 123, return 321&lt;br&gt;Example2: x = -123, return -321&lt;/p&gt;
&lt;p&gt;click to show spoilers.&lt;/p&gt;
&lt;p&gt;Have you thought about this?&lt;br&gt;Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!&lt;/p&gt;
&lt;p&gt;If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.&lt;/p&gt;
&lt;p&gt;Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?&lt;/p&gt;
&lt;p&gt;For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Math" scheme="http://since1992.org/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-125-Valid Palindrome</title>
    <link href="http://since1992.org/2016/06/30/Leetcode-125-Valid-Palindrome/"/>
    <id>http://since1992.org/2016/06/30/Leetcode-125-Valid-Palindrome/</id>
    <published>2016-06-30T15:48:57.000Z</published>
    <updated>2016-06-30T15:50:51.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;“A man, a plan, a canal: Panama” is a palindrome.&lt;br&gt;“race a car” is not a palindrome.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Have you consider that the string might be empty? This is a good question to ask during an interview.&lt;/p&gt;
&lt;p&gt;For the purpose of this problem, we define empty string as valid palindrome.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个字符串，判断它是否是回文的。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;这道题不难，只要对原始字符串进行适当的预处理之后（去掉标点符号）在判断是否是回文即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isPalindrome(string s) {
        string nstr=&amp;quot;&amp;quot;;
        for(int i = 0; i &amp;lt; s.length(); i++)
        {
            if(s[i]&amp;gt;=&amp;apos;a&amp;apos;&amp;amp;&amp;amp;s[i]&amp;lt;=&amp;apos;z&amp;apos;)
                nstr+=s[i];
            else if(s[i]&amp;gt;=&amp;apos;A&amp;apos;&amp;amp;&amp;amp;s[i]&amp;lt;=&amp;apos;Z&amp;apos;)
                nstr+=(char)(s[i]-&amp;apos;A&amp;apos;+&amp;apos;a&amp;apos;);
            else if(s[i]&amp;gt;=&amp;apos;0&amp;apos;&amp;amp;&amp;amp;s[i]&amp;lt;=&amp;apos;9&amp;apos;)
                nstr+=s[i];
        }
        for(int i = 0;i&amp;lt;nstr.length();i++)
        {
            if(nstr[i]!=nstr[nstr.length()-1-i]) return false;
        }
        return true;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;“A man, a plan, a canal: Panama” is a palindrome.&lt;br&gt;“race a car” is not a palindrome.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Have you consider that the string might be empty? This is a good question to ask during an interview.&lt;/p&gt;
&lt;p&gt;For the purpose of this problem, we define empty string as valid palindrome.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://since1992.org/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-1-Two Sum</title>
    <link href="http://since1992.org/2016/06/30/Leetcode-1-Two-Sum/"/>
    <id>http://since1992.org/2016/06/30/Leetcode-1-Two-Sum/</id>
    <published>2016-06-30T15:36:59.000Z</published>
    <updated>2016-06-30T15:38:36.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;
&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;br&gt;return [0, 1].&lt;br&gt;UPDATE (2016/2/13):&lt;br&gt;The return format had been changed to zero-based indices. Please read the above updated description carefully.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;在给定数组中找到两个数的和为目标值，求出对应的两个值的坐标。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;对原数组进行哈希存储，值对应坐标即可，然后查询差值是否在哈希表中。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        vector&amp;lt;int&amp;gt; res;
        map&amp;lt;int,int&amp;gt; m;
        if(nums.empty()) return res;
        for(int i = 0 ; i &amp;lt; nums.size(); i++)
        {
            int rest = target-nums[i];
            if(m.find(rest)!=m.end()){
                res.push_back(m[rest]);
                res.push_back(i);
                break;
            }else{
                m[nums[i]]=i;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;
&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;br&gt;return [0, 1].&lt;br&gt;UPDATE (2016/2/13):&lt;br&gt;The return format had been changed to zero-based indices. Please read the above updated description carefully.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-303-Range Sum Query- Immutable</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-303-Range-Sum-Query-Immutable/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-303-Range-Sum-Query-Immutable/</id>
    <published>2016-06-27T14:52:18.000Z</published>
    <updated>2016-06-27T14:54:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example:
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:&lt;br&gt;You may assume that the array does not change.&lt;br&gt;There are many calls to sumRange function.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个数组，多次查询从i到j的和，实现它。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用一个数组存储从头到I的总和。那么i-j的和用从头到j和减去从头到i-1的和，即为所求。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class NumArray {
public:
    vector&amp;lt;int&amp;gt; dp;

    NumArray(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
     dp.resize(nums.size());
     if(!nums.empty()){
     dp[0]=nums[0];
     for(int i=1;i&amp;lt;nums.size();i++)
     dp[i]=dp[i-1]+nums[i];
     }
    }

    int sumRange(int i, int j) {
        return i==0?dp[j]:dp[j]-dp[i-1];
    }
};


// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
// numArray.sumRange(1, 2);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example:
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:&lt;br&gt;You may assume that the array does not change.&lt;br&gt;There are many calls to sumRange function.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Dynamic Programming" scheme="http://since1992.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-28-Implement strStr()</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-28-Implement-strStr/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-28-Implement-strStr/</id>
    <published>2016-06-27T14:37:57.000Z</published>
    <updated>2016-06-27T14:39:20.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;返回字符串中某子串的出现的第一个序列号。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;维护一个长度和子串相等的滑动窗口，比较它是否和子串相等即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.length()&amp;gt;haystack.size()) return -1;
        if(needle==&amp;quot;&amp;quot;) return 0;
        for(int i = 0 ; i &amp;lt;haystack.length();i++)
        {
            string win= haystack.substr(i,needle.size());
            if(win==needle) return i;
        }
        return -1;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Implement strStr().&lt;/p&gt;
&lt;p&gt;Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-67-Add Binary</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-67-Add-Binary/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-67-Add-Binary/</id>
    <published>2016-06-27T14:30:12.000Z</published>
    <updated>2016-06-27T14:32:56.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary strings, return their sum (also a binary string).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定两个二进制数，求他们的和。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的字符串操作，注意进位和最后加完了还有进位的情况。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string addBinary(string a, string b) {
        string res=&amp;quot;&amp;quot;;
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0 ;
        if(i&amp;gt;j)
        {
            for(int x =0;x&amp;lt;i-j; x++)
            b=&amp;apos;0&amp;apos;+b;
        }else{
            for(int x =0 ;x&amp;lt;j-i;x++)
            a=&amp;apos;0&amp;apos;+a;
        }
        int len = a.length()-1;
        int cur;
        while(len&amp;gt;=0){
            cur = (a[len]-&amp;apos;0&amp;apos;)+(b[len]-&amp;apos;0&amp;apos;)+carry;
            carry=cur/2;
            cur%=2;
            res= (char)(cur+&amp;apos;0&amp;apos;) + res;
            len--;
        }
       if(carry==1) res= to_string(1)+res;
        return res;

    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given two binary strings, return their sum (also a binary string).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-14-LongestCommon Prefix</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-14-LongestCommon-Prefix/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-14-LongestCommon-Prefix/</id>
    <published>2016-06-27T12:18:54.000Z</published>
    <updated>2016-06-27T12:20:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;找出一组字符串的最长前缀。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;从前往后依次搜索即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) {
        if(strs.empty()) return &amp;quot;&amp;quot;;
        string prefix = &amp;quot;&amp;quot;;
        for(int i = 0;i &amp;lt; strs[0].length(); i++)
        {
            char cur = strs[0][i];
            for(int j =  0 ;j &amp;lt; strs.size();j++){
            if(strs[j][i]==cur) {
                if(j==strs.size()-1) prefix+=cur;
            }else return prefix;
            }
        }
        return prefix;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-234-Palindrome Linked List</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-234-Palindrome-Linked-List/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-234-Palindrome-Linked-List/</id>
    <published>2016-06-27T11:52:06.000Z</published>
    <updated>2016-06-27T11:54:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do it in O(n) time and O(1) space?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;判断一个单向链表是否是回文的。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;存下来每一个结点的值，判断是否是对称的即可。至于follow up,可以考虑反转后半个链表，然后挨个比对是否和前半部分相等即可。本文只给出第一种解法。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector&amp;lt;int&amp;gt; v;
        while(head)
        {
            v.push_back(head-&amp;gt;val);
            head=head-&amp;gt;next;
        }
        for(int i = 0;i&amp;lt; v.size()/2 ; i++)
        if(v[i]!=v[v.size()-1-i]) return false;
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do it in O(n) time and O(1) space?&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-203-Remove Linked List Elements</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-203-Remove-Linked-List-Elements/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-203-Remove-Linked-List-Elements/</id>
    <published>2016-06-27T10:24:58.000Z</published>
    <updated>2016-06-27T10:26:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;/p&gt;
&lt;p&gt;Example&lt;br&gt;    Given: 1 –&amp;gt; 2 –&amp;gt; 6 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5 –&amp;gt; 6, val = 6&lt;br&gt;    Return: 1 –&amp;gt; 2 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;去掉单向链表中所有值与给定值相等的结点。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;保存之前的结点，然后扫描每个节点即可。注意头结点是否会被去掉的问题。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(!head) return head;
        ListNode * prev = head;
        ListNode * cur = prev-&amp;gt;next;
        while(prev-&amp;gt;next)
        {
            if(cur-&amp;gt;val == val){
                prev-&amp;gt;next =  cur-&amp;gt;next;
                cur=prev-&amp;gt;next;
            }else{
                prev= cur;
                cur = prev-&amp;gt;next;
            }
        }
       if(head-&amp;gt;val == val) return head-&amp;gt;next;
       return head;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;/p&gt;
&lt;p&gt;Example&lt;br&gt;    Given: 1 –&amp;gt; 2 –&amp;gt; 6 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5 –&amp;gt; 6, val = 6&lt;br&gt;    Return: 1 –&amp;gt; 2 –&amp;gt; 3 –&amp;gt; 4 –&amp;gt; 5&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Linked List" scheme="http://since1992.org/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-190-Reverse Bits</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-190-Reverse-Bits/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-190-Reverse-Bits/</id>
    <published>2016-06-27T10:13:40.000Z</published>
    <updated>2016-06-27T10:15:23.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;反转一个32位整数（原来是0,1,2,3,…32, 变成 32,31,30…,1）&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;简单的位运算操作。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0 ;
        int mask = 1 ;
        for(int i = 0 ; i &amp;lt;  32 ; i ++)
        {
            if( n &amp;amp; mask ) res += 1 ;
            if(i &amp;lt; 31)res &amp;lt;&amp;lt;=  1 ;
            mask &amp;lt;&amp;lt;= 1;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Bit Manipulation" scheme="http://since1992.org/tags/Bit-Manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-257-Binary Tree Paths</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-257-Binary-Tree-Paths/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-257-Binary-Tree-Paths/</id>
    <published>2016-06-27T09:55:50.000Z</published>
    <updated>2016-06-27T09:57:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return all root-to-leaf paths.&lt;/p&gt;
&lt;p&gt;For example, given the following binary tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
 /   \
2     3
 \
  5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All root-to-leaf paths are:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，返回所有的从根结点到叶子节点的路径。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;利用深度优先搜索，每当走到叶子节点便返回路径。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;string&amp;gt; binaryTreePaths(TreeNode* root) {
        vector&amp;lt;string&amp;gt; res;
        if(root)
            dfs(root,res,&amp;quot;&amp;quot;);
        return res;
    }
    void dfs(TreeNode* root, vector&amp;lt;string&amp;gt; &amp;amp;res, string path){
        path+=to_string(root-&amp;gt;val);
        if(!root-&amp;gt;left&amp;amp;&amp;amp;!root-&amp;gt;right)
            res.push_back(path);
        else {
            if(root-&amp;gt;left)
                dfs(root-&amp;gt;left,res,path+&amp;quot;-&amp;gt;&amp;quot;);
            if(root-&amp;gt;right)
                dfs(root-&amp;gt;right,res,path+&amp;quot;-&amp;gt;&amp;quot;);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a binary tree, return all root-to-leaf paths.&lt;/p&gt;
&lt;p&gt;For example, given the following binary tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
 /   \
2     3
 \
  5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All root-to-leaf paths are:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Tree" scheme="http://since1992.org/tags/Tree/"/>
    
      <category term="DFS" scheme="http://since1992.org/tags/DFS/"/>
    
      <category term="Mark" scheme="http://since1992.org/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-58-Length of Last Word</title>
    <link href="http://since1992.org/2016/06/27/Leetcode-58-Length-of-Last-Word/"/>
    <id>http://since1992.org/2016/06/27/Leetcode-58-Length-of-Last-Word/</id>
    <published>2016-06-27T09:08:01.000Z</published>
    <updated>2016-06-27T09:09:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.&lt;/p&gt;
&lt;p&gt;If the last word does not exist, return 0.&lt;/p&gt;
&lt;p&gt;Note: A word is defined as a character sequence consists of non-space characters only.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given s = “Hello World”,&lt;br&gt;return 5.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;返回一个字符串中最后一个单词的长度。如果不存在，则返回0&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;先去掉尾部空格再计算最后一个单词长度即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int lengthOfLastWord(string s) {
        if(s==&amp;quot;&amp;quot;) return 0;
        int i = s.length()-1;
        int count = 0;
        while(i&amp;gt;=0){
            if(count==0&amp;amp;&amp;amp;s[i]==&amp;apos; &amp;apos;) i--;
            else if(s[i]!=&amp;apos; &amp;apos;){
                i--;count++;
            }else if(count&amp;gt;0&amp;amp;&amp;amp;s[i]==&amp;apos; &amp;apos;) break;

        }
        return count;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.&lt;/p&gt;
&lt;p&gt;If the last word does not exist, return 0.&lt;/p&gt;
&lt;p&gt;Note: A word is defined as a character sequence consists of non-space characters only.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given s = “Hello World”,&lt;br&gt;return 5.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-38-Count and Sway</title>
    <link href="http://since1992.org/2016/06/26/Leetcode-38-Count-and-Say/"/>
    <id>http://since1992.org/2016/06/26/Leetcode-38-Count-and-Say/</id>
    <published>2016-06-26T09:09:00.000Z</published>
    <updated>2016-06-26T09:11:55.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers beginning as follows:&lt;br&gt;1, 11, 21, 1211, 111221, …&lt;/p&gt;
&lt;p&gt;1 is read off as “one 1” or 11.&lt;br&gt;11 is read off as “two 1s” or 21.&lt;br&gt;21 is read off as “one 2, then one 1” or 1211.&lt;br&gt;Given an integer n, generate the nth sequence.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;边数边说出上一次的结果。 1读作 “1 1”，11读作“ 2 1”，21读作“1 2 1 1”&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;递归调用该函数，利用上一次的计算结果来读数即可。注意：数字转化成字符串的时候不可以直接 +’0’,因为有可能会是超过一位数。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    string countAndSay(int n) {
        if(n==0) return &amp;quot;&amp;quot;;
        if(n==1) return &amp;quot;1&amp;quot;;
        string res=&amp;quot;&amp;quot;;
        string prev = countAndSay(n-1);
        int count = 1;
        char cur=prev[0];
        for(int i = 1 ; i &amp;lt; prev.length(); i++)
        {
            if(prev[i]==cur) count++;
            else
            {
                res+=i2s(count);
                res+=cur;
                count = 1;
                cur=prev[i];
            }
        }
        res+=i2s(count);
        res+=cur;
        return res;

    }
    string i2s(int n)
    {
        string res = &amp;quot;&amp;quot;;
        while(n&amp;gt;0){
            res+=(char)(n%10+&amp;apos;0&amp;apos;);
            n/=10;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;The count-and-say sequence is the sequence of integers beginning as follows:&lt;br&gt;1, 11, 21, 1211, 111221, …&lt;/p&gt;
&lt;p&gt;1 is read off as “one 1” or 11.&lt;br&gt;11 is read off as “two 1s” or 21.&lt;br&gt;21 is read off as “one 2, then one 1” or 1211.&lt;br&gt;Given an integer n, generate the nth sequence.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="String" scheme="http://since1992.org/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-20-Valid Parentheses</title>
    <link href="http://since1992.org/2016/06/26/Leetcode-20-Valid-Parentheses/"/>
    <id>http://since1992.org/2016/06/26/Leetcode-20-Valid-Parentheses/</id>
    <published>2016-06-26T08:35:11.000Z</published>
    <updated>2016-06-26T08:36:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个字符串，判断它是否是一个合法的括号组。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;经典的栈匹配的问题。仔细即可。&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isValid(string s) {
        stack&amp;lt;char&amp;gt;st;
        for(int i = 0; i &amp;lt; s.length(); i ++)
        {
            switch(s[i]){
                case &amp;apos;(&amp;apos;:
                case &amp;apos;[&amp;apos;:
                case &amp;apos;{&amp;apos;: st.push(s[i]);break;
                case &amp;apos;)&amp;apos;: 
                    if(st.empty()) return false;
                    if(st.top()!=&amp;apos;(&amp;apos;) return false;
                    else st.pop();
                    break;
                case &amp;apos;}&amp;apos;:
                    if(st.empty()) return false;
                    if(st.top()!=&amp;apos;{&amp;apos;) return false;
                    else st.pop();
                    break;
                case &amp;apos;]&amp;apos;:
                    if(st.empty()) return false;
                    if(st.top()!=&amp;apos;[&amp;apos;) return false;
                    else st.pop();
                    break;
                default: continue;
            }
        }
        return st.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;/p&gt;
&lt;p&gt;The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Stack" scheme="http://since1992.org/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-290-Word Pattern</title>
    <link href="http://since1992.org/2016/06/26/Leetcode-290-Word-Pattern/"/>
    <id>http://since1992.org/2016/06/26/Leetcode-290-Word-Pattern/</id>
    <published>2016-06-26T08:11:29.000Z</published>
    <updated>2016-06-26T08:36:43.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a pattern and a string str, find if str follows the same pattern.&lt;/p&gt;
&lt;p&gt;Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;pattern = “abba”, str = “dog cat cat dog” should return true.&lt;br&gt;pattern = “abba”, str = “dog cat cat fish” should return false.&lt;br&gt;pattern = “aaaa”, str = “dog cat cat dog” should return false.&lt;br&gt;pattern = “abba”, str = “dog dog dog dog” should return false.&lt;br&gt;Notes:&lt;br&gt;You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;题目大意：&lt;/h2&gt;&lt;p&gt;给定一个模式和一个字符串，判定字符串是否和模式相匹配。&lt;/p&gt;
&lt;h2 id=&quot;Solutions&quot;&gt;&lt;a href=&quot;#Solutions&quot; class=&quot;headerlink&quot; title=&quot;Solutions:&quot;&gt;&lt;/a&gt;Solutions:&lt;/h2&gt;&lt;p&gt;本体和&lt;a href=&quot;/2016/06/24/Leetcode-205-Isomorphic-Strings/&quot;&gt;这道题&lt;/a&gt;很相似，只是需要对字符串做一个预处理。仔细即可&lt;/p&gt;
&lt;h2 id=&quot;Code-in-C&quot;&gt;&lt;a href=&quot;#Code-in-C&quot; class=&quot;headerlink&quot; title=&quot;Code in C++:&quot;&gt;&lt;/a&gt;Code in C++:&lt;/h2&gt;&lt;p&gt;  class Solution {&lt;br&gt;  public:&lt;br&gt;      bool wordPattern(string pattern, string str) {&lt;br&gt;          vector&lt;string&gt; s;&lt;br&gt;          helper(str,s);&lt;br&gt;          map&lt;char,string&gt; m;&lt;br&gt;          map&lt;string,char&gt; mr;&lt;br&gt;          map&lt;char,string&gt;::iterator it;&lt;br&gt;          map&lt;string,char&gt;::iterator itr;&lt;br&gt;          if(pattern.length()!=s.size()) return false;&lt;br&gt;          for(int i = 0; i &amp;lt; pattern.length(); i++)&lt;br&gt;          {&lt;br&gt;             it  = m.find(pattern[i]);&lt;br&gt;             itr = mr.find(s[i]);&lt;br&gt;             if(it!=m.end()||itr!=mr.end())&lt;br&gt;             {&lt;br&gt;                 if(m[pattern[i]]!=s[i]||mr[s[i]]!=pattern[i]) return false;&lt;br&gt;             }else{&lt;br&gt;                 m[pattern[i]]=s[i];&lt;br&gt;                 mr[s[i]]=pattern[i];&lt;br&gt;             }&lt;br&gt;          }&lt;br&gt;          return true;&lt;/string,char&gt;&lt;/char,string&gt;&lt;/string,char&gt;&lt;/char,string&gt;&lt;/string&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;}
void helper(string &amp;amp;str,vector&amp;lt;string&amp;gt;&amp;amp;s)
{
    string tem=&amp;quot;&amp;quot;;
    for(int i = 0;i&amp;lt;str.length();i++)
    {
        if(str[i]!=&amp;apos; &amp;apos;)tem+=str[i];
        else{
            s.push_back(tem);
            tem=&amp;quot;&amp;quot;;
        }
    }
    if(tem!=&amp;quot;&amp;quot;) s.push_back(tem);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  };&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description:&quot;&gt;&lt;/a&gt;Problem Description:&lt;/h2&gt;&lt;p&gt;Given a pattern and a string str, find if str follows the same pattern.&lt;/p&gt;
&lt;p&gt;Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;pattern = “abba”, str = “dog cat cat dog” should return true.&lt;br&gt;pattern = “abba”, str = “dog cat cat fish” should return false.&lt;br&gt;pattern = “aaaa”, str = “dog cat cat dog” should return false.&lt;br&gt;pattern = “abba”, str = “dog dog dog dog” should return false.&lt;br&gt;Notes:&lt;br&gt;You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.&lt;br&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://since1992.org/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://since1992.org/tags/Leetcode/"/>
    
      <category term="Easy" scheme="http://since1992.org/tags/Easy/"/>
    
      <category term="Hash Table" scheme="http://since1992.org/tags/Hash-Table/"/>
    
  </entry>
  
</feed>
