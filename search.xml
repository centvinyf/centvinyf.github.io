<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Leetcode-88-Merge Sorted Array]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-88-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>合并两个排了序的数组到nums1。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>本题简单，从后开始往前合并即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        while(m&gt;0&amp;&amp;n&gt;0)
        {
            if(nums1[m-1]&gt;nums2[n-1]){
                nums1[m+n-1]=nums1[m-1];
                m--;
            }else{
                nums1[m+n-1]=nums2[n-1];
                n--;
            }

        }
        if(n&gt;0)
        {
            for(int i=0;i&lt;n;i++)
            nums1[i]=nums2[i];
        }

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-299-Bulls and Cows]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-299-Bulls-and-Cows/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows" target="_blank" rel="external">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>For example:</p>
<p>Secret number:  “1807”<br>Friend’s guess: “7810”<br>Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)<br>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”.</p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits, for example:</p>
<p>Secret number:  “1123”<br>Friend’s guess: “0111”<br>In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.<br>You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>朋友猜你所想的数字，如果数字与位置均正确记为A，如果数字正确位置错误记为B。输出”XAYB“的结果</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>用两个数组统计每个数字出现的次数，然后就可以输出结果了。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    string getHint(string secret, string guess) {
        if(!secret.length()||!guess.length()) return &quot;0A0B&quot;;
        vector&lt;int&gt;countS(10,0);
        vector&lt;int&gt;countG(10,0);
        int A=0;
        int B=0;
        for(int i=0;i&lt;secret.length();i++)
        {
            if(secret[i]==guess[i])
            A++;
            else{
                countS[secret[i]-&apos;0&apos;]++;
                countG[guess[i]-&apos;0&apos;]++;
            }
        }
        for(int i=0;i&lt;10;i++)
        {
            B+=min(countS[i],countG[i]);
        }
        string res=&quot;&quot;;
        res+=num2str(A);
        res+=&apos;A&apos;;
        res+=num2str(B);
        res+=&apos;B&apos;;
        return res;
    }
    string num2str(int n)
    {
        if(n==0) return &quot;0&quot;;
        string res=&quot;&quot;;
        while(n&gt;0)
        {
            res=(char)((n%10)+&apos;0&apos;)+res;
            n/=10;
        }
        return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-219-Contains Duplicate II]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-219-Contains-Duplicate-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组和一个数字N，求数组里又没有间隔N以下的相等值。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>维护一个大小为K的滑动窗口，只需要O（n）的时间即可。注意K大于数组容量的情况。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        if(nums.empty()||k&lt;1) return false;
        set&lt;int&gt; s;
        if(k&gt;nums.size())
        {
            for(int i=0;i&lt;nums.size();i++){
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);

            }
              return false;  
        }
        else
        {
            for(int i=0;i&lt;k;i++)
            {
                if(s.find(nums[i])!=s.end())
                return true;
                else
                s.insert(nums[i]);
            }
            for(int j=k;j&lt;nums.size();j++)
            {

                if(s.find(nums[j])!=s.end())
                return true;
                else{
                s.insert(nums[j]);
                s.erase(nums[j-k]);
                }
            }
            return false;
        }


    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-160-Intersection of Two Linked Lists]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-160-Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<pre><code>A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
</code></pre><p>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给两个单向链表，返回他们的交接处，如果没有交接，则返回空指针，只能使用O(1)的额外空间，且不可以修改原链表。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>统计出两个链表的节点数，让长的那个从头去掉相差额的结点，则相遇即相交。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA||!headB) return NULL;
        int counta=0;
        int countb=0;
        ListNode* a= headA;
        ListNode* b= headB;
        while(a)
        {
            counta++;
            a=a-&gt;next;
        }
        while(b)
        {
            countb++;
            b=b-&gt;next;
        }
        int dif = counta-countb;

            for(int i=abs(dif);i&gt;0;i--)
            {
                if(dif &gt; 0)
                    headA=headA-&gt;next;
                else headB=headB-&gt;next;
            }
        while(headA&amp;&amp;headB&amp;&amp;headA!=headB)
        {
            headA=headA-&gt;next;
            headB=headB-&gt;next;
        }
        ListNode * res;
        headA==headB?res=headA:res=NULL;
        return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-225-Implement Stack using Queues]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-225-Implement-Stack-using-Queues/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Implement the following operations of a stack using queues.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>empty() – Return whether the stack is empty.<br>Notes:<br>You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.<br>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.<br>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>用队列实现栈的操作。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>和<a href="/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/">这道题</a>类似，注意对应变量关系即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Stack {

public:
    queue&lt;int&gt; q1;
    queue&lt;int&gt; q2;
    int count = 0;
    // Push element x onto stack.
    void push(int x) {
        q1.push(x);
        count++;
    }

    // Removes the element on top of the stack.
    void pop() {
        while(count&gt;1)
        {
            q2.push(q1.front());
            q1.pop();
            count--;
        }
        q1.pop();
        count--;
        while(!q2.empty())
        {
            q1.push(q2.front());
            count++;
            q2.pop();
        }
    }

    // Get the top element.
    int top() {
      return q1.back();

    }

    // Return whether the stack is empty.
    bool empty() {
        return q1.empty();
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-111-Minimum Depth of Binary Tree]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-111-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵树，找出它从根节点到某一叶子节点的最短路径。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题和<a href="/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/">找出最长路径</a>的做法不太一样。不能直接取左右较短者加一，因为有可能某个子树是空的。细心判断即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        int minl = minDepth(root-&gt;left);
        int minr = minDepth(root-&gt;right);
        int minx = min(minl,minr);
        minx==0?minx=minl+minr:minx=minx;
        return minx+1;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-12-Path Sum]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-112-Path-Sum/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,<br>              5<br>             / \<br>            4   8<br>           /   / \<br>          11  13  4<br>         /  \      \<br>        7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵二叉树，判断是否有从根到叶子节点的路径和等于给定值。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>一个简单的递归调用函数即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(!root) return false;
        sum-=root-&gt;val;
        return hasPathSum(root-&gt;left,sum)||hasPathSum(root-&gt;right,sum)||(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;sum==0);
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-9-Palindrome Number]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-9-Palindrome-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Determine whether an integer is a palindrome. Do this without extra space.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>判断一个整数是否是对称数。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>首先负数肯定不是对称的。然后可以把数字转化成字符串，存成两个正\反序的字符串，如果这两个字符串相等，则是对称的。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><p>class Solution {<br>    public:<br>        bool isPalindrome(int x) {<br>            if(x<0) return="" false;="" string="" a="" ,b="" ;="" while(x="">0)<br>            {<br>                a+=(char)(x%10+’0’);<br>                b=(char)(x%10+’0’)+b;<br>                x/=10;<br>            }<br>            return a==b;<br>        }<br>    };</0)></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-119-Pascal's Triangle II]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-119-Pascal-s-Triangle-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].<br>Note:<br>Could you optimize your algorithm to use only O(k) extra space?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数字N，返回帕斯卡三角的第N行结果。只能使用 O(k)的额外空间。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>用循环累加的办法生成对应行即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    vector&lt;int&gt; getRow(int rowIndex) {
        vector&lt;int&gt; row(1,1);
        if(rowIndex&lt;1) return row;
        for(int i=1;i&lt;=rowIndex;i++)
        {
            int prev1=row[0];
            int prev2;
            for(int j=1;j&lt;i;j++)
                {
                    prev2=row[j];
                    row[j]+=prev1;
                    prev1=prev2;
                }
            row.push_back(1);
        }
        return row;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-172-Factorial Trailing Zeroes]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-172-Factorial-Trailing-Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer n, return the number of trailing zeroes in n!.</p>
<p>Note: Your solution should be in logarithmic time complexity.</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个整数N，返回n的阶乘的结果中末尾0的个数。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>其实很简单，就是考的1-n中有几个5的因子，注意到5的次幂有不止1个因子5即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    int trailingZeroes(int n) {
        int count=0;
        while(n&gt;1)
        {
            count+=n/5;
            n/=5;
        }
       return count; 
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-102-Binary Tree Level Order Traversal]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-102-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>        3<br>       / \<br>      9  20<br>        /  \<br>       15   7<br>return its level order traversal as:<br>    [<br>      [3],<br>      [9,20],<br>      [15,7]<br>    ]<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵二叉树，返回层次遍历的结果。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>本题和<a href="/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/">这道题</a>一样，没什么好说的，很简单利用一个队列完成BFS操作。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; tem;
        if(!root) return res;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        q.push(NULL);
        while(!q.empty())
        {
            TreeNode* t=q.front();
            q.pop();
            if(t)
            {
                tem.push_back(t-&gt;val);
                if(t-&gt;left)
                    q.push(t-&gt;left);
                if(t-&gt;right)
                    q.push(t-&gt;right);
            }else{
                if(!q.empty())
                {
                    res.push_back(tem);
                    tem.clear();
                    q.push(NULL);
                }else{
                    res.push_back(tem);
                }
            }
        }
        return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-26-Remove Duplicates from Sorted Array]]></title>
      <url>http://since1992.org/2016/06/19/Leetcode-26-Remove-Duplicates-from-Sorted-Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个已排序的数组，去除重复元素， 然后返回新的长度，只能使用O(1)的额外空间。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单的一次遍历即可。当某个数比它前一个数大的时候说明它是新的一个未重复元素。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int count=0;
        if(nums.empty()) return count;
        count++;
        for(int i=1;i&lt;nums.size();i++)
        {
          if(nums[i]&gt;nums[i-1])
            nums[count++]=nums[i];
        }
        return count;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-118-Pascal's Triangle]]></title>
      <url>http://since1992.org/2016/06/18/Leetcode-118-Pascal-s-Triangle/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return</p>
<pre><code>[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</code></pre><a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数字N，生成前N行帕斯卡三角。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>至于什么是帕斯卡三角，可以参加<a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle" target="_blank" rel="external">维基百科</a>,找出规律以后写代码就容易了。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; ans;
        if(numRows&lt;=0) return ans;
        ans.resize(numRows);
        for(int i=0;i&lt;numRows;i++)
        {
            ans[i].resize(i+1,1);
            for(int j=1;j&lt;i;j++)
            ans[i][j]=ans[i-1][j]+ans[i-1][j-1];
        }
        return ans;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-232-Implement Queue using Stacks]]></title>
      <url>http://since1992.org/2016/06/18/Leetcode-232-Implement-Queue-using-Stacks/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Notes:<br>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>用栈实现队列的操作。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单，用两个栈即可取到任意一端的元素。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Queue {
    stack&lt;int&gt; s1;
    stack&lt;int&gt; s2;
public:
    // Push element x to the back of queue.
    void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        s2.pop();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }

    }

    // Get the front element.
    int peek(void) {
        while(!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
        int p = s2.top();
        while(!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }
        return p;
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return s1.empty();

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-66-Plus One]]></title>
      <url>http://since1992.org/2016/06/18/Leetcode-66-Plus-One/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个数组表示一个数字，返回它加一的结果。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单的一道题，注意进位的处理，以及全9的情况即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        int i = digits.size()-1;
        while(i&gt;=0)
        {
            if(digits[i]&lt;9){
                digits[i]++;
                return digits;
            }
            digits[i--]=0;

        }
        digits.insert(digits.begin(),1);
        return digits;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-342-Power of Four]]></title>
      <url>http://since1992.org/2016/06/18/Leetcode-342-Power-of-Four/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>
<p>Example:<br>Given num = 16, return true. Given num = 5, return false.</p>
<p>Follow up: Could you solve it without loops/recursion?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个32位的整数，判断它是否是4的幂。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>本体与<a href="/2016/06/07/Leetcode-231-Power-of-Two/">求2的幂</a>和<a href="/2016/06/07/Leetcode-326-Power-of-Tree/">求3的幂</a>类似，解法可参加这两题。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    bool isPowerOfFour(int num) {
        while(num&gt;1&amp;&amp;num%4==0)
        {
            num/=4;
        }
        return num==1;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-107-Binary Tree Level Order Traversal II]]></title>
      <url>http://since1992.org/2016/06/18/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>        3<br>       / \<br>      9  20<br>        /  \<br>       15   7<br>return its bottom-up level order traversal as:<br>    [<br>      [15,7],<br>      [9,20],<br>      [3]<br>    ]</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵二叉树，返回从底至顶的层次遍历结果。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用一个辅助队列完成BFS.再反向存储数组即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><p>/**</p>
<ul>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li>};<br>*/<br>class Solution {<br> public:<pre><code>vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
    vector&lt;int&gt; tem;
    vector&lt;vector&lt;int&gt;&gt; ans;
    queue &lt;TreeNode*&gt; q;
    if(!root) return ans;
    q.push(root);
    q.push(NULL);
    while(!q.empty())
    {
        TreeNode * t = q.front();
        q.pop();
        if(t){
            tem.push_back(t-&gt;val);
            if(t-&gt;left)
            q.push(t-&gt;left);
            if(t-&gt;right)
            q.push(t-&gt;right);
        }else
        {
            if(!q.empty()){
            ans.push_back(tem);
            tem.clear();
            q.push(NULL);}
            else
            ans.push_back(tem);
        }
    }
    vector&lt;vector&lt;int&gt;&gt; res;
    for(int i=ans.size()-1;i&gt;=0;i--)
    res.push_back(ans[i]);
    return res;
}
</code></pre> };</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-101-Symmetric Tree]]></title>
      <url>http://since1992.org/2016/06/16/Leetcode-101-Symmetric-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>But the following [1,2,2,null,3,null,3] is not:<br>        1<br>       / \<br>      2   2<br>       \   \<br>       3    3</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵树，检查它是否是中心对称的。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单，运用一个辅助函数检查两棵树是否对称即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isM(root-&gt;left,root-&gt;right);

    }
    bool isM(TreeNode* a,TreeNode* b)
    {
        if(!a&amp;&amp;!b) return true;
        if((a&amp;&amp;!b)||(b&amp;&amp;!a)) return false;
        if(a-&gt;val!=b-&gt;val) return false;
        return isM(a-&gt;left,b-&gt;right)&amp;&amp;isM(a-&gt;right,b-&gt;left);
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-27-Remove Element]]></title>
      <url>http://since1992.org/2016/06/16/Leetcode-27-Remove-Element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example:<br>Given input array nums = [3,2,2,3], val = 3</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组和一个特定的值，移除数组中所有该值，并返回剩余值的个数。你只能只用O(1)的额外空间，数字的顺序可以改变。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>本题和<a href="2016/05/23/Leetcode-283-Move-Zeroes/">这道题</a>很类似，只是删除特定的值而已。我们的策略就是把所有的特定值都移动到数组的末尾。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int p=0;
        for(int i=0;i&lt;nums.size();i++)
        {
            if(nums[i]!=val)
                swap(nums[i],nums[p++]);
        }
        return p;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-110-Balanced Binary Tree]]></title>
      <url>http://since1992.org/2016/06/12/Leetcode-110-Balanced-Binary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵二叉树，判断它是否平衡。一个平衡的二叉树的左右子树的深度差小于或等于1.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单的DFS问题，先判断左右子树是否为平衡二叉树，再判断它们的高度差是否在1以内。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        if(isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right))
            if(abs(height(root-&gt;left)-height(root-&gt;right))&lt;2)
                return true;
        return false;

    }
    int height(TreeNode* root)
    {
        if(!root) return 0;
        return 1+max(height(root-&gt;left),height(root-&gt;right));
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-24-Swap Nodes in Pairs]]></title>
      <url>http://since1992.org/2016/06/12/Leetcode-24-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>交换每一对链表的顺序。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>用一个递归的办法可以简单的完成这个问题，注意边界。 当然用非递归的办法也可以，不过写法并不够简洁，本文仅提供递归的解法。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head||!head-&gt;next) return head;
        ListNode * nextp = head-&gt;next-&gt;next;
        ListNode * tem = head-&gt;next;
        head-&gt;next = swapPairs(nextp);
        tem-&gt;next = head;
        return tem;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-198-House Robber]]></title>
      <url>http://since1992.org/2016/06/11/Leetcode-198-House-Robber/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>一排房子每个房子有一个价值，一个小偷进行偷窃，不可以连续偷挨着的两家，求小偷的最大收益。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>简单的一维动态规划问题。每个房子要么不偷，要么偷，如果不偷收益和前一个房子一样，如果偷则为前两个房子的最大收益加上这个房子的价值，两种情况下最大的收益即为到这个房子为止的最大收益。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return 0;
        vector&lt;int&gt; dp(nums.size(),0);
        dp[0]=nums[0];
        dp[1]=nums[0]&gt;nums[1]?nums[0]:nums[1];
        for(int i=2;i&lt;nums.size();i++)
        {
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp.back();
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-345-Reverse Vowels of a String]]></title>
      <url>http://since1992.org/2016/06/11/Leetcode-345-Reverse-Vowels-of-a-String/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p>Example 1:<br>Given s = “hello”, return “holle”.</p>
<p>Example 2:<br>Given s = “leetcode”, return “leotcede”.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>反转一个字符串中所有元音字母的位置。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>记录下来元音字母的顺序以及位置，在位置中倒序插入字母即可。当然也可以使用双指针，从头尾开始扫描，一旦扫描到两个元音字母，则交换他们，这种算法可以使得额外空间代价降低到O(1)。本文只提供第一种解法。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    string reverseVowels(string s) {
        vector&lt;char&gt; c;
        vector&lt;int&gt; p;
        for(int i=0;i&lt;s.length();i++)
        {
            if(isV(s[i]))
            {
                c.push_back(s[i]);
                p.push_back(i);
            }
        }
        for(int i=0;i&lt;p.size();i++)
        {
            s[p[i]]=c[c.size()-1-i];
        }
        return s;

    }
    bool isV(char x)
    {
        return x==&apos;a&apos;||x==&apos;e&apos;||x==&apos;i&apos;||x==&apos;o&apos;||x==&apos;u&apos;||x==&apos;A&apos;||x==&apos;E&apos;||x==&apos;I&apos;||x==&apos;O&apos;||x==&apos;U&apos;;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-21-Merge Two Sorted Lists]]></title>
      <url>http://since1992.org/2016/06/11/Leetcode-21-Merge-Two-Sorted-Lists/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>合并两个已排好序的单向链表</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>非常简单的链表基本操作，实现即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1) return l2;
        if(!l2) return l1;
        ListNode* l3;
        if(l1-&gt;val&lt;l2-&gt;val)
        {
            l3=l1;
            l3-&gt;next=mergeTwoLists(l1-&gt;next,l2);
        }else{
            l3=l2;
            l3-&gt;next=mergeTwoLists(l1,l2-&gt;next);
        }
        return l3;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-121-Best Time to Buy and Sell Stock]]></title>
      <url>http://since1992.org/2016/06/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有一个数组表示一段时间内某只股票每天的价格，如果你只能买卖一次，求你能获得的最大利润</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>依次找到最小值，然后再记录最大差值，返回最大差值即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if(prices.size()&lt;2) return 0;
        vector&lt;int&gt;dp(prices.size(),0);
        int max=INT_MIN;
        int min=prices[0];
        for(int i=1;i&lt;prices.size();i++)
        {
            if(prices[i]&lt;min) min=prices[i];
            dp[i]=prices[i]-min;
            if(dp[i]&gt;max)
            max=dp[i];

        }
        return max;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-153-Find Minimum in Rotated Sorted Array]]></title>
      <url>http://since1992.org/2016/06/10/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>某个排好序的数组从某一点开始到数组结尾，被全体移动到数组的最开始位置。求这个数组的最小值。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>求数组的最小值，一般情况下需要遍历一次数组，即用O(n)的时间，不过这道题给定的是预先排好序的数组，而且是被移动的是整个子序列，所以我们可以使用二分查找的办法，把时间复杂度缩短到O(logn)。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        if(nums.size()==1) return nums[0];
        int begin=0,end=nums.size()-1,mid=begin+(end-begin)/2;
        while(begin&lt;end)
        {
            if(nums[mid]&gt;nums[mid+1]) return nums[mid+1];
            else if(nums[mid]&lt;nums[end])
            {
                end=mid;
                mid=begin+(end-begin)/2;
            }
            else if(nums[mid]&gt;nums[end])
            {
                begin=mid;
                mid=begin+(end-begin)/2;
            }

        }
        return nums[end];

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-116-Populating Next Right Pointers in Each Node]]></title>
      <url>http://since1992.org/2016/06/10/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree</p>
<pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br>Given the following perfect binary tree,<br>             1<br>           /  \<br>          2    3<br>         / \  / \<br>        4  5  6  7<br>After calling your function, the tree should look like:<br>             1 -&gt; NULL<br>           /  \<br>          2 -&gt; 3 -&gt; NULL<br>         / \  / \<br>        4-&gt;5-&gt;6-&gt;7 -&gt; NULL<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一棵树添加右指针，每一行的末尾指向NULL。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>一个简单的DFS的问题，利用一个队列，完成层次遍历即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(!root) return;
        queue&lt;TreeLinkNode*&gt; q;
        q.push(root);
        q.push(NULL);
        while(!q.empty())
        {
            TreeLinkNode *tem = q.front();
            q.pop();

            if(tem)
            {
                tem-&gt;next=q.front();
                if(tem-&gt;left)
                    q.push(tem-&gt;left);
                if(tem-&gt;right)
                    q.push(tem-&gt;right);

            }
            else
            {
                if(!q.empty())
                {
                    q.push(NULL);
                    continue;
                }
                else break;
            }
        }

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-62-Unique Paths]]></title>
      <url>http://since1992.org/2016/06/10/Leetcode-62-Unique-Paths/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?<br><a href="http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png" target="_blank" rel="external"></a><br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>如图所示，机器人从最左上角走到最右下角，它只能往右或者往下走，求它有多少种不重复的走法。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>一个简单的二维动态规划问题。对于第一行和第一列来说，走到该格子只能沿着直线走，所以走到这些格子的方法数为1.而其他的格子，因为只能往右和往下走，那么第（i,j）格可以由（i,j-1）往下走一步或者(i-1,j)往右走一步达到，所以该格子的方法数应该是这辆格数字的和。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><p>class Solution {<br>    public:<br>        int uniquePaths(int m, int n) {<br>            vector<int> a(m,1);<br>            vector<vector<int>&gt; map;<br>            for(int i=0;i&lt;n;i++)<br>            map.push_back(a);<br>            for(int i=1;i&lt;n;i++)<br>                for(int j=1;j&lt;m;j++)<br>                    map[i][j]=map[i-1][j]+map[i][j-1];<br>            return map[n-1][m-1];<br>        }<br>    };</vector<int></int></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-89-Gray Code]]></title>
      <url>http://since1992.org/2016/06/10/Leetcode-89-Gray-Code/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<pre><code>00 - 0
01 - 1
11 - 3
10 - 2
</code></pre><p>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p>
<p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>灰码是指邻近的数字只有一位相差，输入一个数字，求出该数字位数相符的灰码序列。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>首先，对于什么是灰码，请参见<a href="https://en.wikipedia.org/wiki/Gray_code" target="_blank" rel="external">维基百科</a>。我觉得和<a href="/2016/05/23/Leetcode-338-Counting-Bits/">这道题</a>比较相似。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; grayCode(int n) {
            vector&lt;int&gt; res;
            res.push_back(0);
            for(int i=0;i&lt;n;i++)
                {
                    int high=1&lt;&lt;i;
                    int size=res.size();
                    for(int j=size-1;j&gt;=0;j--)
                        res.push_back(high+res[j]);
                }
            return res;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-53-Maximum Subarray]]></title>
      <url>http://since1992.org/2016/06/09/Leetcode-53-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<p>click to show more practice.</p>
<p>More practice:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>对于给定的一个数组，找出其子序列中和最大的一个。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>本题如果做动态规划，则复杂度为O(n)，对于当前和来讲，如果加上某个元素时和为负数，则舍弃。另用一个变量来储存历史中最大的和。注意考虑到最大和有可能是负数，初始化时应该把max初始化为INT_MIN.</p>
<p>Follow up: 如果想用分治法来解这道题，那么可以这样做：最大的和要么存在于前半个数组中，要么存在于后半个数组中，要么存在于中间往两边延伸。求出这三种情况的最大值中最大那个，即为我们所求。代码请读者自己完成。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int maxSubArray(vector&lt;int&gt;&amp; nums) {
            vector&lt;int&gt; dp(nums.size(),0);
            int sum=0;
            int max=INT_MIN;
            for(int i=0;i&lt;nums.size();i++)
                {
                       sum+=nums[i];
                       if(sum&gt;max)
                           max=sum;
                       if(sum&lt;0)
                           sum=0;
                }
            return max;

    }

};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-309-Best Time to Buy and Sell Stock With Cooldown]]></title>
      <url>http://since1992.org/2016/06/09/Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-With-Cooldown/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)<br>Example:</p>
<pre><code>prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
</code></pre><a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有一个数组表示第I天某只股票的价格。设计一个算法求出买卖这只股票的最大收益，买入之前必须先卖出，卖出后第二天不能进行买入操作。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>一个典型的动态规划问题。我们可以如下分析动态规划问题：<br>状态：买入，卖出，所以我们需要2个数组buy[n],sell[n]分别记录第N天如果买入/卖出，已经获得的最大收益。<br>状态转移方程：对于买入来说，如果今天没有买入，则获益和昨天一样（因为没有发生交易），如果今天买入了，则I-2天之前必须要卖出，则获益为sell[i-2]-price[i]，两种情况下最大值即为当天的buy[i]值（buy[i]=max(buy[i-1],sell[i-2]-prices[i]).<br>对于卖出来说，如果今天没有卖出，则收益和昨天一样（因为没有发生交易），以及如果昨天买入了，今天卖出，则总收益为sell[i-1]+prices[i]，两种情况下最大值即为当天的sell[i]值。而股票收益仅当你不持有股票时才能体现出来，所以我们要的值即为sell数组的最后一个值。<br>初始状态：对于两个数组来说，Buy[0]即第一天买入，收益当然为-prices[0],而buy[1]则表示按照低价买入，所以应当为前两天价格低者的相反数。对于Sell[0]而言，第一天因为之前没有持有股票，所以sell[0]=0，而sell[1]则表示第2天卖出股票的最大收益，那么如果第二天的股价低于第一天，则为0，若高于第一天，则为差价。<br>Follow up:<br>当然了，我们不难发现，状态方程里每天的收益仅仅和前两天的买入/卖出收益相关，所以我们可以improve我们的空间复杂度从O（n）到O(1)。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int maxProfit(vector&lt;int&gt;&amp; prices) {
            if(prices.size()&lt;2) return 0;
            vector&lt;int&gt; buy(prices.size(),0);
            vector&lt;int&gt; sell(prices.size(),0);
            buy[0]=-prices[0];
            buy[1]=max(-prices[0],-prices[1]);
            sell[0]=0;
            sell[1]=max(0,prices[1]-prices[0]);
            for(int i=2;i&lt;prices.size();i++)
                {
                    buy[i]=max(buy[i-1],sell[i-2]-prices[i]);
                    sell[i]=max(sell[i-1],buy[i-1]+prices[i]);
                }
            return sell.back();
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-350-Intersection of Two Arrays II]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-350-Intersection-of-Two-Arrays-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>
<p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.<br>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定两个数组，写一个函数来返回两个数组的交集，如果有重复的也需要返回。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>本题和<a href="/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/">这道题</a>略有不同。本题需要返回交集中的重复数字。其实类似于这类集合的交、并集问题，<a href="https://www.quora.com/Programming-Interview-Questions-How-do-you-find-out-intersection-between-two-arrays-when-they-are-sorted-when-they-are-not-sorted" target="_blank" rel="external">这篇文章</a>讲的非常详细，推荐读一读。一个简单的算法，先对数组进行排序，然后使用双指针，当遍历完短数组后结束。这样复杂度为O(nlogn+mlogm)。如果是已排好序的数组，或者某一个数组已排好序，可以对未排序数组的每个元素在已排序数组里进行二分查找，复杂度为O(m*logn).本文提供排序后双指针的解法。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
            vector&lt;int&gt; res;
            if(nums1.empty()||nums2.empty()) return res;
            sort(nums1.begin(),nums1.end());
            sort(nums2.begin(),nums2.end());
            int i=0,j=0;
               while(i&lt;nums1.size()&amp;&amp;j&lt;nums2.size())
                   {
                       if(nums1[i]==nums2[j]){
                         res.push_back(nums1[i]);
                         i++;
                         j++;
                   }
                       else if(nums1[i]&gt;nums2[j]) j++;
                       else i++;
           }
               return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-141-Linked List Cycle]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-141-Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a linked list, determine if it has a cycle in it.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个链表，判断它是否包含一个环</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>环链表的特征很多，最常用的判断方法是双指针法。让快慢两个指针同时在链表中遍历，如果存在环，那么两个指针一定会相遇。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        bool hasCycle(ListNode *head) {
            if(!head||!head-&gt;next) return false;
            ListNode* fast=head-&gt;next;
            ListNode* slow=head;
            while(slow&amp;&amp;fast&amp;&amp;slow!=fast)
                {
                    if(fast-&gt;next)
                        fast=fast-&gt;next-&gt;next;
                    else return false;
                    slow=slow-&gt;next;
                }
            return slow==fast;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-70-Climbing Stairs]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-70-Climbing-Stairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>你在爬一个楼梯，每一步要么爬一阶要么爬两阶，求爬到楼梯的顶部有多少种方法。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>一个简单的动态规划问题，后面的每一步都是前两个数的和，因为要么爬一阶要么爬两阶，那么除开最后一步，就变成和子问题一样的问题了。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int climbStairs(int n) {
            vector&lt;int&gt; res(n+1);
            res[0]=1;
            res[1]=1;
            for(int i=2;i&lt;=n;i++)
                res[i]=res[i-1]+res[i-2];
            return res[n];

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-202-Happy Number]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-202-Happy-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>快乐数的定义是这样的，循环做这个步骤：把某个正整数的每个位上的数字的平方相加。当这个循环包含了1的时候，它就是快乐数，判断一个数字是不是快乐数。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>根据快乐数的定义，利用一个哈希表来记录出现过的数字，一旦出现循环，如果不是在1的地方循环，则这个数不是快乐数。很简单的题，细心，争取bugfree.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isHappy(int n) {
            set&lt;int&gt; s;
            int sum=helper(n);
            while (s.find(sum)==s.end())
                {
                    s.insert(sum);
                    sum=helper(sum);
                }
            return sum==1;

            }
        int helper(int n)
            {
                int res=0;
                while(n&gt;0)
                    {
                        res+=((n%10)*(n%10));
                        n/=10;
                    }
                return res;
                }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-263-Ugly Number]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-263-Ugly-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<p>Credits:<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>丑数是指那些只有2，3，5作为质因子的数字，判断一个数是不是丑数。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>循环剔除所有2，3，5因子，看剩下的是否是1.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isUgly(int num) {
            if(num==0) return false;
            while(num%5==0)
                num/=5;
            while(num%3==0)
                num/=3;
            while(num%2==0)
                num/=2;
            return num==1;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-83-Remove Duplicates from Sorted List]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-83-Remove-Duplicates-from-Sorted-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个已排序的链表，删除所有重复的结点。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>遍历整个链表，发现某个结点的下一个结点的值和它一样时，把它的下一个结点指向再后一个结点。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* deleteDuplicates(ListNode* head) {
                ListNode* p = head;
                if(!head) return head;
                while(p&amp;&amp;p-&gt;next)
                    {
                        if(p-&gt;val==p-&gt;next-&gt;val) 
                            p-&gt;next=p-&gt;next-&gt;next;
                        else
                            p=p-&gt;next;
                    }
                return head;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-231-Power of Two]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-231-Power-of-Two/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer, write a function to determine if it is a power of two.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个整数，判断是否是2的整数幂。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>和<a href="/2016/06/07/Leetcode-326-Power-of-Tree/">这道题</a>类似，只是判断是否是2的整数幂。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isPowerOfTwo(int n) {
            while(n&gt;1)
                {
                    if(n%2&gt;0) return false;
                    n/=2;
                }
            return n==1;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-326-Power of Tree]]></title>
      <url>http://since1992.org/2016/06/07/Leetcode-326-Power-of-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer, write a function to determine if it is a power of three.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个整数，判断它是不是3的幂</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>简单的循环，判断最后是否得到1.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isPowerOfThree(int n) {

            while(n&gt;1)
                {
                    if(n%3&gt;0) return false;
                    n/=3;
                }
            return n==1;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-337-House Robber III]]></title>
      <url>http://since1992.org/2016/05/27/Leetcode-337-House-Robber-III/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>一个树状的结构里，两个相邻的父，子结点不可以被同时偷，求盗贼的最大收益。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题可以使用动态规划,使用一个辅助函数返回是否抢该节点的两个收益最大值。动态转移方程为，左右均不偷+根节点或者偷左右不偷根节点，取最大值。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int rob(TreeNode* root) {
            vector&lt;int&gt; res = helper(root);
            return max(res[0],res[1]); 
    }

        vector&lt;int&gt; helper(TreeNode* root)
            {
                vector&lt;int&gt; res(2,0);
                if(!root) return res;
                vector&lt;int&gt; left = helper(root-&gt;left);
                vector&lt;int&gt; right = helper(root-&gt;right);
                res[0]= max(left[1],left[0])+max(right[1],right[0]);
                res[1]= left[0]+right[0]+root-&gt;val;
                return res;
            }

    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-22-Generate Parentheses]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-22-Generate-Parentheses/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数字，返回该数字对括号能产生的所有合法括号组合。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>使用回溯法，生成所有组合。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;string&gt; generateParenthesis(int n) {
            vector&lt;string&gt; res;
            string tem;
            helper(res,tem,0,0,n);
            return res;

        }
        void helper(vector&lt;string&gt;&amp;res,string&amp; s,int left,int right,int n)
            {
                if(left==n&amp;&amp;right==n) {res.push_back(s);}

                if(left&lt;n) {s.push_back(&apos;(&apos;); helper(res,s,left+1,right,n);s.pop_back();}
                if(right&lt;left) {s.push_back(&apos;)&apos;); helper(res,s,left,right+1,n);s.pop_back();}

            }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-35-Search Insert Position]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-35-Search-Insert-Position/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个排好序的数组和一个值，返回它的下标，如果它在数组里，否则，则返回该值应该被插入的位置。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>找到第一个大于该值的位置，返回之前一个位置。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
            if(target&lt;nums[0]) return 0;
            if(target&gt;nums[nums.size()-1]) return nums.size();
            for(int i=0;i&lt;nums.size();i++)
                {
                    if(nums[i]==target) return i;
                    else if(nums[i]&lt;target) continue;
                    else if(nums[i-1]&lt;target) return i;  
                }
            return 0;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-108-Convert Sorted Array to Binary Search Tree]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个已排序数组，把它转化成一个平衡BST。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用DFS和递归调用函数生成。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
            return helper(nums,0,nums.size()-1);
    }
        TreeNode* helper(vector&lt;int&gt; &amp;nums,int begin,int end)
                {
                if(begin&gt;end) return NULL;
                if(begin==end) return new TreeNode(nums[begin]);
                int mid = begin + (end-begin)/2;
                 TreeNode* res = new TreeNode(nums[mid]);
                 res-&gt;left = helper(nums,begin,mid-1);
                 res-&gt;right = helper(nums,mid+1,end);
                 return res;
                }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-235-Lowest Common Ancester of a Binary Search Tree]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-235-Lowest-Common-Ancester-of-a-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>找到两个节点的最低相同祖先。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>先求出两条路径，再找到最后一个相同元素即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            vector&lt;TreeNode*&gt; p1;
            vector&lt;TreeNode*&gt; q1;
            findpath(p1,p,root);
            findpath(q1,q,root);
            for(int i=p1.size()-1;i&gt;=0;i--)
                {
                    if(find(q1.begin(),q1.end(),p1[i])!=q1.end())
                        return p1[i];
                }
            return NULL;


        }
        void findpath(vector&lt;TreeNode*&gt;&amp; path,TreeNode* p, TreeNode* root)
            {
                TreeNode* current = root;
                while(current-&gt;val!=p-&gt;val)
                    {
                        path.push_back(current);
                        if(current-&gt;val&gt;p-&gt;val)
                            current=current-&gt;left;
                        else current=current-&gt;right;
                        }
                path.push_back(p);
            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-96-Unique Binary Search Trees]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-96-Unique-Binary-Search-Trees/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个数字，求有多少个不同的二叉搜索树。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用动态规划，两边的可能性相乘的和即为总数。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int numTrees(int n) {
            vector&lt;int&gt; ans(n+1,0);
            ans[0]=1;
            ans[1]=1;
            for(int i=2;i&lt;=n;i++)
                {
                    for(int j=0;j&lt;=i;j++)
                        ans[i]+=ans[j]*ans[i-j-1];
                   }
            return ans[n];
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-137-Single Number II]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-137-Single-Number-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>一个数组中每个元素都出现了3次除了一个只出现了一次，找到这个元素。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用2个哈希表，第一次出现就放入第一个，第二次出现把第一个表里删除再插入第二个表，第三次出现把第二个表里删除。这样那个单独元素就会在第一个哈希表里。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int singleNumber(vector&lt;int&gt;&amp; nums) {
            set&lt;int&gt; first;
            set&lt;int&gt; second;
            for(int i=0;i&lt;nums.size();i++)
                {
                    if(second.find(nums[i])!=second.end()){
                        second.erase(nums[i]);
                    }else
                        {
                            if(first.find(nums[i])!=first.end())
                                    {
                                    first.erase(nums[i]);
                                    second.insert(nums[i]);
                                }else first.insert(nums[i]);
                        }
                }
            return *first.begin();

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-230-Kth Smallest Element in a BST]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-230-Kth-Smallest-Element-in-a-BST/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>Hint:</p>
<p>Try to utilize the property of a BST.<br>What if you could modify the BST node’s structure?<br>The optimal runtime complexity is O(height of BST).<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个BST,找出第K小的元素。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>先遍历一次，按顺序存下来，再返回特定坐标即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int kthSmallest(TreeNode* root, int k) {
            stack&lt;TreeNode*&gt; st;
            vector&lt;int&gt; ans;
            while(!st.empty()||root)
                {
                    while(root)
                        {
                            st.push(root);
                            root=root-&gt;left;
                        }
            TreeNode* tem=st.top();
            ans.push_back(tem-&gt;val);
            st.pop();
            if(tem-&gt;right)
                root=tem-&gt;right;

                    }
            return ans[k-1];

    }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-328-Odd Even Linked List]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-328-Odd-Even-Linked-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,<br>return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</p>
<p>Note:<br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个单向链表，返回所有奇数结点，再接上所有偶数结点。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>先分别构建两个子串，再连起来。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* oddEvenList(ListNode* head) {
            if(!head||!head-&gt;next) return head;
            ListNode* odd=head;
            ListNode* eve=head-&gt;next;
            ListNode* tem=eve;
            while(odd-&gt;next&amp;&amp;eve-&gt;next)
                {
                    odd-&gt;next=eve-&gt;next;
                    eve-&gt;next=odd-&gt;next-&gt;next;
                    if(odd-&gt;next)
                        odd=odd-&gt;next;
                    if(eve-&gt;next)
                        eve=eve-&gt;next;
                }
            odd-&gt;next=tem;
            eve-&gt;next=NULL;
            return head;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-287-Find the Duplicate Number]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-287-Find-the-Duplicate-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有一个大小为n+1的数组，数字均在1-n之间，证明一定至少有一个重复的数字，假设只有一个重复数字，找到它。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题有许多种解法。如果数组不能被改动，则可以利用二分查找，统计不大于mid的数个数，如果超过mid个，则这个重复的数字一定在1-mid之间，否则在mid-n之间。<br>如果数组可以被改动，可以使用循环标记的算法，把每个数字的值作为下标，标负，当发现标负的值的时候，该值即为重复值。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int findDuplicate(vector&lt;int&gt;&amp; nums) {
            int begin=1,end=nums.size()-1;
            int mid= begin+(end-begin)/2;
            while(end-begin&gt;0)
                {
                    if(helper(nums,mid))
                        {
                            end=mid;
                            mid=begin+(end-begin)/2;
                        }else
                            {
                                begin=mid+1;
                                mid=begin+(end-begin)/2;
                            }
                }
            return begin;

        }
        bool helper(vector&lt;int&gt;&amp; nums, int target)
            {
                int count = 0;
                    for(int i=0;i&lt;nums.size();i++)
                    if(nums[i]&lt;=target) count++;
                        return count&gt;target;
            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-12-Integer to Roman]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-12-Integer-to-Roman/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>把十进制数字转化为罗马数字。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>先找到不同的转化点，再依次转化</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        string intToRoman(int num) {
            string res=&quot;&quot;;
            int nums[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};
            string s[13]={&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};
            for(int i=0;i&lt;=13;i++)
                {
                    if(num&gt;=nums[i])
                        {
                            for(int j=0;j&lt;num/nums[i];j++)
                                res+=s[i];
                                num%=nums[i];
                        }
                }
            return res;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-13-Roman to Integer]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-13-Roman-to-Integer/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个罗马数字，1-3999内，求对应的十进制数字</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单，如果左边的比右边的小，说明左边的需要减去，右边的比左边的小或者相等就累加</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int romanToInt(string s) {
            if(s.length()==0) return 0;
            if(s.length()==1) return letter2int(s[0]);
            int res=letter2int(s[0]);
            for(int i=1;i&lt;s.length();i++)
                {
                    if(letter2int(s[i])&gt;letter2int(s[i-1]))
                        res+=letter2int(s[i])-2*letter2int(s[i-1]);
                    else res+=letter2int(s[i]);
                }
            return res;

        }
        int letter2int(char a)
            {
                switch(a)
                    {
                        case &apos;I&apos;: return 1;
                        case &apos;V&apos;: return 5;
                        case &apos;X&apos;: return 10;
                        case &apos;L&apos;: return 50;
                        case &apos;C&apos;: return 100;
                        case &apos;D&apos;: return 500;
                        case &apos;M&apos;: return 1000;
                        default : return 0;
                    }
            }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-94-Binary Tree Inorder Traversal]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-94-Binary-Tree-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>           1<br>        \<br>         2<br>        /<br>           3<br>return [1,3,2].<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>中序遍历一个二叉树</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>用递归的办法做很简单，这里选择一个辅助栈，用非递归的方法完成中序遍历。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&lt;int&gt; inorderTraversal(TreeNode* root) {
            stack&lt;TreeNode*&gt; s;
            vector&lt;int&gt; res;
            while(!s.empty()||root)
                {
                    s.push(root);
                    while(root-&gt;left)
                        {
                            s.push(root-&gt;left);
                            root=root-&gt;left;
                        }
                    while(!s.empty())
                        {
                            root=s.top();
                            s.pop();
                            res.push_back(root-&gt;val);
                    if(root-&gt;right)
                        {
                            root=root-&gt;right;
                            break;
                        }else root=NULL;
                        }
                }
            return res;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-206-Reverse Linked List]]></title>
      <url>http://since1992.org/2016/05/26/Leetcode-206-Reverse-Linked-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Reverse a singly linked list.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>反转一个单向链表</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>有许多方法可以反转一个单向链表，这里我们选择把每个结点都放在头结点之后一次，再从尾部连接头结点，最后再断环。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* reverseList(ListNode* head) {
            if(!head||!head-&gt;next) return head;
            ListNode * current = head-&gt;next;
            ListNode * next;
            while(current-&gt;next)
                {
                    next = current-&gt;next;
                    current-&gt;next=next-&gt;next;
                    next-&gt;next=head-&gt;next;
                    head-&gt;next=next;
                }
            current-&gt;next=head;
            ListNode *newhead=head-&gt;next;
            head-&gt;next=NULL;
            return newhead;   
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-144-Binary Tree Preorder Traversal]]></title>
      <url>http://since1992.org/2016/05/24/Leetcode-144-Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>       1<br>      \<br>         2<br>        /<br>         3<br>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>二叉树前序遍历。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>如果用递归做这道题很简单，这里本文提供一种非递归的解法。利用一个辅助栈，既然是先序遍历，那么右子树应该先入栈，接着是左子树。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&lt;int&gt; preorderTraversal(TreeNode* root) {
            stack&lt;TreeNode*&gt; s;
            vector&lt;int&gt; res;
            while(!s.empty()||root)
                {

                    if(root)
                        {
                            res.push_back(root-&gt;val);
                            if(root-&gt;right)
                                s.push(root-&gt;right);
                            root=root-&gt;left;
                        }
                    else{
                            root=s.top();
                            s.pop();
                        }
                }
            return res;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-268-Missing Number]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-268-Missing-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>For example,<br>Given nums = [0, 1, 3] return 2.</p>
<p>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一个n个互异整数组成的数组，其中少掉了一个数字，求这个数字。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题有很多解法。对于O(n)的解法，可以求出和，再减去每个数字。对于位运算来说就是求所有的异或再与完整数组异或一次。本文给出数学的解法。<br>如果是排好序的数组，可以利用二分查找进而把复杂度降低到O（lgn）</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int missingNumber(vector&lt;int&gt;&amp; nums) {
            int n=nums.size();
            int res=n*(n+1)/2;
            for(int i=0;i&lt;n;i++)
            res-=nums[i];

                return res;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-343-Integer Break]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-343-Integer-Break/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>
<p>Note: you may assume that n is not less than 2.</p>
<p>Hint:</p>
<p>There is a simple O(n) solution to this problem.<br>You may check the breaking results of n ranging from 7 to 10 to discover the regularities.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个正整数，把它拆分成至少2个正整数的和，然后求这些正整数的乘积的最大值。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>通过动态规划可以很简单的得出状态转移方程，当n为4以下的时候，只能拆分为1和n-1，4以上时，拆分为2，n-2或者3，n-3时，能够获得最大乘积。（其实这个稍微感觉一下，就是幂函数的增长速度是最快的一样）</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int integerBreak(int n) {
            vector&lt;int&gt; dp(n+1);
            if(n&lt;4) return n-1;
            dp[2]=2;
            dp[3]=3;
            for(int i=4;i&lt;=n;i++)
                dp[i]=max(dp[i-2]*2,dp[i-3]*3);

            return dp[n];
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-319-Bulb Switcher]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-319-Bulb-Switcher/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.</p>
<p>Example:</p>
<pre><code>Given n = 3. 

At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 

So you should return 1, because there is only one bulb is on.
</code></pre><a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n个开关，第i次操作你拨动所有i整数倍序号的开关。问最后有几盏灯留下了。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>任何一个开关都会被拨动偶数次，除非它是一个完全平方数，本题目即是求不大于n的完全平方数有几个</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int bulbSwitch(int n) {
               return sqrt(n);

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-169-Majority Element]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-169-Majority-Element/</url>
      <content type="html"><![CDATA[<p>Problem Description:<br>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<h2 id="You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array"><a href="#You-may-assume-that-the-array-is-non-empty-and-the-majority-element-always-exist-in-the-array" class="headerlink" title="You may assume that the array is non-empty and the majority element always exist in the array."></a>You may assume that the array is non-empty and the majority element always exist in the array.</h2><a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个数组，里面有一个元素出现了至少⌊ n/2 ⌋次，找到这个元素。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>排序以后中间的那个元素肯定是所求元素。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int majorityElement(vector&lt;int&gt;&amp; nums) {
            sort(nums.begin(),nums.end());
            return nums[nums.size()/2];
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-217-Contains Duplicate]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-217-Contains-Duplicate/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，找出其是否包含重复元素。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>简单的利用一个哈希表存储所有未重复数字，当发现重复数字即可返回true,否则返回false</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
            set&lt;int&gt; s;
            for(int i=0;i&lt;nums.size();i++){
                if(s.find(nums[i])!=s.end()) return true;
                else s.insert(nums[i]);
            }
            return false;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-171-Excel Sheet Column Number]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-171-Excel-Sheet-Column-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
</code></pre><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>简单的26进制转化问题。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int titleToNumber(string s) {
            int res=0;
            int high=s.length()-1;
            for(int i=0;i&lt;s.length();i++)
                res+=pow(26,high-i)*(s[i]-&apos;A&apos;+1);

            return res;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-242-Valid Anagram]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-242-Valid-Anagram/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
<a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定两个字符串，判定它们是否是异构体（即包含相同的字符）</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用哈希表，把字符串放入数组中排序，如果是异构体则排序后结果应该相同。或者利用两个向量变量统计每个字母出现的次数，看是否相同。本文给出第一种解法，第二种请读者自己完成。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isAnagram(string s, string t) {
            if(s.length()!=t.length()) return false;
            vector&lt;char&gt;a;
            vector&lt;char&gt;b;
            for(int i=0;i&lt;s.length();i++)
                {
                    a.push_back(s[i]);
                    b.push_back(t[i]);
                }
            sort(a.begin(),a.end());
            sort(b.begin(),b.end());
            for(int i =0;i&lt;a.size();i++)
                if(a[i]!=b[i]) return false;
            return true;


            return true;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-122-Best Time to Buy and Sell Stock II]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>你有一个数组表示某只股票每天的市值，设计一个算法求出你过了这些天之后能够赚到的最大利润（再次买入之前必须售出）</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用贪心算法，只要是任何两天之内有的价值增加都能被加入总收益之中。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int maxProfit(vector&lt;int&gt;&amp; prices) {
            int max=0;
            for(int i=1;i&lt;prices.size();i++)
                prices[i]-prices[i-1]&gt;0?max+=prices[i]-prices[i-1]:max+=0;
            return max;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-238-Product of Array Except Self]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-238-Product-of-Array-Except-Self/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it without division and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，输出为其他数组中所有其他元素的乘积，不能使用除法，时间复杂度应为O(n)</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>使用动态规划，遍历2次数组，求出左边所有元素的乘积和右边所有元素的乘积，再把它们相乘即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
            vector&lt;int&gt; res;
            if(nums.empty()) return res;
               vector&lt;int&gt; productleft(nums.size(),1);
            vector&lt;int&gt; productright(nums.size(),1);
            for(int i =1;i&lt;nums.size();i++)
                   productleft[i]=productleft[i-1]*nums[i-1];
            for(int j=nums.size()-2;j&gt;=0;j--)
                productright[j]=productright[j+1]*nums[j+1];
            for(int i =0;i&lt;nums.size();i++)
                res.push_back(productleft[i]*productright[i]);
            return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-100-Same Tree]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-100-Same-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定两个二叉树，写一个函数来检查它们是否相同。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>递归调用函数，检查左右子树以及根节点的值是否相同。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        bool isSameTree(TreeNode* p, TreeNode* q) {
            if(!p&amp;&amp;!q) return true;
            if((p&amp;&amp;!q)||(!p&amp;&amp;q)) return false;
            return (p-&gt;val==q-&gt;val)&amp;&amp;isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-237-Delete Node in a Linked List]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-237-Delete-Node-in-a-Linked-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>删除一个链表中的结点，你只能获取该结点的指针。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>有点像脑筋急转弯。很简单，将这个结点的next结点拷贝到这个结点就可以了。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        void deleteNode(ListNode* node) {
            node-&gt;val=node-&gt;next-&gt;val;
            node-&gt;next=node-&gt;next-&gt;next;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-260-Single Number III]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-260-Single-Number-III/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，其中有两个元素只出现了一次，其他的元素出现了2次，找出这两个只出现过一次的元素。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>第一步与<a href="/2016/05/23/Leetcode-136-Single-Number/">simgle number I</a> 一样，先求出所有的数字的^结果，此时假设这两个数是a和b,那么我们已经得到了a^b的结果。那么我们如何将这两个数分开呢。^运算的结果是同位相等为0，不等为1.那么我们就可以找出a和b不相等的最低位，然后把原数组分成两个子数组，接着使用我们<a href="/2016/05/23/Leetcode-136-Single-Number/">simgle number I</a> 中使用的方法即可求解两个数。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
            int tem = 0;
            for(int i=0;i&lt;nums.size();i++)
                tem^=nums[i];
            int last = tem-(tem&amp;(tem-1));//求出tem中最低“1”位
            int first = 0; int second = 0;
            for(int i=0;i&lt;nums.size();i++)
                {
                    if(nums[i]&amp;last)
                        first^=nums[i];
                    else
                        second^=nums[i];
                }
            vector&lt;int&gt; ans;
            ans.push_back(first);
            ans.push_back(second);
            return ans;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-283-Move Zeroes]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-283-Move-Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，写一个函数把所有的0都移动到数组的末端且非0元素的相对位置不变。<br>你没有额外的存储空间来复制一遍数组。且使移动操作次数最少。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>用一个指针指向第一个0的坐标，如果不是0，则交换0坐标上的数字与当前数字</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        void moveZeroes(vector&lt;int&gt;&amp; nums) {
            int mark = 0;
            for(int i =0;i&lt;nums.size();i++)
                {
                    if(nums[i]!=0)
                           swap(nums[i],nums[mark++]);     
                }

            }
        };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-349-Intersection of Two Arrays]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>找到两个集合的交集，并且注意交集中每个元素只能出现一次。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单的hash map的题，遍历a中每一个元素，只要在b中出现的，如果没有添加过，则添加到结果集合中。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        vector&lt;int&gt; res;
        if(!nums1.empty()||!nums2.empty())
            for(int i=0;i&lt;nums1.size();i++)
                {
                    if(find(nums2.begin(),nums2.end(),nums1[i])!=nums2.end())//if nums1[i] is in nums2
                        if(find(res.begin(),res.end(),nums1[i])==res.end())// if nums[i] not in res
                            res.push_back(nums1[i]);
                }
            return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-226-Invert Binay Tree]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-226-Invert-Binay-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Invert a binary tree.</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>to</p>
<pre><code>      4
    /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><a id="more"></a>        
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>反转一个二叉树</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>递归调用函数本身即可，注意边界条件。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
           TreeNode* invertTree(TreeNode* root) {
            if(!root) return root;
            if(!root-&gt;left&amp;&amp;!root-&gt;right) return root;
            else{
                TreeNode* teml = invertTree(root-&gt;right);
                TreeNode* temr = invertTree(root-&gt;left);
                root-&gt;left= teml;
                root-&gt;right=temr;
                return root;
                    }

            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-104-Maximum Depth of Binary Tree]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个二叉树，返回它的最大深度</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>递归调用本函数，返回左右子树的最大深度中较大值+1即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int maxDepth(TreeNode* root) {
            if(!root) return 0;
            else
                return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-258-Add Digits]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-258-Add-Digits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个非负整数，重复累加它的每一位，直到生成的新数字只有一位。<br>例如：38-》3+8=11-》1+1=2.此时返回2.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这里提供两种方法，第一种是正常的循环解题思路，另一种是数学的方法。数学方法请参见<a href="https://en.wikipedia.org/wiki/Digital_root" target="_blank" rel="external">这篇wiki文章</a>.循环解法只需要按照题目要求累加每一位数字即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int addDigits(int num) {
            switch(num)
                {
                    case 0: return 0;
                    default: return (num-1)%9+1;
                }
            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-136-Single Number]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-136-Single-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers, every element appears twice except for one. Find that single one.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，其中除了某一个数字以外其他数字都出现过两次，找出这个数字。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题方法有许多，这里本文介绍最简单的一种，使用位运算，一个数字a^b^b以后仍然为它本身。这样，把整个数组^一次即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int singleNumber(vector&lt;int&gt;&amp; nums) {
            int res=0;
            for(int i=0;i&lt;nums.size();i++)
                res^=nums[i];

            return res;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-292-Nim Game]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-292-Nim-Game/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>你和朋友玩一个取石子的游戏，每一个人可以取1-3个石子，假如你们俩都能每一步做出最优选择，那么当你先取的时候，输入一个石子数，返回你是否能取得胜利。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题仔细分析其实并不难。当石子数为4的整数倍的时候，总是后手胜利，因为不管先手拿走了n(1-3)枚石子，你总是拿走4-n枚，即可获胜，其他情况下，先手可以把自己变为后手，即取走余数。所以想通了这一点之后这道题变得非常简单。即判断先手是否胜利的条件在于石子数能否被4整除。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool canWinNim(int n) {
            return n%4;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-191-Number of 1 Bits]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-191-Number-of-1-Bits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>写一个函数，返回某一数字二进制表示中1出现的次数</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用位运算中&amp;操作符号，和指定数的每一位都单独&amp;一次，如果是1，则会返回1，再使用一个计数器实现统计。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int hammingWeight(uint32_t n) {
            int count=0;
            for(int i=0;i&lt;32;i++)
                if(n&amp;1&lt;&lt;i) count++;

            return count;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-338-Counting Bits]]></title>
      <url>http://since1992.org/2016/05/23/Leetcode-338-Counting-Bits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>输入一个数字，输出从0开始到该数字为止的所有数字二进制表示中1的个数.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>对于最基本的解题思路，如果使用O(n*sizeof(integer))的时间的话,可以写一个统计某个数之中出现“1”的次数的函数，正如<a href="/2016/05/23/Leetcode-191-Number-of-1-Bits/">这一题</a>，然后从0开始循环调用N次。<br>但是我们通过观察二进制的规律不难发现，除了2的整数次幂只有一个1以外，每多一位，立马会从0开始到这个数字为止全部重复一次。动态规划转移方程为a[n]=1(如果n为2的整数次幂)，a[n]=1+a[mark] （mark为我们的标记）我们用两个标记变量，一个表示2的整数次幂，另一个表示已经循环到的数字，每次经过2的整数次幂后，该标记归0。这样便能把时间复杂度降低为O(n)，而且只用使用O(n)的额外空间。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; countBits(int num) {
            vector&lt;int&gt; res(num+1);
            if(num==0) return res;
            else {

                res[0]=0;
                int power=1;
                int mark=1;
                for(int i =1;i&lt;=num;i++)
                    {
                        if(i==power)
                            {
                                    res[i]=1;
                                    power&lt;&lt;=1;
                                    mark=1;
                            }else
                        {
                              res[i]=1+res[mark];
                              mark++;
                        }
                    }
                }
            return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-344-Reverse String]]></title>
      <url>http://since1992.org/2016/05/22/Leetcode-344-Reverse-String/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:<br>Given s = “hello”, return “olleh”.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>反转一个给定字符串</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>简单的倒序添加每一个字符即可</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    string reverseString(string s) {
        string res=&quot;&quot;;
        for(int i = 0; i&lt;s.length();i++)
        res=s[i]+res;

        return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://since1992.org/2015/10/20/Hello-World/</url>
      <content type="html"><![CDATA[<p>由于上一次惨痛的经历。。。重装系统忘记备份博客源码。我决定使用Time Machine。。。没啥好说的，心情十分复杂，就这样。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[随手小记]]></title>
      <url>http://since1992.org/2015/10/15/%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>今天终于刷完了Leetcode最后一道我能做的Easy难度。明天就要迈向Medium了。想到Z君说的easy 5分钟一道，我还是太年轻了么果然。。。加油吧。。。坚持就是胜利！逐渐成为一个合格的码农！不过通过这两周来的训练，我觉得我自己的代码能力确实有了一个很大的提升。No pains, no gains.加油吧。从0到1比从1到2难多了，非常庆幸自己能迈出第一步。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Latex使用经验1——用bibtex添加引用]]></title>
      <url>http://since1992.org/2015/10/02/Latex%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C1%E2%80%94%E2%80%94%E7%94%A8bibtex%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>用bibtex添加引用</p>
<h2 id="第一步：建立一个tex文件"><a href="#第一步：建立一个tex文件" class="headerlink" title="第一步：建立一个tex文件"></a>第一步：建立一个tex文件</h2><p>任何一种你想要方法建立一个tex文件，假如说叫a.tex</p>
<p>在文章末尾\end{document}之前加入以下三行：<br>\renewcommand\refname{Reference}<br>\bibliographystyle{plain}<br>\bibliography{b}<br>其中第一行是参考文献的标题，标题是Reference；第二行是格式，还有其他格式见此处，这里用plain；第三行是一个bib格式文件的名字，最好和tex文件名称一致，编译起来方便一些。<br>(有一点小小要注意的地方：最常见的引用格式是plain，它是按作者字母排序的，如果要按引用顺序来排序，推荐用格式unsrt)</p>
<h2 id="第二步：建立一个bib文件"><a href="#第二步：建立一个bib文件" class="headerlink" title="第二步：建立一个bib文件"></a>第二步：建立一个bib文件</h2><p>bib文件就是一个plain text文件，明明为b.bib，bib格式可以在各种数据库里面的citation找到，例如<br>@book{Book1,<br>title = “Title1”,<br>author = “author1”,<br>publisher = “publisher1”,<br>year = “2015”<br>}</p>
<h2 id="第三步：在tex文件中引用"><a href="#第三步：在tex文件中引用" class="headerlink" title="第三步：在tex文件中引用"></a>第三步：在tex文件中引用</h2><p>在需要引用的地方使用\cite{Book1},期中Book1是你在bib文件中给每个引用的名字</p>
<h2 id="第四步：运行-tex文件"><a href="#第四步：运行-tex文件" class="headerlink" title="第四步：运行.tex文件"></a>第四步：运行.tex文件</h2><p>可以直接运行texshop里面的排版或者用命令行 pdflatex a(a是咱们.tex文件的名字)</p>
<h2 id="第五步：运行-bib文件"><a href="#第五步：运行-bib文件" class="headerlink" title="第五步：运行.bib文件"></a>第五步：运行.bib文件</h2><p>用bibtex b(b是咱们.bib文件的名字)，注意：一定要先运行pdflatex命令，因为运行后会生成aux文件，而编译bib是需要aux文件的、</p>
<h2 id="第六步：运行-tex文件2次"><a href="#第六步：运行-tex文件2次" class="headerlink" title="第六步：运行.tex文件2次"></a>第六步：运行.tex文件2次</h2><p>对，你没看错，运行2次，才能正确生成引用和引用目录，原理我也不知道，就这么用就行了！pdflatex a 这个命令运行2次就行了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[今天的月亮很美]]></title>
      <url>http://since1992.org/2015/10/01/%E4%BB%8A%E5%A4%A9%E7%9A%84%E6%9C%88%E4%BA%AE%E5%BE%88%E7%BE%8E/</url>
      <content type="html"><![CDATA[<p>前几天中秋节，在美帝幸运地看到了血月和月全食之后。突然想起了夏目漱石问学生如何翻译“i love you”这个问题。他给学生的答案是“今天的月亮很美”。想起曾经和人谈论过这个问题，当时觉得有种听到“今天的风儿真是喧嚣”的感觉。其实我觉得我现在能理解了这种观点。就仿佛是我期待着下雪，想到下雪后的第一件事就是拍张照片，然后告诉某人，“下雪了”，这是一样的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableView上方总是有一截留白的解决方法]]></title>
      <url>http://since1992.org/2015/09/29/TableView%E4%B8%8A%E6%96%B9%E6%80%BB%E6%98%AF%E6%9C%89%E4%B8%80%E6%88%AA%E7%95%99%E7%99%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>不知道从哪个版本（大概是iOS8）开始，如果你用了autolayout，当你设置某个tableview（或者任意scrollview）顶部约束为顶格的适合，它总会多出来一个留白，其实解决方法很简单，在该viewcontroller的.m文件中把automaticallyAdjustsScrollViewInsets这个属性设置成false就可以了。鬼知道谁设计的留白。。。</p>
]]></content>
    </entry>
    
  
  
</search>
