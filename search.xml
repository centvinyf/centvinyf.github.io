<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Leetcode-191-Number of 1 Bits]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-191-Number-of-1-Bits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>写一个函数，返回某一数字二进制表示中1出现的次数</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用位运算中&amp;操作符号，和指定数的每一位都单独&amp;一次，如果是1，则会返回1，再使用一个计数器实现统计。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int hammingWeight(uint32_t n) {
            int count=0;
            for(int i=0;i&lt;32;i++)
                if(n&amp;1&lt;&lt;i) count++;

            return count;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-338-Counting Bits]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-338-Counting-Bits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>输入一个数字，输出从0开始到该数字为止的所有数字二进制表示中1的个数.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>对于最基本的解题思路，如果使用O(n*sizeof(integer))的时间的话,可以写一个统计某个数之中出现“1”的次数的函数，正如<a href="/2016/05/23/Leetcode-191-Number-of-1-Bits/">这一题</a>，然后从0开始循环调用N次。<br>但是我们通过观察二进制的规律不难发现，除了2的整数次幂只有一个1以外，每多一位，立马会从0开始到这个数字为止全部重复一次。动态规划转移方程为a[n]=1(如果n为2的整数次幂)，a[n]=1+a[mark] （mark为我们的标记）我们用两个标记变量，一个表示2的整数次幂，另一个表示已经循环到的数字，每次经过2的整数次幂后，该标记归0。这样便能把时间复杂度降低为O(n)，而且只用使用O(n)的额外空间。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; countBits(int num) {
            vector&lt;int&gt; res(num+1);
            if(num==0) return res;
            else {

                res[0]=0;
                int power=1;
                int mark=1;
                for(int i =1;i&lt;=num;i++)
                    {
                        if(i==power)
                            {
                                    res[i]=1;
                                    power&lt;&lt;=1;
                                    mark=1;
                            }else
                        {
                              res[i]=1+res[mark];
                              mark++;
                        }
                    }
                }
            return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-344-Reverse String]]></title>
      <url>http://yoursite.com/2016/05/22/Leetcode-344-Reverse-String/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:<br>Given s = “hello”, return “olleh”.</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>反转一个给定字符串</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>简单的倒序添加每一个字符即可</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    string reverseString(string s) {
        string res=&quot;&quot;;
        for(int i = 0; i&lt;s.length();i++)
        res=s[i]+res;

        return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录84-Minimum Path Sum]]></title>
      <url>http://yoursite.com/2015/10/29/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9584-Minimum-Path-Sum/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>A simple 2D dynamic programming problem</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
            int m=grid[0].size();
            int n=grid.size();
            int solution[n][m];
            solution[0][0]=grid[0][0];
            for(int i=1;i&lt;m;i++)
                solution[0][i]=solution[0][i-1]+grid[0][i];
            for(int j=1;j&lt;n;j++)
                solution[j][0]=solution[j-1][0]+grid[j][0];

            for(int j=1;j&lt;n;j++)
                for(int i=1;i&lt;m;i++)
                    solution[j][i]=min(solution[j-1][i],solution[j][i-1])+grid[j][i];

            return solution[n-1][m-1];

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录83-Swap Nodes in Pairs]]></title>
      <url>http://yoursite.com/2015/10/27/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9583-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>exchange every pair. remember to keep the pre of next pair.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* swapPairs(ListNode* head) {
            if(!head||!head-&gt;next) 
                return head;
            ListNode * a= head;
            ListNode * b= a-&gt;next;
            ListNode * newhead =b;
            ListNode* pre= new ListNode(-1);
            pre-&gt;next=head;
            while(b&amp;&amp;a)
                {
                    a-&gt;next=b-&gt;next;
                    b-&gt;next=a;
                    pre-&gt;next=b;
                    pre=a;
                    a=a-&gt;next;
                    if(a)
                    b=a-&gt;next;
                    else break;
                }
            return newhead;
       }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录82-Sort Colors]]></title>
      <url>http://yoursite.com/2015/10/27/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9582-Sort-Colors/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p>
<p>click to show follow up.</p>
<p>Follow up:<br>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p>
<p>Could you come up with an one-pass algorithm using only constant space?</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><p>A typical counting sort problem. </p>
<h2 id="Code-in-C-for-Solution-1"><a href="#Code-in-C-for-Solution-1" class="headerlink" title="Code in C++ for Solution 1:"></a>Code in C++ for Solution 1:</h2><pre><code>class Solution {
    public:
        void sortColors(vector&lt;int&gt;&amp; nums) {
            int numof0=0;
            int numof1=0;
            int numof2=0;
            for(int i=0;i&lt;nums.size();i++)
                {
                    switch(nums[i])
                        {
                            case 0 : numof0++;break;
                            case 1 : numof1++;break;
                            case 2 : numof2++;break;
                            default: break;
                           }
                   }
            for(int i=0;i&lt;numof0;i++)
                nums[i]=0;
            for(int j=0;j&lt;numof1;j++)
                nums[j+numof0]=1;
            for(int k=numof0+numof1;k&lt;nums.size();k++)
                nums[k]=2;

        }
};
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>Using two pointers to seprate those parts.</p>
<h2 id="Code-in-C-for-Solution-2"><a href="#Code-in-C-for-Solution-2" class="headerlink" title="Code in C++ for Solution 2:"></a>Code in C++ for Solution 2:</h2><pre><code>class Solution {
    public:
        void sortColors(vector&lt;int&gt;&amp; nums) {
            int indexof0=0;
            int indexof2=nums.size()-1;
            int i=0;
            while(i&lt;=indexof2)
                {
                    if(nums[i]==0)
                        {
                            swap(nums[i],nums[indexof0]);
                            indexof0++;
                            i++;
                        }
                    else if(nums[i]==2)
                        {
                            swap(nums[i],nums[indexof2]);
                            indexof2--;
                        }
                    else i++;
            }

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录81-Best Time to Buy and Sell Stock]]></title>
      <url>http://yoursite.com/2015/10/27/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9581-Best-Time-to-Buy-and-Sell-Stock/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>This problem is very similar to <a href="/2015/10/25/Leetcode刷题记录77-Maximum-Subarray/">This problem</a>.Just change the array into the change array.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int maxProfit(vector&lt;int&gt;&amp; prices) {
            if(prices.empty()) 
                return 0;
            int change[prices.size()];
            change[0]=0;
            for(int i=1;i&lt;prices.size();i++)
                change[i]=prices[i]-prices[i-1];
            int res=INT_MIN;
               int sum=0;
            for(int i=0;i&lt;prices.size();i++){
                sum= sum&gt;=0? sum+change[i]:change[i];
                res=max(res,sum);
        }
            return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录80-Unique Paths]]></title>
      <url>http://yoursite.com/2015/10/27/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9580-Unique-Paths/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Descriptions"><a href="#Problem-Descriptions" class="headerlink" title="Problem Descriptions:"></a>Problem Descriptions:</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<h2 id="Solutions-1"><a href="#Solutions-1" class="headerlink" title="Solutions 1:"></a>Solutions 1:</h2><p>Using recursive call. It’s like the <a href="/2015/10/10/Leetcode刷题记录34-Climbing-Stairs/">Climbing stairs problem</a>.</p>
<h2 id="Code-in-C-for-Solution-1"><a href="#Code-in-C-for-Solution-1" class="headerlink" title="Code in C++ for Solution 1:"></a>Code in C++ for Solution 1:</h2><pre><code>class Solution {
    public:
        int uniquePaths(int m, int n) {
            if(m==1||n==1) return 1;
            else return uniquePaths(m-1,n)+uniquePaths(m,n-1);

    }
};
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>Using a map to record the best solutions(using dynamic programming)</p>
<h2 id="Code-in-C-for-Solution-2"><a href="#Code-in-C-for-Solution-2" class="headerlink" title="Code in C++ for Solution 2:"></a>Code in C++ for Solution 2:</h2><pre><code>class Solution {
       public:
           int uniquePaths(int m, int n) {
           int a[m][n];
           for(int i=0;i&lt;m;i++)
                a[i][n-1]=1;
           for(int i=0;i&lt;n;i++)
               a[m-1][i]=1;
           for(int i=m-2;i&gt;=0;i--)
               for(int j=n-2;j&gt;=0;j--)
                   a[i][j]=a[i+1][j]+a[i][j+1];
           return a[0][0];
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录79-Find Minimum]]></title>
      <url>http://yoursite.com/2015/10/27/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9579-Find-Minimum/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using binary search</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int findMin(vector&lt;int&gt;&amp; nums) {
            int begin =0;
            int end = nums.size()-1;
            int mid =begin+(end-begin)/2;
            if(nums[end]&gt;nums[begin]) return nums[begin];
            while(end-begin&gt;1)
                {
                    if(nums[mid-1]&gt;nums[mid])
                        return nums[mid];
                    else if(nums[mid]&lt;nums[begin])
                        {
                            end = mid ;
                            mid = begin + (end-begin)/2;
                        }
                    else if (nums[mid]&gt;nums[begin])
                        {
                            begin = mid;
                            mid = begin + (end-begin)/2;
                        }
                }
            return min(nums[end],nums[begin]);

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录78-Convert Sorted Array to Binary Search Tree]]></title>
      <url>http://yoursite.com/2015/10/25/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9578-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Do it recursively. use mid element to be the root.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
            vector&lt;int&gt; a;
            vector&lt;int&gt; b;
            int mid=nums.size()/2;
            for(int i=0;i&lt;mid;i++)
            a.push_back(nums[i]);
            for(int i=mid+1;i&lt;nums.size();i++)
            b.push_back(nums[i]);
            if(nums.size()==0) 
                return NULL;
            else if(nums.size()==1)
                {
                    TreeNode* t= new TreeNode(nums[0]);
                    return t;
                }
            else
                {
                       TreeNode* root =new TreeNode(nums[mid]);
                       root-&gt;left= sortedArrayToBST(a);
                       root-&gt;right=sortedArrayToBST(b);
                       return root;
                }
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录77-Maximum Subarray]]></title>
      <url>http://yoursite.com/2015/10/25/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9577-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Descriptions"><a href="#Problem-Descriptions" class="headerlink" title="Problem Descriptions:"></a>Problem Descriptions:</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Once the sum is less than 0, start from the current element.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int maxSubArray(vector&lt;int&gt;&amp; nums) {
            int res=INT_MIN;
            int sum=0;
            for(int i=0;i&lt;nums.size();i++){
                sum= sum&gt;=0? sum+nums[i]:nums[i];
                res=max(res,sum);
            }
        return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录76-Integer to Roman]]></title>
      <url>http://yoursite.com/2015/10/25/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9576-Integer-to-Roman/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Like coin pick problems, just use greedy algorithm</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        string intToRoman(int num) {
            string res=&quot;&quot;;
            int a[13]={1000,900,500,400,100,90,50,40,10,9,5,4,1};
            string x[13]={&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};
            for(int i=0;i&lt;13;i++)
                {
                    if(num&gt;=a[i])
                        {
                            for(int j=0;j&lt;num/a[i];j++)
                                res+=x[i];
                                num%=a[i];
                        }
                }
            return res;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录75-Search Insert Position]]></title>
      <url>http://yoursite.com/2015/10/25/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9575-Search-Insert-Position/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using binary search</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
            int begin =0;
            int end = nums.size()-1;
            int mid = begin+(end-begin)/2;
            while(end-begin&gt;1)
                    {
                    if(nums[mid]==target) 
                        return mid;
                    else if(nums[mid]&gt;target)
                        {
                            end=mid;
                            mid=begin+(end-begin)/2;
                            continue;
                        }
                    else if(nums[mid]&lt;target)
                        {
                            begin=mid;
                            mid=begin+(end-begin)/2;
                            continue;
                        }
                }
            if(target&lt;=nums[begin])return begin;
            if(target&gt;nums[end]) return end+1;
            return end;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录74-Unique Binary Search Tree]]></title>
      <url>http://yoursite.com/2015/10/25/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9574-Unique-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title=" Solutions:"></a> Solutions:</h2><p> A unique binary search tree using i as root in n nodes are (0~i-1) in the left and (i+1~n) in the right. So we can do a dynamic programming.</p>
<p> Updates:<br> You can see from <a href="https://en.wikipedia.org/wiki/Catalan_number" target="_blank" rel="external">here</a> . This kind of number is called “Catalan number”.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title=" Code in C++:"></a> Code in C++:</h2><pre><code>class Solution {
    public:
        int numTrees(int n) {
            int res[n+1]={0};
            res[0]=1;
            res[1]=1;
            for(int i=2;i&lt;=n;i++)
                    for(int j=0;j&lt;i;j++)
                      res[i]+=res[j]*res[i-1-j];
            return res[n];
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录73-Missing Number]]></title>
      <url>http://yoursite.com/2015/10/24/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9573-Missing-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>For example,<br>Given nums = [0, 1, 3] return 2.</p>
<p>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><p>If we have O(n) extra space. we can mark every appeard element.</p>
<h2 id="Code-in-C-for-Solution-1"><a href="#Code-in-C-for-Solution-1" class="headerlink" title="Code in C++ for Solution 1:"></a>Code in C++ for Solution 1:</h2><pre><code>class Solution {
    public:
        int missingNumber(vector&lt;int&gt;&amp; nums) {
            bool flag[nums.size()+1];
            for(int i=0;i&lt;nums.size();i++) 
                flag[i]=false;
            for(int i=0;i&lt;nums.size();i++)
                flag[nums[i]]= true;
            for(int i=0;i&lt;nums.size();i++)
                if(!flag[i]) return i;
            return nums.size();

    }
};
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>We can add the total number and minus every element.</p>
<h2 id="Code-in-C-for-Solution-2"><a href="#Code-in-C-for-Solution-2" class="headerlink" title="Code in C++ for Solution 2:"></a>Code in C++ for Solution 2:</h2><pre><code>class Solution {
    public:
        int missingNumber(vector&lt;int&gt;&amp; nums) {
            int res=nums.size();
            for(int i=0;i&lt;nums.size();i++)
                res += (i-nums[i]);
            return res;

    }
};
</code></pre><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3:"></a>Solution 3:</h2><p>Use Bit Manipulation(which I don’t know very well)</p>
<h2 id="Code-in-C-for-Solution-3"><a href="#Code-in-C-for-Solution-3" class="headerlink" title="Code in C++ for Solution 3:"></a>Code in C++ for Solution 3:</h2><pre><code>class Solution {
    public:
        int missingNumber(vector&lt;int&gt;&amp; nums) {
            int res = 0;
            for (int i = 0; i &lt; nums.size(); ++i) {
                res ^= (i + 1) ^ nums[i];
        }
            return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录72-Populating Next Right Pointers in Each Node]]></title>
      <url>http://yoursite.com/2015/10/24/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9572-Populating-Next-Right-Pointers-in-Each-Node/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree</p>
<pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br>Given the following perfect binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \  / \<br>    4  5  6  7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \  / \<br>    4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title=" Solutions:"></a> Solutions:</h2><p> It’s very like <a href="/2015/10/15/Leetcode刷题记录64-Binary-Tree-Level-Order-Traversal/">This Problem</a></p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title=" Code in C++:"></a> Code in C++:</h2><pre><code> /**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
    public:
        void connect(TreeLinkNode *root) {
            queue&lt;TreeLinkNode*&gt; a;
            if(root)
                {
                    TreeLinkNode* pre=NULL;
                    a.push(root);
                    a.push(NULL);
                    while(!a.empty())
                        {
                            TreeLinkNode* t=a.front();
                            a.pop();
                            if(t)
                                {
                                    if(t-&gt;left)
                                        a.push(t-&gt;left);
                                    if(t-&gt;right)
                                        a.push(t-&gt;right);
                                    if(pre) 
                                        pre-&gt;next = t;
                                    pre=t;                                 
                                }
                            else{
                                    if(!a.empty())
                                        {
                                            a.push(NULL);
                                            if(pre) 
                                                pre-&gt;next=NULL;
                                            pre=NULL;
                                        }
                                }

                        }
                }

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录71-Linked List Cycle]]></title>
      <url>http://yoursite.com/2015/10/24/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9571-Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><p>If we can have extra space</p>
<h2 id="Code-in-C-for-Solution-1"><a href="#Code-in-C-for-Solution-1" class="headerlink" title="Code in C++ for Solution 1:"></a>Code in C++ for Solution 1:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        bool hasCycle(ListNode *head) {
            set&lt;ListNode*&gt; s;
            ListNode*a = head;
            while(a)
                {
                    if(s.find(a)!=s.end()) 
                        return true;
                    else 
                        {
                               s.insert(a);
                               a=a-&gt;next;
                        }

                }
            return false;

        }        
    };
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>If we don’t have extra space. We can have two pointers, once there being a cycle, they will meet.</p>
<h2 id="Code-in-C-for-Solution-2"><a href="#Code-in-C-for-Solution-2" class="headerlink" title="Code in C++ for Solution 2:"></a>Code in C++ for Solution 2:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        bool hasCycle(ListNode *head) {
            if(!head) 
                return false;
            ListNode *a = head;
            ListNode *b = NULL;
            if(a-&gt;next)
                b=a-&gt;next;
            while(a&amp;&amp;b)
                {
                       if(a==b) 
                           return true;
                       else
                           {
                               if(b-&gt;next) 
                                   b=b-&gt;next-&gt;next;
                               else 
                                   return false;
                               a=a-&gt;next;
                           }

                }
            return false;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录70-Binary Search Tree InOrder Traversal]]></title>
      <url>http://yoursite.com/2015/10/24/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9570-Binary-Search-Tree-InOrder-Traversal/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,3,2].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>It’s like <a href="/2015/10/24/Leetcode刷题记录69-Binary-Search-Tree-PreOrder-Traversal/">This Problem</a> </p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&lt;int&gt; inorderTraversal(TreeNode* root) {
                vector&lt;int&gt; res;
            stack&lt;TreeNode*&gt; s;
            TreeNode*p = root;
            while(p||!s.empty())
                {
                    while(p)
                        {
                            s.push(p);
                            p=p-&gt;left;
                        }
                    if(!s.empty())
                        {
                               res.push_back(s.top()-&gt;val);
                               p=s.top()-&gt;right;
                               s.pop();
                        }
                }
            return res;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录69-Binary Tree Preorder Traversal]]></title>
      <url>http://yoursite.com/2015/10/24/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9569-Binary-Search-Tree-PreOrder-Traversal/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Use a stack to store the pre nodes.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&lt;int&gt; preorderTraversal(TreeNode* root) {
            vector&lt;int&gt; res;
            TreeNode* p = root;
            stack&lt;TreeNode*&gt; s;
            while(!s.empty()||p)
                {
                    while(p)
                        {
                            s.push(p);
                            res.push_back(p-&gt;val);
                            p=p-&gt;left;
                        }
                    if(!s.empty())
                        {
                            p=s.top()-&gt;right;
                            s.pop();
                        }
                }
            return res;

            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2015/10/20/Hello-World/</url>
      <content type="html"><![CDATA[<p>由于上一次惨痛的经历。。。重装系统忘记备份博客源码。我决定使用Time Machine。。。没啥好说的，心情十分复杂，就这样。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录68-Product Of Array Except Self]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9568-Product-Of-Array-Except-Self/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it without division and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>To record everything’s product from left and from right and make a product.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
               vector&lt;int&gt; left(nums.size(),1);
               for(int i=1;i&lt;left.size();i++)
                   left[i]= left[i-1]*nums[i-1];
               vector&lt;int&gt; right(nums.size(),1);
               for(int i=right.size()-2;i&gt;=0;i--)
                   right[i]=right[i+1]*nums[i+1];
               vector&lt;int&gt; res(nums.size(),1);
               for(int i=0;i&lt;res.size();i++)
                   res[i]=left[i]*right[i];
               return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录67-Single Number III]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9567-Single-Number-III/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using a set to store unique items.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
            set&lt;int&gt; s;
            s.clear();
            for(int i=0;i&lt;nums.size();i++)
                {
                    if(s.find(nums[i])!=s.end())
                        s.erase(nums[i]);
                    else 
                        s.insert(nums[i]);
                }
            vector&lt;int&gt; res;
            res.push_back(*s.begin());
            s.erase(*s.begin());
            res.push_back(*s.begin());
            return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录66-Best Time to Buy and Sell Stock II]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9566-Best-Time-to-Buy-and-Sell-Stock-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>buy at lowest price and sell when it has a higher price.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int maxProfit(vector&lt;int&gt;&amp; prices) {
            int total=0;
            if(prices.size()==0) 
                return total;
            int buy=prices[0];
            int sell=prices[0];
            int i=0;

            while(i&lt;prices.size())
                {
                    if(prices[i]&lt;buy) 
                        {
                            buy=prices[i];sell=prices[i]; 
                            i++;
                            continue;
                        }
                    else if(prices[i]&gt;sell) 
                        {
                            sell=prices[i];
                            total+=(sell-buy);
                            buy=prices[i];
                            i++;
                            continue;
                        }
                    else i++;
                }
            return total;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录65-Binary Tree Level Order Traversal-II]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9565-Binary-Tree-Level-Order-Traversal-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>        3<br>       / \<br>       9 20<br>         / \<br>        15 7<br>return its bottom-up level order traversal as:<br>    [<br>        [15,7],<br>        [9,20],<br>        [3]<br>    ]</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>It’s very similar as This Problem. Just remember to rotate the result vector.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
            vector&lt;vector&lt;int&gt;&gt; res ;
            if(!root) 
                return res;
            vector&lt;int&gt; tem;
            queue&lt;TreeNode*&gt; q;
            q.push(root);
            q.push(NULL);
            while(!q.empty())
                {
                    TreeNode* t=q.front();
                    q.pop();
                    if(t!=NULL)
                        {
                            tem.push_back(t-&gt;val);
                            if(t-&gt;left) 
                                q.push(t-&gt;left);
                            if(t-&gt;right) 
                                q.push(t-&gt;right);
                        }
                    else
                        {
                            res.push_back(tem);
                            if(!q.empty())
                                {
                                    tem.clear();
                                    q.push(NULL);
                                }

                        }
                }
            vector&lt;vector&lt;int&gt;&gt; result;
            for(int i=res.size()-1;i&gt;=0;i--)
                result.push_back(res[i]);

            return result;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录64-Binary Tree Level Order Traversal]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9564-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Descriptions"><a href="#Problem-Descriptions" class="headerlink" title="Problem Descriptions:"></a>Problem Descriptions:</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>      3<br>     / \<br>     9 20<br>       / \<br>       15 7<br>return its level order traversal as:<br>    [<br>        [3],<br>        [9,20],<br>        [15,7]<br>    ]</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Use a NULL node to mark every level.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
            vector&lt;vector&lt;int&gt;&gt; res ;
            if(!root) 
                return res;
            vector&lt;int&gt; tem;
            queue&lt;TreeNode*&gt; q;
            q.push(root);
            q.push(NULL);
            while(!q.empty())
                {
                    TreeNode* t=q.front();
                    q.pop();
                    if(t!=NULL)
                        {
                            tem.push_back(t-&gt;val);
                            if(t-&gt;left) 
                                q.push(t-&gt;left);
                            if(t-&gt;right) 
                                q.push(t-&gt;right);
                        }
                    else
                        {
                            res.push_back(tem);
                            if(!q.empty())
                                {
                                    tem.clear();
                                    q.push(NULL);
                                }

                        }
                }
            return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[随手小记]]></title>
      <url>http://yoursite.com/2015/10/15/%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>今天终于刷完了Leetcode最后一道我能做的Easy难度。明天就要迈向Medium了。想到Z君说的easy 5分钟一道，我还是太年轻了么果然。。。加油吧。。。坚持就是胜利！逐渐成为一个合格的码农！不过通过这两周来的训练，我觉得我自己的代码能力确实有了一个很大的提升。No pains, no gains.加油吧。从0到1比从1到2难多了，非常庆幸自己能迈出第一步。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录63-String to INteger(atoi)]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9563-String-to-INteger-atoi/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Be very careful and think about all the cases.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int myAtoi(string str) {
            int flag=1;
            int res=0;
            int i=0;
            while(i&lt;str.length()&amp;&amp;str[i]==&apos; &apos;) 
                i++;
            if(str[i]==&apos;+&apos;)
                {
                    flag=1;
                    i++;
                }
            else if(str[i]==&apos;-&apos;)
                {
                    flag=-1;
                    i++;
                }
            while(i&lt;str.length())
                {
                    if(str[i]&lt;&apos;0&apos;||str[i]&gt;&apos;9&apos;) 
                        break;
                    if((flag==1&amp;&amp;res==INT_MAX/10&amp;&amp;str[i]-&apos;0&apos;&gt;=7)||(flag==1&amp;&amp;res&gt;INT_MAX/10)) 
                        return INT_MAX;
                    if((flag==-1&amp;&amp;-res==INT_MIN/10&amp;&amp;str[i]-&apos;0&apos;&gt;=8)||(flag==-1&amp;&amp;-res&lt;INT_MIN/10)) 
                        return INT_MIN;
                    res=res*10+str[i]-&apos;0&apos;;
                    i++;
                }

            return res*flag;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录62-Compare Version Number]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9562-Compare-Version-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Compare two version numbers version1 and version2.<br>If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:</p>
<pre><code>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37
</code></pre><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Compare each part seprately, if one ends first, set the rest to 0</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int compareVersion(string version1, string version2) {
            int len1=version1.size();
            int len2=version2.size();
            int i=0;
            int j=0;
            while(i&lt;len1||j&lt;len2)
                {
                    int a=0;
                    int b=0;
                    while(i&lt;len1&amp;&amp;version1[i]!=&apos;.&apos;)
                        a=a*10+version1[i++]-&apos;0&apos;;
                    i++;
                    while(j&lt;len2&amp;&amp;version2[j]!=&apos;.&apos;)
                        b=b*10+version2[j++]-&apos;0&apos;;
                    j++;
                    if(a&gt;b) 
                        return 1;
                    else if(a&lt;b) 
                        return -1;
                }
            return 0;

        }    
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录61-Excel Sheet Column Title]]></title>
      <url>http://yoursite.com/2015/10/15/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9561-Excel-Sheet-Column-Title/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB
</code></pre><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Just pay attention to those boader cases.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        string convertToTitle(int n) {
            string res=&quot;&quot;;
            char current;
            while(n&gt;0)
                {
                    if(n%26==0) 
                        {
                            current=&apos;Z&apos;;
                            n--;
                        }
                    else
                        current=(char)((n-1)%26+&apos;A&apos;);
                    res=current+res;
                    n/=26;
                }


            return res;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录60-First Bad Version]]></title>
      <url>http://yoursite.com/2015/10/14/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9560-First-Bad-Version/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Desctiption"><a href="#Problem-Desctiption" class="headerlink" title="Problem Desctiption:"></a>Problem Desctiption:</h2><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using binary search, but mid=start+(end-start)/2 instead of mid = (start+end)/2.</p>
<h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates:"></a>Updates:</h2><p>Why cannot use mid=(start+end)/2?<br>Because that may be beyond the range of int.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
    public:
        int firstBadVersion(int n) {
            int start = 1;
            int end = n;
            int mid = start+(end-start)/2;
            while(end-start&gt;1)
                {
                       if(isBadVersion(mid))
                        {
                            end = mid;
                            mid= start+(end-start)/2;
                        }
                    else
                        {
                            start =mid+1;
                            mid = start+(end-start)/2;
                        } 

                }
            if(isBadVersion(start))
                return start;
            else 
                return end;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录59-Summary Ranges]]></title>
      <url>http://yoursite.com/2015/10/14/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9559-Summary-Ranges/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Descriptions"><a href="#Problem-Descriptions" class="headerlink" title="Problem Descriptions:"></a>Problem Descriptions:</h2><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>use tags to mark every range.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {
            vector&lt;string&gt; res;
            int i=0;
            while(i&lt;nums.size())
                {
                    int j=1;
                    while(i+j&lt;nums.size()&amp;&amp;nums[i+j]-nums[i]==j) 
                        j++;
                    res.push_back(j==1? to_string(nums[i]):to_string(nums[i])+&quot;-&gt;&quot;+to_string(nums[i+j-1]));
                    i+=j;
                }
            return res;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录58-Counting Primes]]></title>
      <url>http://yoursite.com/2015/10/13/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9558-Counting-Primes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Count the number of prime numbers less than a non-negative number, n.</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><p>using a function to determine if a number is prime, but the solution would time out when n reaches 1500000</p>
<h2 id="Code-in-C-for-Solution-1"><a href="#Code-in-C-for-Solution-1" class="headerlink" title="Code in C++ for Solution 1:"></a>Code in C++ for Solution 1:</h2><pre><code>class Solution {
    public:
        bool isPrime(int x)
            {
                if(x==2||x==3) 
                    return true;
                else
                    {
                        int tem=2;
                        while(tem*tem&lt;=x)
                            {
                                if(x%tem==0) 
                                    return false;
                                else
                                    tem++;
                            }
                        return true;
                    }

            }
        int countPrimes(int n) {
            if(n&lt;=2) 
                return 0;
            else
                {
                    int res =0;
                    for(int i=2;i&lt;=n-1;i++)
                        {
                            if(isPrime(i)) 
                                res++;
                        }
                    return res;
                }
            }

    };
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>Using Sieve of Eratosthenes.</p>
<p>It marks everytime when a number can be divided by one prime. The left is those primes;</p>
<h2 id="Code-in-C-for-Solution-2"><a href="#Code-in-C-for-Solution-2" class="headerlink" title="Code in C++ for Solution 2:"></a>Code in C++ for Solution 2:</h2><pre><code>class Solution {
    public:
        int countPrimes(int n) {
                bool mark[n];
            for(int i=2;i&lt;n;i++)
                mark[i]=false;//init the mark arry
            for(int i=2;i&lt;n;i+=2)
                mark[i]=true;//mark all even numbers
                mark[2]=false;//unmark 2
            for(int i=3;i&lt;n;i+=2)
                {
                    if(mark[i]==false)//for unmarked elements
                        {
                            if(i*i&gt;n) 
                                break;//left numbers are all odd
                            else
                                {
                                    for(int j=2;j*i&lt;n;j++)//mark the times of the current biggeset prime
                                        mark[i*j]=true;
                                }
                        }
                }
            int count=0;
            for(int i=2;i&lt;n;i++)//count
                {
                    if(mark[i]==false)
                        count++;
                    }

            return count;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录57-Implement Stack Using Queue]]></title>
      <url>http://yoursite.com/2015/10/13/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9557-Implement-Stack-Using-Queue/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Implement the following operations of a stack using queues.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>empty() – Return whether the stack is empty.<br>Notes:<br>You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.<br>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.<br>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using a loop.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Stack {
    public:
        queue&lt;int&gt; q;
        queue&lt;int&gt; tem;
        // Push element x onto stack.
        void push(int x) 
            {
                q.push(x);
            }

        // Removes the element on top of the stack.
        void pop() 
            {
                int n=q.size();
                  for(int i=0;i&lt;n-1;i++)  
                      {
                          q.push(q.front());
                          q.pop();
                      }
                  q.pop();
            }

        // Get the top element.
        int top() 
            {
                int n=q.size();
                  for(int i=0;i&lt;n-1;i++)  
                      {
                          q.push(q.front());
                          q.pop();
                      }                
                  int res=q.front();
                  q.push(q.front());
                  q.pop();
                  return res;
            }

        // Return whether the stack is empty.
        bool empty() 
            {
                return q.empty();

            }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录56-Implement Queue Using Stack]]></title>
      <url>http://yoursite.com/2015/10/13/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9556-Implement-Queue-Using-Stack/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Implement the following operations of a queue using stacks.</p>
<p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Notes:<br>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using two stacks.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Queue {
    public:
        stack&lt;int&gt; s;
        stack&lt;int&gt;tem;
        // Push element x to the back of queue.
        void push(int x) 
            {
                 s.push(x);   
            }

        // Removes the element from in front of queue.
        void pop(void) 
            {
                while(!s.empty())
                    {
                        tem.push(s.top());
                        s.pop();
                    }
                tem.pop();
                   while(!tem.empty())
                    {
                            s.push(tem.top());
                        tem.pop();
                    }

            }

        // Get the front element.
        int peek(void)
             {
                 while(!s.empty())
                    {
                           tem.push(s.top());
                        s.pop();
                    }
                int res=tem.top();
                while(!tem.empty())
                    {
                            s.push(tem.top());
                        tem.pop();
                    }
                return res;
            }

        // Return whether the queue is empty.
        bool empty(void) 
            {
                   return s.empty(); 
            }

    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录55-MIN Stack]]></title>
      <url>http://yoursite.com/2015/10/13/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9555-MIN-Stack/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Descriptions"><a href="#Problem-Descriptions" class="headerlink" title="Problem Descriptions:"></a>Problem Descriptions:</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using two arrays to store the elements;</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class MinStack {
    public:
        void push(int x) 
            {
                if(min.size()==0) 
                    min.push_back(x);
                else if(x&lt;min.back()) 
                    min.push_back(x); 
                else 
                    min.push_back(min.back());
                a.push_back(x);
            }

        void pop() 
            {
                 min.pop_back();
                a.pop_back();
            }

        int top() 
            {
                   return a.back();
            }

        int getMin() 
            {
                return min.back();
            }
    private:
        vector&lt;int&gt; a;
        vector&lt;int&gt;min;
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录54-Rotate Array]]></title>
      <url>http://yoursite.com/2015/10/13/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9554-Rotate-Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Pay attention to the situation that k might &gt; nums.size()</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        void rotate(vector&lt;int&gt;&amp; nums, int k) {
            vector&lt;int&gt; tem;
            k%=nums.size();
            for(int i=nums.size()-k;i&lt;=nums.size()-1;i++)
                {
                    tem.push_back(nums[i]);
                }
            for(int j=nums.size()-1;j&gt;=k;j--)
                {
                       nums[j]=nums[j-k];
                }
            for(int m=0;m&lt;tem.size();m++)
                {
                    nums[m]=tem[m];
                }


        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录53-Implement Str]]></title>
      <url>http://yoursite.com/2015/10/13/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9553-Implement-Str/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Descriptions"><a href="#Problem-Descriptions" class="headerlink" title="Problem Descriptions:"></a>Problem Descriptions:</h2><p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Use two pointers</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int strStr(string haystack, string needle) {
            if(needle==&quot;&quot;) 
                return 0;
            if(haystack.length()&lt;needle.length()) 
                return -1;
            int i=0;
            int j=needle.length();
            for(;i&lt;haystack.length()-needle.length()+1;i++)
                {
                    for(int k=0;k&lt;j;k++)
                           {
                            if(haystack[i+k]!=needle[k]) 
                                break;
                            if(k==j-1) 
                                return i;
                        }

                }
            return -1;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录52-Valid Palindrome]]></title>
      <url>http://yoursite.com/2015/10/12/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9552-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Descriptions"><a href="#Problem-Descriptions" class="headerlink" title="Problem Descriptions:"></a>Problem Descriptions:</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.</p>
<p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Just simplify the string and do the decision.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isPalindrome(string s) {
               string plain =&quot;&quot;;
            for(int i =0;i&lt;s.length();i++)
                {
                    if(s[i]&gt;=&apos;a&apos;&amp;&amp;s[i]&lt;=&apos;z&apos;)
                        plain+=s[i];
                    else if(s[i]&gt;=&apos;A&apos;&amp;&amp;s[i]&lt;=&apos;Z&apos;)
                        plain+=(char)(s[i]-&apos;A&apos;+&apos;a&apos;);
                    else if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;)
                        plain+=s[i];
                    else continue;
                }
            if(s.length()&lt;=1) 
                return true;
            for(int i=0;i&lt;plain.length()/2+1;i++)
            if(plain[i]!=plain[plain.length()-1-i]) 
                return false;
            return true;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录51-Palindrome Linked List]]></title>
      <url>http://yoursite.com/2015/10/12/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9551-Palindrome-Linked-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Could you do it in O(n) time and O(1) space?</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>reverse the second part and check if it is the same as the first half.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* reverseList(ListNode* head) {
        if(head == NULL) 
            return NULL;
        if(head-&gt;next == NULL) 
            return head;
        ListNode* p;
        ListNode* q;
        p = head-&gt;next;
        while(p-&gt;next!=NULL)
            {
                q=p-&gt;next;
                p-&gt;next = q-&gt;next;
                q-&gt;next = head-&gt;next;
                head-&gt;next = q;
            }
        p-&gt;next = head;
        head = p-&gt;next-&gt;next;
        p-&gt;next-&gt;next = NULL;

        return head;

    }
    bool isPalindrome(ListNode* head) {
        if(!head||!head-&gt;next) 
            return true;
           ListNode* first = head;
           ListNode* second = head;
          ListNode* counthelper=head;
           int secondindex=0;
           int count=0;
           while(counthelper!=NULL)
               {
                   counthelper=counthelper-&gt;next;
                   count++;
               }
           if(count%2==0)
               secondindex=count/2;
           else 
               secondindex =count/2+1;
           for(int i=0;i&lt;secondindex;i++)
               second=second-&gt;next;
           second=reverseList(second);
           while(second!=NULL)
               {
                   if(first-&gt;val!=second-&gt;val)
                       return false;
                   first=first-&gt;next;
                   second=second-&gt;next;
               }
           return true;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录50-Nim Game]]></title>
      <url>http://yoursite.com/2015/10/12/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9550-Nim-Game/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>This is a simple math problem. The first will win only if the number of total stones have anything left if is divided by 4.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool canWinNim(int n) {
            return n%4&gt;0;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录49-Reverse Integer]]></title>
      <url>http://yoursite.com/2015/10/12/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9549-Reverse-Integer/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>
<p>click to show spoilers.</p>
<p>Have you thought about this?<br>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>
<p>If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.</p>
<p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p>
<p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>A simple math task</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int reverse(int x) {
               int res = 0;
            while(x!=0)
                {
                    if(res&gt;INT_MAX/10||res&lt;INT_MIN/10) 
                        return 0;
                    else
                        {
                            res= res*10+x%10;
                            x/=10;
                        }
                }
            return res;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录48-Add Binary]]></title>
      <url>http://yoursite.com/2015/10/11/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9548-Add-Binary/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,<br>a = “11”<br>b = “1”<br>Return “100”.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Handle that from back to front;</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        string addBinary(string a, string b) {
            string res;
            int carry=0;
                int i=a.length()-1;
            int j=b.length()-1;
                for(;i&gt;=0||j&gt;=0;i--,j--)
                {
                    int aa,bb;
                       if(i&gt;=0)
                           aa=(a[i]-&apos;0&apos;);
                    else 
                        aa=0;
                    if(j&gt;=0)
                        bb=(b[j]-&apos;0&apos;);
                    else 
                        bb=0;
                    int current=aa+bb+carry;
                    char bit;
                    switch(current)
                        {
                                case 0: bit=&apos;0&apos;;carry=0;break;
                                 case 1: bit=&apos;1&apos;;carry=0;break;
                                case 2: bit=&apos;0&apos;;carry=1;break;
                              case 3: bit=&apos;1&apos;;carry=1;break;
                              default:break;
                        }
                    res=bit+res;
                }
            if(carry)
                {
                    string s=&quot;1&quot;;
                    return s+res;
                }
            return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录47-Count and Say]]></title>
      <url>http://yoursite.com/2015/10/11/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9547-Count-and-Say/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, …</p>
<p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.<br>Given an integer n, generate the nth sequence.</p>
<p>Note: The sequence of integers will be represented as a string.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Do it very carefully with borders</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        string int2str(int num) 
            { 
                if(num == 0) 
                    return &quot;0&quot;; 

                string str = &quot;&quot;; 

                int num_ = num &gt; 0 ? num : -1 * num; 

                while(num_) 
                    { 
                        str = (char)(num_ % 10 + 48) + str; 
                        num_ /= 10; 
                    } 

                if(num &lt; 0) 
                    str = &quot;-&quot; + str; 
                    return str; 
            }     
        string countAndSay(int n) {
                if(n&lt;1) 
                    return &quot;1&quot;;
                vector&lt;string&gt; res;
                res.push_back(&quot;1&quot;);
                int count=1;
                char current=&apos; &apos;;
                string temp=&quot;&quot;;
                for(int i=1;i&lt;n;i++)
                    {
                           temp=&quot;&quot;;
                          count=0;
                        current=res[i-1][0];
                        for(int j=0;j&lt;res[i-1].length();j++)
                            {
                                if(res[i-1][j]==current)
                                    count++;

                                else
                                    {
                                        temp+=int2str(count);
                                           temp+=current;
                                        current=res[i-1][j];
                                        count=1;
                                    }
                                if(j==res[i-1].length()-1)
                                    {
                                           temp+=int2str(count);
                                        temp+=current;

                                    }
                            }
                        res.push_back(temp);

                    }
                   return res[n-1]; 
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录46-Valid Parentheses]]></title>
      <url>http://yoursite.com/2015/10/11/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9546-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Very classic stack problem.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isValid(string s) {
               if(s.length()==0) 
                    return true;
            vector&lt;char&gt; stack;
            stack.clear();
            for(int i =0;i&lt;s.length();i++)
                {

                      switch(s[i])
                          {
                              case &apos;(&apos;:
                                          stack.push_back(s[i]);break;
                              case &apos;[&apos;:
                                          stack.push_back(s[i]);break;
                              case &apos;{&apos;:
                                          stack.push_back(s[i]);break;
                             case &apos;)&apos;:
                                          if(stack.size()&gt;0&amp;&amp;stack.back()==&apos;(&apos;) 
                                              stack.pop_back(); 
                                          else 
                                              return false;
                                              break;
                              case &apos;]&apos;:
                                          if(stack.size()&gt;0&amp;&amp;stack.back()==&apos;[&apos;) 
                                              stack.pop_back(); 
                                          else 
                                              return false;
                                              break;
                              case &apos;}&apos;:
                                          if(stack.size()&gt;0&amp;&amp;stack.back()==&apos;{&apos;) 
                                              stack.pop_back(); 
                                          else 
                                              return false;
                                              break;
                              default: 
                                          return false;
                          }



            }  
            return stack.size()==0;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录45-Remove Nth Node From End Of List]]></title>
      <url>http://yoursite.com/2015/10/11/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9545-Remove-Nth-Node-From-End-Of-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Use two pointers</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
               ListNode *pre=head;
            ListNode *b=head-&gt;next;
            if(!b) 
                return NULL;
            while(pre&amp;&amp;b)
                {
                for(int i = 0;i&lt;n-1;i++) b=b-&gt;next;
                if (!b) 
                    return head-&gt;next;
                else
                {
                    b=b-&gt;next;
                    if(!b)
                        {
                            pre-&gt;next=pre-&gt;next-&gt;next;
                             return head;
                            }
                    else
                        {
                            pre=pre-&gt;next;
                            b=pre-&gt;next;
                        }
                }



                }
            return head;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录44-Minimum Depth of Binary Tree]]></title>
      <url>http://yoursite.com/2015/10/11/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9544-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using Depth First Search</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int minDepth(TreeNode* root) {
            if(!root) 
                return 0;
            if(!root-&gt;left) 
                return minDepth(root-&gt;right)+1;
            if(!root-&gt;right) 
                return minDepth(root-&gt;left)+1;
            if(root-&gt;left&amp;&amp;root-&gt;right)
                return min(minDepth(root-&gt;left)+1,minDepth(root-&gt;right)+1);
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录43-Palindrome Number]]></title>
      <url>http://yoursite.com/2015/10/11/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9543-Palindrome-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Check every pair of front and rear numbers</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isPalindrome(int x) {
            if(x&lt;0) 
                return false;
            else if(x&lt;10) 
                return true;

            int helper=1;
            int current=x;
            int rear =0;
            while(current&gt;9)
                {
                        current/=10;
                        helper*=10;
                }
            while(helper&gt;1)
                {
                       if(x/helper!=x%10) 
                            return false;
                    else
                        {
                            x-=helper*(x/helper);
                            x/=10;
                            helper/=100;
                        }
                }
            return true;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录42-Two Sum]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9542-Two-Sum/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Just index every element in nums[] and search for its pair, the time complexity would be O(n)</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
            map&lt;int,int&gt; map;
            vector&lt;int&gt; res;
            res.clear();
            for(int i = 0 ;i&lt;nums.size();i++)
                {
                        map[nums[i]]=i;
                }
            for(int i = 0;i&lt;nums.size();i++)
                {
                    int pair = target-nums[i];
                    if(map.find(pair)!=map.end())
                        {
                            if(i!=map[pair])
                                {
                                        res.push_back(i+1);
                                        res.push_back(map[pair]+1);
                                    break;
                                }


                            }
                    }
                return res;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录41-Intersection of Two Linked Lists]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9541-Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3<br>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><p>Find the diffrenece between the two lists, move forward the longer one by the difference.</p>
<h2 id="Code-in-C-for-Solution-1"><a href="#Code-in-C-for-Solution-1" class="headerlink" title="Code in C++ for Solution 1:"></a>Code in C++ for Solution 1:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
*/
class Solution {
    public:
        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
            if(!headA||!headB) 
                return NULL;
            ListNode *pa=headA;
            ListNode *pb=headB;
            int numofA=0,numofB=0;
            while(pa)
                {
                        numofA++;
                        pa=pa-&gt;next;
                }
            while(pb)
                {
                        numofB++;
                        pb=pb-&gt;next;
                }
            pa=headA;
            pb=headB;
            int dif=numofA-numofB;
            while(numofA&gt;0&amp;&amp;numofB&gt;0&amp;&amp;pa!=pb)
                {
                    if(numofA&gt;numofB)
                        {
                            pa=pa-&gt;next;
                            numofA--;
                        }
                    if(numofA&lt;numofB)
                        {
                            pb=pb-&gt;next;
                            numofB--;
                        }
                    if(numofA==numofB)
                        {
                            if(pa==pb) 
                                return pa;
                            else
                                {
                                    pa=pa-&gt;next;
                                    pb=pb-&gt;next;
                                       numofA--;
                                    numofB--;
                                }
                        }
                }
            return pa;
        }
    };
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>use two pointers,once finishes one link, goto the head of the next link</p>
<h2 id="Code-in-C-for-Solution-2"><a href="#Code-in-C-for-Solution-2" class="headerlink" title="Code in C++ for Solution 2:"></a>Code in C++ for Solution 2:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
            ListNode *pa=headA;
            ListNode *pb=headB;
               if((!pa&amp;&amp;pb)||(pa&amp;&amp;!pb)) 
                   return NULL;
            while(pa!=pb)
                {
                       pa=pa-&gt;next;
                       pb=pb-&gt;next;
                       if(!pa&amp;&amp;pb) 
                            pa=headB;
                     else if(!pb&amp;&amp;pa) 
                        pb=headA;
                     else if(!pa&amp;&amp;!pb) 
                          return NULL;

                    }
            return pa;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录40-actorial Trailing Zeroes]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9540-actorial-Trailing-Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer n, return the number of trailing zeroes in n!.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Very easy task</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int trailingZeroes(int n) {
            int res=0;
            while(n&gt;0)
                {
                    res+=n/5;
                    n=n/5;
                }
            return res;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录39-Symmetric Tree]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9539-Symmetric-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<pre><code>    1
   / \
  2   2
   / \ / \
3  4 4  3
</code></pre><p>But the following is not:<br>      1<br>     / \<br>     2  2<br>     \   \<br>     3    3</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Just use Depth First Search</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        bool isSymmetric(TreeNode* a,TreeNode*b)
            {
                if(!a&amp;&amp;!b)
                    return true;
                if((!a&amp;&amp;b)||(!b&amp;&amp;a))
                    return false;
                else
                    {
                        if(a-&gt;val==b-&gt;val)
                            return isSymmetric(a-&gt;left,b-&gt;right)&amp;&amp;isSymmetric(a-&gt;right,b-&gt;left);
                    }
                return false;
            }
        bool isSymmetric(TreeNode* root) {
                if(!root)
                    return true;
                if(!root-&gt;left&amp;&amp;!root-&gt;right) 
                    return true;
                if((!root-&gt;left&amp;&amp;root-&gt;right)||(!root-&gt;right&amp;&amp;root-&gt;left)) 
                    return false;
                if(root-&gt;left&amp;&amp;root-&gt;right)
                    {
                        if(root-&gt;left-&gt;val==root-&gt;right-&gt;val) return isSymmetric(root-&gt;left,root-&gt;right);
                        return false;
                    }



            }
        };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录38-Path Sum]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9538-Path-Sum/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>       5
   / \
   4 8
  / / \
11 13 4
  / \ \
  7 2 1
</code></pre><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using Depth-First Search</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {
    public:
        bool hasPathSum(TreeNode* root, int sum) {
            if(!root) 
                return false;
            if(root-&gt;val == sum &amp;&amp; !root-&gt;left&amp;&amp;!root-&gt;right) 
                return true;
            if(hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val))
                return true;
            return false;


        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录37-Balanced Binary Tree]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9537-Balanced-Binary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using Depth First Search.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {
    public:
        int Dep(TreeNode* root)
            {
                if(!root) 
                    return 0;
                return max(Dep(root-&gt;left)+1,Dep(root-&gt;right)+1);
            }
        bool isBalanced(TreeNode* root) {
            if(!root) 
                return true;
            if(isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right))
                {
                    if (abs(Dep(root-&gt;left)-Dep(root-&gt;right))&lt;=1)
                        return true;
                    return false;
                }
            return false;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录36-Ugly Number]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9536-Ugly-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Simply math problem.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isUgly(int num) {
            if(num==0) 
                return false;
            while(num%2==0)
                {
                    num/=2;
                }
            while(num%3==0)
                {
                    num/=3;
                }
            while(num%5==0)
                {
                    num/=5;
                }
            return num==1;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录35-Merge Two Sorted Lists]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9535-Merge-Two-Sorted-Lists/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Easy task</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
    public:
        ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
            ListNode * res=new ListNode(0);
            ListNode * a = res;
            while(1)
                {
                    if(!l1)
                        {
                            a-&gt;next = l2;
                            break;
                        }
                    if(!l2)
                        {
                            a-&gt;next=l1;
                            break;
                        }

                    if(l1-&gt;val&lt;=l2-&gt;val)
                        {
                            a-&gt;next = l1;
                            l1=l1-&gt;next;
                        }
                    else
                        {
                            a-&gt;next = l2;
                            l2=l2-&gt;next;
                        }
                    a=a-&gt;next;
                }
            return res-&gt;next;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录34-Climbing Stairs]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9534-Climbing-Stairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><p>Using Dynamic Programming</p>
<h2 id="Code-for-Solution-1"><a href="#Code-for-Solution-1" class="headerlink" title="Code for Solution 1:"></a>Code for Solution 1:</h2><pre><code>class Solution {
    public:
        int climbStairs(int n) {
            switch(n)
                {
                    case 0:return 1;
                    case 1:return 1;
                    default:
                    vector&lt;int&gt; result;
                    result.push_back(1);
                    result.push_back(1);
                    for(int i =2;i&lt;=n;i++)
                        {
                            result.push_back(result[i-1]+result[i-2]);
                        }
                    return result[n];
                }
            }
    };
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>Using Recursive call</p>
<h2 id="Code-for-Solution-2"><a href="#Code-for-Solution-2" class="headerlink" title="Code for Solution 2:"></a>Code for Solution 2:</h2><pre><code>class Solution {
    public:
        int climbStairs(int n) {
            switch(n)
                {
                    case 0 : return 1;
                    case 1 : return 1;
                    default: return climbStairs(n-1)+climbStairs(n-2);

                }
            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录33-Majority Element]]></title>
      <url>http://yoursite.com/2015/10/10/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9533-Majority-Element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Every other element will cancel the majority once. The left one is the majority.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int majorityElement(vector&lt;int&gt;&amp; nums) {
            int res = nums[0];
            int count = 1;
            for(int i =1;i&lt;nums.size();i++)
                {    
                    if(nums[i]==res) 
                        count++;
                    else if(nums[i]!=res) 
                        count--;
                    if(count==0) 
                        {
                            res = nums[i];
                            count=1;
                        }
                }
            return res;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录32-Remove Duplicates from Sorted List]]></title>
      <url>http://yoursite.com/2015/10/09/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9532-Remove-Duplicates-from-Sorted-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Simple task</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
    public:
        ListNode* deleteDuplicates(ListNode* head) {
            if(head==NULL||head-&gt;next==NULL) 
                return head;
            else
                {
                    ListNode*a = head;      
                    ListNode*b = head-&gt;next;
                    while(a!=NULL&amp;&amp;b!=NULL)
                        {
                            if(a-&gt;val==b-&gt;val)
                                {
                                    a-&gt;next=b-&gt;next;
                                    b=b-&gt;next;
                                }
                            else
                                {
                                    a= a-&gt;next;
                                    b=b-&gt;next;
                                }

                        }
                    return head; 
                }

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录31-Excel Sheet Column Number]]></title>
      <url>http://yoursite.com/2015/10/09/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9531-Excel-Sheet-Column-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Related to question Excel Sheet Column Title</p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
</code></pre><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Easy task</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int toInt(char a)
            {
                if(a&gt;=&apos;A&apos;&amp;&amp;a&lt;=&apos;Z&apos;)
                    return (int)(a-&apos;A&apos;+1);
                else 
                    return 0;
            }
int titleToNumber(string s) {
    int res = 0;
    for(int i =0;i&lt;s.length();i++)
        {
            res+= (pow(26,s.length()-i-1)*toInt(s[i])); 
        }
    return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录30-Same Tree]]></title>
      <url>http://yoursite.com/2015/10/09/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9530-Same-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using Depth First Search.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {
    public:
        bool isSameTree(TreeNode* p, TreeNode* q) {
            if(!p&amp;&amp;!q) 
                return true;
            if((p&amp;&amp;!q)||(q&amp;&amp;!p)) 
                return false;
            return isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right)&amp;&amp;(p-&gt;val==q-&gt;val);
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录29-Delete Node in a Linked List]]></title>
      <url>http://yoursite.com/2015/10/09/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9529-Delete-Node-in-a-Linked-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Simply use this link to point to the next node.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
    public:
        void deleteNode(ListNode* node) {
            node-&gt;val = node-&gt;next-&gt;val;
            node-&gt;next = node-&gt;next-&gt;next;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录28-Maximum Depth of Bianary Tree]]></title>
      <url>http://yoursite.com/2015/10/09/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9528-Maximum-Depth-of-Bianary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>So easy…</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {
    public:
        int maxDepth(TreeNode* root) {
        if(root==NULL) 
            return 0;
        return max(maxDepth(root-&gt;left)+1,maxDepth(root-&gt;right)+1);
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录27-Add Digits]]></title>
      <url>http://yoursite.com/2015/10/09/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9527-Add-Digits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p>
<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h2><p>Could you do it without any loop/recursion in O(1) runtime?</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Write a few results and find the clue.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int addDigits(int num) {
            if(num&lt;10) 
                return num;
            return num%9==0?9:num%9;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录26-Single Number]]></title>
      <url>http://yoursite.com/2015/10/08/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9526-Single-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using a set to store the unique ones, delete when duplicates are found.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int singleNumber(vector&lt;int&gt;&amp; nums) {
            set&lt;int&gt; set;
            set.clear();
            for(int i =0;i&lt;nums.size();i++)
                {
                    if(set.find(nums[i])!=set.end())
                        set.erase(nums[i]);
                    else 
                        set.insert(nums[i]);
                }
            return *set.begin();
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录25-Isomorphic Strings]]></title>
      <url>http://yoursite.com/2015/10/08/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9525-Isomorphic-Strings/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>For example,<br>Given “egg”, “add”, return true.</p>
<p>Given “foo”, “bar”, return false.</p>
<p>Given “paper”, “title”, return true.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>It’s the same as This Problem.And it’s simpler.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isIsomorphic(string s, string t) {            
            string pattern = s;
            int len = pattern.length();
            string a = t;
            std::map&lt;char,char&gt; map;
            std::map&lt;char,char&gt; map2;
            std::map&lt;char,char&gt;::iterator it;
            std::map&lt;char,char&gt;::iterator it2;

            for(int i =0;i&lt;len;i++)
                {
                    it = map.find(pattern[i]);
                    it2 = map2.find(a[i]);
                    if (it != map.end()|| it2 !=map2.end())
                        {
                            if(a[i]!=map[pattern[i]])
                                return false;
                            if(map[map2[a[i]]]!=a[i]) return false;
                        }
                    else
                        {
                            map[pattern[i]]=a[i];
                            map2[a[i]]=pattern[i];  
                        }
                }
            return true;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录24-Longest Common Prefix]]></title>
      <url>http://yoursite.com/2015/10/08/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9524-Longest-Common-Prefix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>A very simple task.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
            if(strs.size()==0) 
                return &quot;&quot;;
            string res = &quot;&quot;;
            string restem =res+strs[0][0];
            while(res.length()&lt;strs[0].length())
                {
                    for(int i = 0;i&lt; strs.size();i++)
                        {
                            for(int j = 0;j&lt;restem.length();j++)
                                {
                                    if(strs[i][j]!=restem[j]) 
                                        return res;
                                }
                        }
                    res = restem;
                    restem+=strs[0][restem.length()];
                }

            return res;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录23-Remove Linked List Elements]]></title>
      <url>http://yoursite.com/2015/10/08/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9523-Remove-Linked-List-Elements/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Remove all elements from a linked list of integers that have value val.</p>
<p>Example<br>Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6<br>Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Pay attention when first few elements is to be deleted</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            if(head == NULL) 
                return NULL;
            while(head-&gt;val == val) 
                {
                    head=head-&gt;next;
                    if(head == NULL) 
                        return head;
                }
            ListNode* a = head;
            while(a-&gt;next!= NULL&amp;&amp;a!=NULL)
                {
                    if(a-&gt;next-&gt;val == val)
                        {
                            ListNode * b= a-&gt;next;
                            a-&gt;next = b-&gt;next;
                        }
                    else
                        {
                            a=a-&gt;next;
                        }
                }
            return head;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录22-Word Pattern]]></title>
      <url>http://yoursite.com/2015/10/08/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9522-Word-Pattern/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Examples:<br>pattern = “abba”, str = “dog cat cat dog” should return true.<br>pattern = “abba”, str = “dog cat cat fish” should return false.<br>pattern = “aaaa”, str = “dog cat cat dog” should return false.<br>pattern = “abba”, str = “dog dog dog dog” should return false.<br>Notes:<br>patterncontains only lowercase alphabetical letters, and str contains words separated by a single space. Each word in str contains only lowercase alphabetical letters.<br>Both pattern and str do not have leading or trailing spaces.<br>Each letter in pattern must map to a word with length that is at least 1.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>use two hashtables to store the pairs.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;string&gt; stringTovec(string s){
            vector&lt;string&gt; res;
            int len=s.size();
            string temp=&quot;&quot;;
            for(int i=0;i&lt;len;++i)
                {
                    if(s[i]==&apos; &apos;)
                        {
                            res.push_back(temp);
                            temp=&quot;&quot;;
                        }
                    else
                        temp+=s[i];
                }
            res.push_back(temp);
            return res;
        }

        bool wordPattern(string pattern, string str) {
            if(pattern.length()==0||str.length()==0) 
                return false;
            int len = pattern.length();
            vector&lt;string&gt; a = stringTovec(str);
            if(a.size()!=len) return false;

            std::map&lt;char,string&gt; map;
            std::map&lt;string,char&gt; map2;
            std::map&lt;char,string&gt;::iterator it;
            std::map&lt;string ,char&gt;::iterator it2;

            for(int i =0;i&lt;len;i++)
                {
                    it = map.find(pattern[i]);
                    it2 = map2.find(a[i]);
                    if (it != map.end()|| it2 !=map2.end())
                        {
                            if(a[i]!=map[pattern[i]])
                                return false;
                            if(map[map2[a[i]]]!=a[i]) 
                                return false;
                        }
                    else
                        {
                            map[pattern[i]]=a[i];
                            map2[a[i]]=pattern[i];  
                        }
                }
            return true;


        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录21-Rectangular Area]]></title>
      <url>http://yoursite.com/2015/10/08/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9521-Rectangular-Area/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Find the total area covered by two rectilinear rectangles in a 2D plane.</p>
<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p>
<p>Rectangle Area<br>Assume that the total area is never beyond the maximum possible value of int.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Easy math problem. remember to cut off repeat part.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
            int coverleft = A&gt;E?A:E;
            int coverright = C&lt;G?C:G;
            int covertop = D&gt;H?H:D;
            int coverbot = F&gt;B?F:B;

            int coverarea = 0;
            if(coverleft&lt;=coverright&amp;&amp;covertop&gt;=coverbot)
                {
                    coverarea=(coverright-coverleft)*(covertop-coverbot);

                }
            return(C-A)*(D-B)+(G-E)*(H-F)-coverarea;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录20-Contains Duplicate II]]></title>
      <url>http://yoursite.com/2015/10/07/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9520-Contains-Duplicate-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using a moving window of at most size k , find there’s duplicats in the window.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
            if(nums.size()&lt;=1||k&lt;=0) 
                return false;
            else
                {
                    set&lt;int&gt; a;
                    for(int i =0;i&lt;nums.size();i++)
                        {
                            if(a.size()&gt;k)
                                {
                                    a.erase(nums[i-k-1]);
                                }
                            if(a.find(nums[i])!=a.end())
                                return true;

                            a.insert(nums[i]);
                        }
                    return false;
                }
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录19-Length Of Last Word]]></title>
      <url>http://yoursite.com/2015/10/07/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9519-Length-Of-Last-Word/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = “Hello World”,<br>return 5.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>just simple manipulations, remember to take care of special cases</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int lengthOfLastWord(string s) {
            if(s.length() == 0) 
                return 0;
            int count = 0;
            int flag= s.length()-1;
            for(int i = s.length()-1;i&gt;=0;i--)
                {
                    if(s[i]!=&apos; &apos;) {flag = i;break;}
                }

            while(s[flag-count]!=&apos; &apos;&amp;&amp;count&lt;=flag)
                {
                    count++;
                }
            return count;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录18-Merge Sorted Array]]></title>
      <url>http://yoursite.com/2015/10/07/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9518-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Insert from back.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
            if(m == 0)
                {
                    for(int i =0;i&lt;n;i++)
                        nums1[i]=nums2[i];
                }
            else
                {
                    int j = m+n-1;
                    m--;
                    n--;
                    for(;j&gt;=0&amp;&amp;m&gt;=0&amp;&amp;n&gt;=0;j--)
                        {
                            if(nums1[m]&gt;=nums2[n])
                                {
                                    nums1[j]=nums1[m--];
                                }
                            else if(nums1[m]&lt;nums2[n])
                                {
                                    nums1[j]=nums2[n--];
                                }
                        }
                    if(n&gt;=0)
                        {
                            for(int i = 0;i&lt;=n;i++)
                                nums1[i]=nums2[i];
                        } 
                }


            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录17-Happy Number]]></title>
      <url>http://yoursite.com/2015/10/07/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9517-Happy-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<pre><code>12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
</code></pre><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Make a hashtable to store every step’s result. Once you find the result in the hashtable, return if it’s equal to 1</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int theSum(int n)
            {
                int result=0;
                while(n&gt;=1)
                    {
                        result+=(n%10)*(n%10);
                        n/=10;
                    }
                return result;
            }
        bool isHappy(int n) {
            vector&lt;int&gt; a;
            while(1)
                {
                    std::vector&lt;int&gt;::iterator it;
                    it = find (a.begin(), a.end(), theSum(n));
                    if (it != a.end())
                        {
                            return(theSum(n) == 1);
                        }
                    else
                        {
                            a.push_back(theSum(n));
                            n=theSum(n);
                        }
                }

            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录16-Remove Duplicates from Sorted Array II]]></title>
      <url>http://yoursite.com/2015/10/07/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9516-Remove-Duplicates-from-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Use some flag to mark if a number has been kept for once.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int removeDuplicates(vector&lt;int&gt;&amp; nums) {
            if (nums.size() == 0) 
                return 0;
            else if(nums.size() == 1) 
                return 1;
            else
                {
                    int count = 1;
                    int temp = nums[0];
                    bool flag = false;
                    for(int i = 1;i&lt;nums.size();i++)
                        {
                            if(nums[i]!= temp) 
                                {   
                                    temp = nums[i];
                                    nums[count++]=nums[i];
                                    flag= false;

                                }
                            else if(nums[i] == temp) 
                                {
                                    if(!flag)
                                        {
                                            nums[count++]=nums[i];
                                            flag = true;
                                        }
                                }

                        }
                    return count;
                }    
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录15-Pascal's Triangle II]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9515-Pascal-s-Triangle-II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].</p>
<p>Note:<br>Could you optimize your algorithm to use only O(k) extra space?</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Only use two arrays, one to store the answer and the other to store the previous answer.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; getRow(int rowIndex) {
        vector&lt;int&gt; last;
        last.push_back(1);
        if(rowIndex == 0) 
            return last;
        last.push_back(1);
        if(rowIndex == 1) 
            return last;
        if(rowIndex &gt; 1)
            {
                vector&lt;int&gt; result;

                for(int i =1;i&lt;rowIndex;i++)
                    {
                        result.clear();
                        result.push_back(1);
                        for(int i =1;i&lt;last.size();i++)
                        result.push_back(last[i]+last[i-1]);    
                        result.push_back(1);
                        last=result;
                    }
                return result;
            }
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录14-House Robber]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9514-House-Robber/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h2><p>Use recursive algorithms. That will take so much time,and will not be accepted;</p>
<h2 id="Code-in-C-for-Solution-1"><a href="#Code-in-C-for-Solution-1" class="headerlink" title="Code in C++ for Solution 1:"></a>Code in C++ for Solution 1:</h2><pre><code>class Solution {
    public:
        int max(vector&lt;int&gt;&amp; a, int p)
            {
                if(p == 0) return 0;
                if(p == 1) return a[0];
                if(p == 2) return a[0]&gt;a[1]? a[0]:a[1];
                else
                    {
                        if(max(a,p-2)+a[p-1]&gt;max(a,p-1)) 
                            return max(a,p-2)+a[p-1];
                        else 
                            return max(a,p-1);
                    }
            }
        int rob(vector&lt;int&gt;&amp; nums) {
            return max(nums,nums.size());

            }
};
</code></pre><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h2><p>Use Dynamic Programming, which will use an array to keep every best solution for each step.</p>
<h2 id="Code-in-C-for-Solution-2"><a href="#Code-in-C-for-Solution-2" class="headerlink" title="Code in C++ for Solution 2:"></a>Code in C++ for Solution 2:</h2><pre><code>class Solution {
    public:
        int rob(vector&lt;int&gt;&amp; nums) {
            if(nums.size()==0) 
                return 0;
            if(nums.size()==1) 
                return nums[0];
            if(nums.size()==2) 
                return nums[0]&gt;nums[1]?nums[0]:nums[1];
            if(nums.size()&gt;=3)
                {
                    vector&lt;int&gt; solutions;
                    solutions.push_back(nums[0]);
                    solutions.push_back(nums[0]&gt;nums[1]?nums[0]:nums[1]);
                    for(int i = 2; i &lt; nums.size();i++)
                        if(solutions[i-2]+nums[i]&gt;solutions[i-1])
                            solutions.push_back(solutions[i-2]+nums[i]);
                        else
                            solutions.push_back(solutions[i-1]);

                    return solutions.back();
                }

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录13-Pascal's Triangle]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9513-Pascal-s-Triangle/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return</p>
<p>[<br>[1],<br>[1,1],<br>[1,2,1],<br>[1,3,3,1],<br>[1,4,6,4,1]<br>]</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>For every element after the second line, we can see that a[i][j]=a[i-1][j-1]+a[i-1][j], finally put a 1 at the back of the row.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; a;
        if(numRows == 0) return a;
        vector&lt;int&gt; last = {1};
        a.push_back(last);
        if(numRows == 1) 
            return a;
        last.push_back(1);
        a.push_back(last);
        if(numRows == 2) 
            return a;
        if(numRows&gt;=3)
            {
                for(int i =2;i&lt; numRows;i++)
                    {
                        last.clear();
                        last.push_back(1);
                        for(int j = 1; j &lt; i; j++)
                            last.push_back(a[i-1][j-1]+a[i-1][j]);
                        last.push_back(1);
                        a.push_back(last);
                    }
                return a;   
            }


        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录12-Plus One]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9512-Plus-One/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>It’s a easy task, just pay attention to all possible cases.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        int n = digits.size();
        digits[n-1]++;
        if(digits[n-1]&lt;10)
            return digits;
        else
            {
                digits[n-1]=0;
                int count=1;
                while(digits[n-1-count] == 9 &amp;&amp; count &lt; n)  count++;
                if(count&lt;n)
                    {
                        digits[n-1-count]++;
                        for(int i = n-1;i&gt;n-1-count;i--)
                            digits[i]=0;
                        return digits;
                    }
                else
                    {
                        digits[0]=1;
                        for(int i =1;i&lt;n-1;i++)
                            digits[i]=0;
                        digits.push_back(0);
                        return digits;
                    }
            }


    }   
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录11-Remove Duplicates from Sorted Array]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9511-Remove-Duplicates-from-Sorted-Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Just search for new distinct element and put it into the right possition of the arry.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int removeDuplicates(vector&lt;int&gt;&amp; nums) {
            if(nums.size() == 0) return NULL;
            if(nums.size() == 1) return 1;
            else
                {
                    int count = 1;
                    int temp = nums[0];
                    for(int i = 0;i&lt;nums.size();i++)
                        {
                            if(nums[i]!= temp) 
                                {
                                    temp = nums[i];
                                    nums[count++]= nums[i];
                                } 
                        }
                    return count;
                }

            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录10-Power Of Two]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%9510-Power-Of-Two/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an integer, write a function to determine if it is a power of two.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Check recuirsively if n can be completely divided by two.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
    bool isPowerOfTwo(int n) {
        while(n&gt;1)
            {
                if(n%2&gt;0) return false;
                else n=n/2;
            } return n == 1;

        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录9-Remove Elements]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%959-Remove-Elements/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Compare every element with the givin value, ignore it when matches, move other elements forwards.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        if(nums.size() == 0) return 0;
        int count1 = 0;
        for(int i =0;i&lt;nums.size();i++)
            {
                if(nums[i]!=val) nums[count1++]=nums[i];
            }
        return count1;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录8-Reverse Linked List]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%958-Reverse-Linked-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Reverse a singly linked list.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>For every single linknode from the second link, just put it after the first linknode. Then put the previous head to the bottom of the linked list.(Make a circle and then break it at proper possition)</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
    public:
        ListNode* reverseList(ListNode* head) {
        if(head == NULL) return NULL;
        if(head-&gt;next == NULL) return head;
        ListNode* p;
        ListNode* q;
        p = head-&gt;next;
        while(p-&gt;next!=NULL)
            {
                q=p-&gt;next;
                p-&gt;next = q-&gt;next;
                q-&gt;next = head-&gt;next;
                head-&gt;next = q;
            }
        p-&gt;next = head;
        head = p-&gt;next-&gt;next;
        p-&gt;next-&gt;next = NULL;

        return head;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录7-Roman to Integer]]></title>
      <url>http://yoursite.com/2015/10/06/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%957-Roman-to-Integer/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Because the range of number is within 3999, so we don’t need to give 1000 times to a character. See the Roman numerals for more infomation.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:

        int RomanToNumbers(char x)
            {
                switch(x)
                    {
                        case &apos;I&apos;: return 1;
                        case &apos;V&apos;: return 5;
                        case &apos;X&apos;: return 10;
                        case &apos;L&apos;: return 50;  
                        case &apos;C&apos;: return 100;  
                        case &apos;D&apos;: return 500;  
                        case &apos;M&apos;: return 1000;  
                        default: return 0;  
                    }
            }
        int romanToInt(string s) {
                if(s.size()==0) return 0;
                if(s.size()==1) return RomanToNumbers(s[0]);
                else
                {
                        int result = RomanToNumbers(s[0]);
                        for(int i =1; i &lt;s.size();i++)
                            {
                                if(RomanToNumbers(s[i])&gt;RomanToNumbers(s[i-1]))
                                result+= (RomanToNumbers(s[i])-2*(RomanToNumbers(s[i-1])));
                                else
                                    {
                                        result+=RomanToNumbers(s[i]);
                                    }
                            }
                        return result;
                }

            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录6-valid anagram]]></title>
      <url>http://yoursite.com/2015/10/03/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%956-valid-anagram/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Because there are only lowercase alphabets, we can simply use an array to hash the strings to keep the number of every character.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool isAnagram(string s, string t) {
            if(s.size()==0 &amp;&amp; t.size()==0) return true;
            if(s.size()!=t.size()) return false;
            int count[26]={0};
            for(int i =0;i&lt;s.size();i++)
                {
                    ++count[s[i]-&apos;a&apos;];
                }
            for(int i =0;i&lt;t.size();i++)
                {
                    if(--count[t[i]-&apos;a&apos;]&lt;0) return false;
                }
            return true;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录5-Contains Duplicate]]></title>
      <url>http://yoursite.com/2015/10/03/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%955-Contains-Duplicate/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>This problem is primarily about using the method of hash table. But I really don’t know how to build hash table in C++. So I sorted the array to see if any number is equal to its neighbor.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        if(nums.size()&gt;0)
            {
                std::sort(nums.begin(),nums.end());
                if(nums.size()==2)
                {
                        return nums[0]==nums[1];
                }
                else
                {
                    for(int i = 1; i&lt; nums.size()-1;i++)
                        {
                            if(nums[i]== nums[i-1]|| nums[i]==nums[i+1])
                            return true;
                        }
                }
            }
        return false;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录4-Number of 1 Bits]]></title>
      <url>http://yoursite.com/2015/10/03/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%954-Number-of-1-Bits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>I didn’t have that brilliant idea, This Article is a perfect explaination.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int hammingWeight(uint32_t n) {
        int count= 0;
        while(n!=0)
            {
                n &amp;= (n-1);
                count++;
            }
        return count;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录3-Lowest Common Ancestor of a Binary Search Tree]]></title>
      <url>http://yoursite.com/2015/10/03/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%953-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code>     _______6______
    /              \
 ___2__          ___8__
/      \        /      \
0      _4       7       9
      /  \
     3   5
</code></pre><p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>According to the property of a binary search tree, the LCA would be where the two elements go seperate directions.<br>So we can do that recursively. But we have to pay attention that if one is the other’s ancestor, then return that node.</p>
<p>Code in C++:</p>
<pre><code>/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {
public:
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root&amp;&amp;p&amp;&amp;q)
        {
            if(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val)
            return lowestCommonAncestor(root-&gt;right,p,q);
            if((p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)||(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val)||p-&gt;val == root-&gt;val || q-&gt;val == root-&gt;val)
            return root;
            if(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)
            return lowestCommonAncestor(root-&gt;left,p,q);
        }else return NULL;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录2-Invert Binary Tree]]></title>
      <url>http://yoursite.com/2015/10/03/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%952-Invert-Binary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Invert a binary tree.</p>
<pre><code>        4
    /   \
   2     7
  / \   / \
1   3 6   9
</code></pre><p>to</p>
<pre><code>     4
      /   \
    7     2
  / \   / \
9   6 3   1
</code></pre><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>Using an easy recursive call of the function, just pay attention to when the tree is NULL.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {
public:
TreeNode* invertTree(TreeNode* root) {
    if(root)
        {
            root-&gt;left = invertTree(root-&gt;left);
            root-&gt;right = invertTree(root-&gt;right);
            TreeNode * temp = root-&gt;left;
            root-&gt;left = root-&gt;right;
            root-&gt;right = temp;
        }
    else return NULL;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode刷题记录1-Move Zeroes]]></title>
      <url>http://yoursite.com/2015/10/03/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%951-Move-Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].<br>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>For every non-0 element, just exchange it with the possition of the first 0 element.</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>void moveZeroes(vector&lt;int&gt;&amp; nums) 
{
    int count = 0;
    for(int i = 0;i&lt;nums.size();i++)
        if(nums[i]!=0)
        {
                int temp = nums[count];
                nums[count]=nums[i];
                nums[i]= temp;
                count++;

        }

}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Latex使用经验1——用bibtex添加引用]]></title>
      <url>http://yoursite.com/2015/10/02/Latex%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C1%E2%80%94%E2%80%94%E7%94%A8bibtex%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>用bibtex添加引用</p>
<h2 id="第一步：建立一个tex文件"><a href="#第一步：建立一个tex文件" class="headerlink" title="第一步：建立一个tex文件"></a>第一步：建立一个tex文件</h2><p>任何一种你想要方法建立一个tex文件，假如说叫a.tex</p>
<p>在文章末尾\end{document}之前加入以下三行：<br>\renewcommand\refname{Reference}<br>\bibliographystyle{plain}<br>\bibliography{b}<br>其中第一行是参考文献的标题，标题是Reference；第二行是格式，还有其他格式见此处，这里用plain；第三行是一个bib格式文件的名字，最好和tex文件名称一致，编译起来方便一些。<br>(有一点小小要注意的地方：最常见的引用格式是plain，它是按作者字母排序的，如果要按引用顺序来排序，推荐用格式unsrt)</p>
<h2 id="第二步：建立一个bib文件"><a href="#第二步：建立一个bib文件" class="headerlink" title="第二步：建立一个bib文件"></a>第二步：建立一个bib文件</h2><p>bib文件就是一个plain text文件，明明为b.bib，bib格式可以在各种数据库里面的citation找到，例如<br>@book{Book1,<br>title = “Title1”,<br>author = “author1”,<br>publisher = “publisher1”,<br>year = “2015”<br>}</p>
<h2 id="第三步：在tex文件中引用"><a href="#第三步：在tex文件中引用" class="headerlink" title="第三步：在tex文件中引用"></a>第三步：在tex文件中引用</h2><p>在需要引用的地方使用\cite{Book1},期中Book1是你在bib文件中给每个引用的名字</p>
<h2 id="第四步：运行-tex文件"><a href="#第四步：运行-tex文件" class="headerlink" title="第四步：运行.tex文件"></a>第四步：运行.tex文件</h2><p>可以直接运行texshop里面的排版或者用命令行 pdflatex a(a是咱们.tex文件的名字)</p>
<h2 id="第五步：运行-bib文件"><a href="#第五步：运行-bib文件" class="headerlink" title="第五步：运行.bib文件"></a>第五步：运行.bib文件</h2><p>用bibtex b(b是咱们.bib文件的名字)，注意：一定要先运行pdflatex命令，因为运行后会生成aux文件，而编译bib是需要aux文件的、</p>
<h2 id="第六步：运行-tex文件2次"><a href="#第六步：运行-tex文件2次" class="headerlink" title="第六步：运行.tex文件2次"></a>第六步：运行.tex文件2次</h2><p>对，你没看错，运行2次，才能正确生成引用和引用目录，原理我也不知道，就这么用就行了！pdflatex a 这个命令运行2次就行了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[今天的月亮很美]]></title>
      <url>http://yoursite.com/2015/10/01/%E4%BB%8A%E5%A4%A9%E7%9A%84%E6%9C%88%E4%BA%AE%E5%BE%88%E7%BE%8E/</url>
      <content type="html"><![CDATA[<p>前几天中秋节，在美帝幸运地看到了血月和月全食之后。突然想起了夏目漱石问学生如何翻译“i love you”这个问题。他给学生的答案是“今天的月亮很美”。想起曾经和人谈论过这个问题，当时觉得有种听到“今天的风儿真是喧嚣”的感觉。其实我觉得我现在能理解了这种观点。就仿佛是我期待着下雪，想到下雪后的第一件事就是拍张照片，然后告诉某人，“下雪了”，这是一样的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableView上方总是有一截留白的解决方法]]></title>
      <url>http://yoursite.com/2015/09/29/TableView%E4%B8%8A%E6%96%B9%E6%80%BB%E6%98%AF%E6%9C%89%E4%B8%80%E6%88%AA%E7%95%99%E7%99%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>不知道从哪个版本（大概是iOS8）开始，如果你用了autolayout，当你设置某个tableview（或者任意scrollview）顶部约束为顶格的适合，它总会多出来一个留白，其实解决方法很简单，在该viewcontroller的.m文件中把automaticallyAdjustsScrollViewInsets这个属性设置成false就可以了。鬼知道谁设计的留白。。。</p>
]]></content>
    </entry>
    
  
  
</search>
