<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Leetcode-100-Same Tree]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-100-Same-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定两个二叉树，写一个函数来检查它们是否相同。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>递归调用函数，检查左右子树以及根节点的值是否相同。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        bool isSameTree(TreeNode* p, TreeNode* q) {
            if(!p&amp;&amp;!q) return true;
            if((p&amp;&amp;!q)||(!p&amp;&amp;q)) return false;
            return (p-&gt;val==q-&gt;val)&amp;&amp;isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-237-Delete Node in a Linked List]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-237-Delete-Node-in-a-Linked-List/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>删除一个链表中的结点，你只能获取该结点的指针。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>有点像脑筋急转弯。很简单，将这个结点的next结点拷贝到这个结点就可以了。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        void deleteNode(ListNode* node) {
            node-&gt;val=node-&gt;next-&gt;val;
            node-&gt;next=node-&gt;next-&gt;next;
        }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-260-Single Number III]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-260-Single-Number-III/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，其中有两个元素只出现了一次，其他的元素出现了2次，找出这两个只出现过一次的元素。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>第一步与<a href="/2016/05/23/Leetcode-136-Single-Number/">simgle number I</a> 一样，先求出所有的数字的^结果，此时假设这两个数是a和b,那么我们已经得到了a^b的结果。那么我们如何将这两个数分开呢。^运算的结果是同位相等为0，不等为1.那么我们就可以找出a和b不相等的最低位，然后把原数组分成两个子数组，接着使用我们<a href="/2016/05/23/Leetcode-136-Single-Number/">simgle number I</a> 中使用的方法即可求解两个数。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
            int tem = 0;
            for(int i=0;i&lt;nums.size();i++)
                tem^=nums[i];
            int last = tem-(tem&amp;(tem-1));//求出tem中最低“1”位
            int first = 0; int second = 0;
            for(int i=0;i&lt;nums.size();i++)
                {
                    if(nums[i]&amp;last)
                        first^=nums[i];
                    else
                        second^=nums[i];
                }
            vector&lt;int&gt; ans;
            ans.push_back(first);
            ans.push_back(second);
            return ans;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-283-Move Zeroes]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-283-Move-Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，写一个函数把所有的0都移动到数组的末端且非0元素的相对位置不变。<br>你没有额外的存储空间来复制一遍数组。且使移动操作次数最少。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>用一个指针指向第一个0的坐标，如果不是0，则交换0坐标上的数字与当前数字</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        void moveZeroes(vector&lt;int&gt;&amp; nums) {
            int mark = 0;
            for(int i =0;i&lt;nums.size();i++)
                {
                    if(nums[i]!=0)
                           swap(nums[i],nums[mark++]);     
                }

            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-349-Intersection of Two Arrays]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-349-Intersection-of-Two-Arrays/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>找到两个集合的交集，并且注意交集中每个元素只能出现一次。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>很简单的hash map的题，遍历a中每一个元素，只要在b中出现的，如果没有添加过，则添加到结果集合中。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        vector&lt;int&gt; res;
        if(!nums1.empty()||!nums2.empty())
            for(int i=0;i&lt;nums1.size();i++)
                {
                    if(find(nums2.begin(),nums2.end(),nums1[i])!=nums2.end())//if nums1[i] is in nums2
                        if(find(res.begin(),res.end(),nums1[i])==res.end())// if nums[i] not in res
                            res.push_back(nums1[i]);
                }
            return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-226-Invert Binay Tree]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-226-Invert-Binay-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Invert a binary tree.</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>to</p>
<pre><code>      4
    /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><a id="more"></a>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>反转一个二叉树</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>递归调用函数本身即可，注意边界条件。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
           TreeNode* invertTree(TreeNode* root) {
            if(!root) return root;
            if(!root-&gt;left&amp;&amp;!root-&gt;right) return root;
            else{
                TreeNode* teml = invertTree(root-&gt;right);
                TreeNode* temr = invertTree(root-&gt;left);
                root-&gt;left= teml;
                root-&gt;right=temr;
                return root;
                    }

            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-104-Maximum Depth of Binary Tree]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-104-Maximum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个二叉树，返回它的最大深度</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>递归调用本函数，返回左右子树的最大深度中较大值+1即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    public:
        int maxDepth(TreeNode* root) {
            if(!root) return 0;
            else
                return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-258-Add Digits]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-258-Add-Digits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个非负整数，重复累加它的每一位，直到生成的新数字只有一位。<br>例如：38-》3+8=11-》1+1=2.此时返回2.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这里提供两种方法，第一种是正常的循环解题思路，另一种是数学的方法。数学方法请参见<a href="https://en.wikipedia.org/wiki/Digital_root" target="_blank" rel="external">这篇wiki文章</a>.循环解法只需要按照题目要求累加每一位数字即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int addDigits(int num) {
            switch(num)
                {
                    case 0: return 0;
                    default: return (num-1)%9+1;
                }
            }
    };
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-136-Single Number]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-136-Single-Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given an array of integers, every element appears twice except for one. Find that single one.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个数组，其中除了某一个数字以外其他数字都出现过两次，找出这个数字。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题方法有许多，这里本文介绍最简单的一种，使用位运算，一个数字a^b^b以后仍然为它本身。这样，把整个数组^一次即可。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int singleNumber(vector&lt;int&gt;&amp; nums) {
            int res=0;
            for(int i=0;i&lt;nums.size();i++)
                res^=nums[i];

            return res;

        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-292-Nim Game]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-292-Nim-Game/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>你和朋友玩一个取石子的游戏，每一个人可以取1-3个石子，假如你们俩都能每一步做出最优选择，那么当你先取的时候，输入一个石子数，返回你是否能取得胜利。</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>这道题仔细分析其实并不难。当石子数为4的整数倍的时候，总是后手胜利，因为不管先手拿走了n(1-3)枚石子，你总是拿走4-n枚，即可获胜，其他情况下，先手可以把自己变为后手，即取走余数。所以想通了这一点之后这道题变得非常简单。即判断先手是否胜利的条件在于石子数能否被4整除。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        bool canWinNim(int n) {
            return n%4;
        }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-191-Number of 1 Bits]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-191-Number-of-1-Bits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>写一个函数，返回某一数字二进制表示中1出现的次数</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>利用位运算中&amp;操作符号，和指定数的每一位都单独&amp;一次，如果是1，则会返回1，再使用一个计数器实现统计。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        int hammingWeight(uint32_t n) {
            int count=0;
            for(int i=0;i&lt;32;i++)
                if(n&amp;1&lt;&lt;i) count++;

            return count;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-338-Counting Bits]]></title>
      <url>http://yoursite.com/2016/05/23/Leetcode-338-Counting-Bits/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p>
<p>Follow up:</p>
<p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>输入一个数字，输出从0开始到该数字为止的所有数字二进制表示中1的个数.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>对于最基本的解题思路，如果使用O(n*sizeof(integer))的时间的话,可以写一个统计某个数之中出现“1”的次数的函数，正如<a href="/2016/05/23/Leetcode-191-Number-of-1-Bits/">这一题</a>，然后从0开始循环调用N次。<br>但是我们通过观察二进制的规律不难发现，除了2的整数次幂只有一个1以外，每多一位，立马会从0开始到这个数字为止全部重复一次。动态规划转移方程为a[n]=1(如果n为2的整数次幂)，a[n]=1+a[mark] （mark为我们的标记）我们用两个标记变量，一个表示2的整数次幂，另一个表示已经循环到的数字，每次经过2的整数次幂后，该标记归0。这样便能把时间复杂度降低为O(n)，而且只用使用O(n)的额外空间。</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
    public:
        vector&lt;int&gt; countBits(int num) {
            vector&lt;int&gt; res(num+1);
            if(num==0) return res;
            else {

                res[0]=0;
                int power=1;
                int mark=1;
                for(int i =1;i&lt;=num;i++)
                    {
                        if(i==power)
                            {
                                    res[i]=1;
                                    power&lt;&lt;=1;
                                    mark=1;
                            }else
                        {
                              res[i]=1+res[mark];
                              mark++;
                        }
                    }
                }
            return res;

    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode-344-Reverse String]]></title>
      <url>http://yoursite.com/2016/05/22/Leetcode-344-Reverse-String/</url>
      <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description:"></a>Problem Description:</h2><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example:<br>Given s = “hello”, return “olleh”.<br><a id="more"></a></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>反转一个给定字符串</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions:"></a>Solutions:</h2><p>简单的倒序添加每一个字符即可</p>
<h2 id="Code-in-C"><a href="#Code-in-C" class="headerlink" title="Code in C++:"></a>Code in C++:</h2><pre><code>class Solution {
public:
    string reverseString(string s) {
        string res=&quot;&quot;;
        for(int i = 0; i&lt;s.length();i++)
        res=s[i]+res;

        return res;
    }
};
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2015/10/20/Hello-World/</url>
      <content type="html"><![CDATA[<p>由于上一次惨痛的经历。。。重装系统忘记备份博客源码。我决定使用Time Machine。。。没啥好说的，心情十分复杂，就这样。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[随手小记]]></title>
      <url>http://yoursite.com/2015/10/15/%E9%9A%8F%E6%89%8B%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>今天终于刷完了Leetcode最后一道我能做的Easy难度。明天就要迈向Medium了。想到Z君说的easy 5分钟一道，我还是太年轻了么果然。。。加油吧。。。坚持就是胜利！逐渐成为一个合格的码农！不过通过这两周来的训练，我觉得我自己的代码能力确实有了一个很大的提升。No pains, no gains.加油吧。从0到1比从1到2难多了，非常庆幸自己能迈出第一步。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Latex使用经验1——用bibtex添加引用]]></title>
      <url>http://yoursite.com/2015/10/02/Latex%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C1%E2%80%94%E2%80%94%E7%94%A8bibtex%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>用bibtex添加引用</p>
<h2 id="第一步：建立一个tex文件"><a href="#第一步：建立一个tex文件" class="headerlink" title="第一步：建立一个tex文件"></a>第一步：建立一个tex文件</h2><p>任何一种你想要方法建立一个tex文件，假如说叫a.tex</p>
<p>在文章末尾\end{document}之前加入以下三行：<br>\renewcommand\refname{Reference}<br>\bibliographystyle{plain}<br>\bibliography{b}<br>其中第一行是参考文献的标题，标题是Reference；第二行是格式，还有其他格式见此处，这里用plain；第三行是一个bib格式文件的名字，最好和tex文件名称一致，编译起来方便一些。<br>(有一点小小要注意的地方：最常见的引用格式是plain，它是按作者字母排序的，如果要按引用顺序来排序，推荐用格式unsrt)</p>
<h2 id="第二步：建立一个bib文件"><a href="#第二步：建立一个bib文件" class="headerlink" title="第二步：建立一个bib文件"></a>第二步：建立一个bib文件</h2><p>bib文件就是一个plain text文件，明明为b.bib，bib格式可以在各种数据库里面的citation找到，例如<br>@book{Book1,<br>title = “Title1”,<br>author = “author1”,<br>publisher = “publisher1”,<br>year = “2015”<br>}</p>
<h2 id="第三步：在tex文件中引用"><a href="#第三步：在tex文件中引用" class="headerlink" title="第三步：在tex文件中引用"></a>第三步：在tex文件中引用</h2><p>在需要引用的地方使用\cite{Book1},期中Book1是你在bib文件中给每个引用的名字</p>
<h2 id="第四步：运行-tex文件"><a href="#第四步：运行-tex文件" class="headerlink" title="第四步：运行.tex文件"></a>第四步：运行.tex文件</h2><p>可以直接运行texshop里面的排版或者用命令行 pdflatex a(a是咱们.tex文件的名字)</p>
<h2 id="第五步：运行-bib文件"><a href="#第五步：运行-bib文件" class="headerlink" title="第五步：运行.bib文件"></a>第五步：运行.bib文件</h2><p>用bibtex b(b是咱们.bib文件的名字)，注意：一定要先运行pdflatex命令，因为运行后会生成aux文件，而编译bib是需要aux文件的、</p>
<h2 id="第六步：运行-tex文件2次"><a href="#第六步：运行-tex文件2次" class="headerlink" title="第六步：运行.tex文件2次"></a>第六步：运行.tex文件2次</h2><p>对，你没看错，运行2次，才能正确生成引用和引用目录，原理我也不知道，就这么用就行了！pdflatex a 这个命令运行2次就行了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[今天的月亮很美]]></title>
      <url>http://yoursite.com/2015/10/01/%E4%BB%8A%E5%A4%A9%E7%9A%84%E6%9C%88%E4%BA%AE%E5%BE%88%E7%BE%8E/</url>
      <content type="html"><![CDATA[<p>前几天中秋节，在美帝幸运地看到了血月和月全食之后。突然想起了夏目漱石问学生如何翻译“i love you”这个问题。他给学生的答案是“今天的月亮很美”。想起曾经和人谈论过这个问题，当时觉得有种听到“今天的风儿真是喧嚣”的感觉。其实我觉得我现在能理解了这种观点。就仿佛是我期待着下雪，想到下雪后的第一件事就是拍张照片，然后告诉某人，“下雪了”，这是一样的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableView上方总是有一截留白的解决方法]]></title>
      <url>http://yoursite.com/2015/09/29/TableView%E4%B8%8A%E6%96%B9%E6%80%BB%E6%98%AF%E6%9C%89%E4%B8%80%E6%88%AA%E7%95%99%E7%99%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>不知道从哪个版本（大概是iOS8）开始，如果你用了autolayout，当你设置某个tableview（或者任意scrollview）顶部约束为顶格的适合，它总会多出来一个留白，其实解决方法很简单，在该viewcontroller的.m文件中把automaticallyAdjustsScrollViewInsets这个属性设置成false就可以了。鬼知道谁设计的留白。。。</p>
]]></content>
    </entry>
    
  
  
</search>
